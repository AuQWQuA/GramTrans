{"task_id": "Mbpp/2", "origin_solution": "<def_stmt>similar_elements list1 list2<block_start><return>set(list1)&set(list2)<block_end>\n", "solution": "\ndef similar_elements (list1, list2):\n    return set(list1)&set(list2)\n    \n\n"}
{"task_id": "Mbpp/3", "origin_solution": "<def_stmt>is_not_prime n<block_start><if_stmt>n<le>1<block_start><return><true><block_end><for_stmt>i range(2 int(n<power>0.5)+1)<block_start><if_stmt>n%i<eq>0<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef is_not_prime (n):\n    if n<=1:\n        return  True \n        \n    for i in range(2, int(n**0.5)+1):\n        if n%i==0:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/4", "origin_solution": "<import_stmt>heapq<def_stmt>heap_queue_largest nums n<block_start>largest_nums=heapq.nlargest(n nums)<line_sep><return>largest_nums<block_end>\n", "solution": "\nimport heapq\ndef heap_queue_largest (nums, n):\n    largest_nums=heapq.nlargest(n, nums)\n    return largest_nums\n    \n\n"}
{"task_id": "Mbpp/6", "origin_solution": "<def_stmt>differ_At_One_Bit_Pos x y<block_start>x_bin=bin(x)[2:]<line_sep>y_bin=bin(y)[2:]<line_sep>max_len=max(len(x_bin) len(y_bin))<line_sep>x_bin=x_bin.zfill(max_len)<line_sep>y_bin=y_bin.zfill(max_len)<line_sep>differ_at_one_bit=<false><for_stmt>i range(max_len)<block_start><if_stmt>x_bin[i]<ne>y_bin[i]<block_start>differ_at_one_bit=<true><line_sep><break><block_end><block_end><return>differ_at_one_bit<block_end>\n", "solution": "\ndef differ_At_One_Bit_Pos (x, y):\n    x_bin=bin(x)[2:]\n    y_bin=bin(y)[2:]\n    max_len=max(len(x_bin), len(y_bin))\n    x_bin=x_bin.zfill(max_len)\n    y_bin=y_bin.zfill(max_len)\n    differ_at_one_bit= False \n    for i in range(max_len):\n        if x_bin[i]!=y_bin[i]:\n            differ_at_one_bit= True \n            break \n            \n    \n    return differ_at_one_bit\n    \n\n"}
{"task_id": "Mbpp/7", "origin_solution": "<def_stmt>find_char_long s:str<arrow>list<block_start>words=s.split()<line_sep>result=[word<for>word words<if>len(word)<ge>4]<line_sep><return>result<block_end>\n", "solution": "\ndef find_char_long (s:str)->list:\n    words=s.split()\n    result=[word for word in words if len(word)>=4]\n    return result\n    \n\n"}
{"task_id": "Mbpp/8", "origin_solution": "<def_stmt>square_nums nums<block_start><return>[num<power>2<for>num nums]<block_end>\n", "solution": "\ndef square_nums (nums):\n    return [num**2 for num in nums]\n    \n\n"}
{"task_id": "Mbpp/9", "origin_solution": "<def_stmt>find_Rotations s<block_start>n=len(s)<for_stmt>i range(1 n)<block_start>rotated=s[i:]+s[:i]<if_stmt>rotated<eq>s<block_start><return>i<block_end><block_end><return>n<block_end>\n", "solution": "\ndef find_Rotations (s):\n    n=len(s)\n    for i in range(1, n):\n        rotated=s[i:]+s[:i]\n        if rotated==s:\n            return i\n            \n    \n    return n\n    \n\n"}
{"task_id": "Mbpp/11", "origin_solution": "<def_stmt>remove_Occ s char<block_start>index1=s.find(char)<line_sep>index2=s.rfind(char)<if_stmt>index1<eq>-1<or>index2<eq>-1<block_start><return>s<block_end><return>s[:index1]+s[index1+1:][:index2]+s[index2+1:]<block_end>\n", "solution": "\ndef remove_Occ (s, char):\n    index1=s.find(char)\n    index2=s.rfind(char)\n    if index1==-1 or index2==-1:\n        return s\n        \n    return s[:index1]+s[index1+1:][:index2]+s[index2+1:]\n    \n\n"}
{"task_id": "Mbpp/12", "origin_solution": "<def_stmt>sort_matrix matrix<block_start>row_sums=[(sum(row) row)<for>row matrix]<line_sep>sorted_row_sums=sorted(row_sums key=<lambda>x:x[0])<line_sep>sorted_matrix=[row<for>_,row sorted_row_sums]<line_sep><return>sorted_matrix<block_end>\n", "solution": "\ndef sort_matrix (matrix):\n    row_sums=[(sum(row), row) for row in matrix]\n    sorted_row_sums=sorted(row_sums, key=lambda x:x[0])\n    sorted_matrix=[row for _,row in sorted_row_sums]\n    return sorted_matrix\n    \n\n"}
{"task_id": "Mbpp/14", "origin_solution": "<def_stmt>find_Volume base height length<block_start>volume=(1/2)<times>base<times>height<times>length<line_sep><return>volume<block_end>\n", "solution": "\ndef find_Volume (base, height, length):\n    volume=(1/2)*base*height*length\n    return volume\n    \n\n"}
{"task_id": "Mbpp/16", "origin_solution": "<import_stmt>re<def_stmt>text_lowercase_underscore text<block_start><return>bool(re.search(r'^[a-z]+_[a-z]+$' text))<block_end>\n", "solution": "\nimport re\ndef text_lowercase_underscore (text):\n    return bool(re.search(r'^[a-z]+_[a-z]+$', text))\n    \n\n"}
{"task_id": "Mbpp/17", "origin_solution": "<def_stmt>square_perimeter side_length<block_start><return>4<times>side_length<block_end>\n", "solution": "\ndef square_perimeter (side_length):\n    return 4*side_length\n    \n\n"}
{"task_id": "Mbpp/18", "origin_solution": "<def_stmt>remove_dirty_chars s:str t:str<arrow>str<block_start>\"\"\"\n    Removes characters from the first string which are present in the second string.\n    \n    :param s: The original string.\n    :param t: The string containing characters to be removed from s.\n    :return: The resulting string after removing characters found in t from s.\n    \"\"\"<line_sep>chars_to_remove=set(t)<line_sep>result=[char<for>char s<if>char<not><in>chars_to_remove]<line_sep><return>''.join(result)<block_end>\n", "solution": "\ndef remove_dirty_chars (s:str, t:str)->str:\n    \"\"\"\n    Removes characters from the first string which are present in the second string.\n    \n    :param s: The original string.\n    :param t: The string containing characters to be removed from s.\n    :return: The resulting string after removing characters found in t from s.\n    \"\"\"\n    chars_to_remove=set(t)\n    result=[char for char in s if char not  in chars_to_remove]\n    return ''.join(result)\n    \n\n"}
{"task_id": "Mbpp/19", "origin_solution": "<def_stmt>test_duplicate arr<block_start>seen=set()<for_stmt>num arr<block_start><if_stmt>num<in>seen<block_start><return><true><block_end>seen.add(num)<block_end><return><false><block_end>\n", "solution": "\ndef test_duplicate (arr):\n    seen=set()\n    for num in arr:\n        if num in seen:\n            return  True \n            \n        seen.add(num)\n        \n    return  False \n    \n\n"}
{"task_id": "Mbpp/20", "origin_solution": "<def_stmt>is_woodall n<block_start><return>n%29<eq>0<block_end>\n", "solution": "\ndef is_woodall (n):\n    return n%29==0\n    \n\n"}
{"task_id": "Mbpp/56", "origin_solution": "<def_stmt>check num<block_start>\"\"\"\n    Check if a given number is one less than twice its reverse.\n    \"\"\"<line_sep>reverse_num=int(str(num)[::-1])<line_sep><return>num<eq>2<times>reverse_num-1<block_end>\n", "solution": "\ndef check (num):\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n    \"\"\"\n    reverse_num=int(str(num)[::-1])\n    return num==2*reverse_num-1\n    \n\n"}
{"task_id": "Mbpp/57", "origin_solution": "<def_stmt>find_Max_Num digits<block_start>digits=list(map(str digits))<line_sep>digits.sort(reverse=<true>)<line_sep><return>int(''.join(digits))<block_end>\n", "solution": "\ndef find_Max_Num (digits):\n    digits=list(map(str, digits))\n    digits.sort(reverse= True )\n    return int(''.join(digits))\n    \n\n"}
{"task_id": "Mbpp/58", "origin_solution": "<def_stmt>opposite_Signs a b<block_start><return>a<times>b<l>0<block_end>\n", "solution": "\ndef opposite_Signs (a, b):\n    return a*b<0\n    \n\n"}
{"task_id": "Mbpp/59", "origin_solution": "<def_stmt>is_octagonal n<block_start><return>n<times>(7<times>n-5)<floordiv>2<block_end>\n", "solution": "\ndef is_octagonal (n):\n    return n*(7*n-5)//2\n    \n\n"}
{"task_id": "Mbpp/61", "origin_solution": "<def_stmt>count_Substrings s:str<arrow>int<block_start>count=0<for_stmt>i range(len(s))<block_start>sum_digits=sum(int(digit)<for>digit s[i:])<if_stmt>i+1<eq>sum_digits<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_Substrings (s:str)->int:\n    count=0\n    for i in range(len(s)):\n        sum_digits=sum(int(digit) for digit in s[i:])\n        if i+1==sum_digits:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/62", "origin_solution": "<def_stmt>smallest_num lst<block_start><return>min(lst)<block_end>\n", "solution": "\ndef smallest_num (lst):\n    return min(lst)\n    \n\n"}
{"task_id": "Mbpp/63", "origin_solution": "<def_stmt>max_difference lst<block_start>lst.sort(key=<lambda>x:x[1])<line_sep>max_diff=0<for_stmt>i range(len(lst)-1)<block_start>diff=lst[i+1][0]-lst[i][0]<if_stmt>diff<g>max_diff<block_start>max_diff=diff<block_end><block_end><return>max_diff<block_end>\n", "solution": "\ndef max_difference (lst):\n    lst.sort(key=lambda x:x[1])\n    max_diff=0\n    for i in range(len(lst)-1):\n        diff=lst[i+1][0]-lst[i][0]\n        if diff>max_diff:\n            max_diff=diff\n            \n    \n    return max_diff\n    \n\n"}
{"task_id": "Mbpp/64", "origin_solution": "<def_stmt>subject_marks test_list<block_start><return>sorted(test_list key=<lambda>x:x[1])<block_end>\n", "solution": "\ndef subject_marks (test_list):\n    return sorted(test_list, key=lambda x:x[1])\n    \n\n"}
{"task_id": "Mbpp/65", "origin_solution": "<def_stmt>recursive_list_sum lst<block_start>total=0<for_stmt>element lst<block_start><if_stmt>isinstance(element list)<block_start>total<augadd>recursive_list_sum(element)<block_end><else_stmt><block_start>total<augadd>element<block_end><block_end><return>total<block_end>\n", "solution": "\ndef recursive_list_sum (lst):\n    total=0\n    for element in lst:\n        if isinstance(element, list):\n            total+=recursive_list_sum(element)\n            \n        \n        else :\n            total+=element\n            \n    \n    return total\n    \n\n"}
{"task_id": "Mbpp/66", "origin_solution": "<def_stmt>pos_count nums<block_start>count=0<for_stmt>num nums<block_start><if_stmt>num<g>0<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef pos_count (nums):\n    count=0\n    for num in nums:\n        if num>0:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/67", "origin_solution": "<def_stmt>bell_number n<block_start>bell=[[0<for>i range(n+1)]<for>j range(n+1)] bell[0][0]=1<for_stmt>i range(1 n+1)<block_start>bell[i][0]=bell[i-1][i-1]<for_stmt>j range(1 i+1)<block_start>bell[i][j]=bell[i-1][j-1]+bell[i][j-1]<block_end><block_end><return>bell[n][0]<block_end>print(bell_number(2))<line_sep>print(bell_number(10))<line_sep>print(bell_number(56))<line_sep>\n", "solution": "\ndef bell_number (n):\n    bell=[[0 for i in range(n+1)] for j in range(n+1)], bell[0][0]=1\n    for i in range(1, n+1):\n        bell[i][0]=bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j]=bell[i-1][j-1]+bell[i][j-1]\n            \n    \n    return bell[n][0]\n    \nprint(bell_number(2))\nprint(bell_number(10))\nprint(bell_number(56))\n\n"}
{"task_id": "Mbpp/68", "origin_solution": "<def_stmt>is_Monotonic nums<block_start>increasing=decreasing=<true><for_stmt>i range(1 len(nums))<block_start><if_stmt>nums[i]<g>nums[i-1]<block_start>decreasing=<false><block_end><if_stmt>nums[i]<l>nums[i-1]<block_start>increasing=<false><block_end><block_end><return>increasing<or>decreasing<block_end>\n", "solution": "\ndef is_Monotonic (nums):\n    increasing=decreasing= True \n    for i in range(1, len(nums)):\n        if nums[i]>nums[i-1]:\n            decreasing= False \n            \n        if nums[i]<nums[i-1]:\n            increasing= False \n            \n    \n    return increasing or decreasing\n    \n\n"}
{"task_id": "Mbpp/69", "origin_solution": "<def_stmt>is_sublist lst sublst<block_start>sub_len=len(sublst)<for_stmt>i range(len(lst)-sub_len+1)<block_start><if_stmt>lst[i:i+sub_len]<eq>sublst<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef is_sublist (lst, sublst):\n    sub_len=len(sublst)\n    for i in range(len(lst)-sub_len+1):\n        if lst[i:i+sub_len]==sublst:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/70", "origin_solution": "<def_stmt>get_equal tuples<block_start>length=len(tuples[0])<for_stmt>t tuples<block_start><if_stmt>len(t)<ne>length<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef get_equal (tuples):\n    length=len(tuples[0])\n    for t in tuples:\n        if len(t)!=length:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/71", "origin_solution": "<def_stmt>comb_sort arr<block_start>gap=len(arr)<line_sep>swapped=<true><while_stmt>gap<g>1<or>swapped<is><true><block_start>gap=max(1 int(gap/1.3))<line_sep>swapped=<false><for_stmt>i range(len(arr)-gap)<block_start><if_stmt>arr[i]<g>arr[i+gap]<block_start>arr[i],arr[i+gap]=arr[i+gap] arr[i]<line_sep>swapped=<true><block_end><block_end><block_end><return>arr<block_end>\n", "solution": "\ndef comb_sort (arr):\n    gap=len(arr)\n    swapped= True \n    while gap>1 or swapped is  True :\n        gap=max(1, int(gap/1.3))\n        swapped= False \n        for i in range(len(arr)-gap):\n            if arr[i]>arr[i+gap]:\n                arr[i],arr[i+gap]=arr[i+gap], arr[i]\n                swapped= True \n                \n        \n    \n    return arr\n    \n\n"}
{"task_id": "Mbpp/72", "origin_solution": "<def_stmt>dif_Square n<block_start><for_stmt>i range(int(n<power>0.5)+1)<block_start>j=n-(i<power>2)<if_stmt>int(j<power>0.5)<power>2<eq>j<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef dif_Square (n):\n    for i in range(int(n**0.5)+1):\n        j=n-(i**2)\n        if int(j**0.5)**2==j:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/74", "origin_solution": "<def_stmt>is_samepatterns patterns:list strings:list<arrow>bool<block_start><if_stmt>len(patterns)<ne>len(strings)<block_start><return><false><block_end><for_stmt>i range(len(patterns))<block_start><if_stmt>patterns[i]<not><in>strings[i]<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef is_samepatterns (patterns:list, strings:list)->bool:\n    if len(patterns)!=len(strings):\n        return  False \n        \n    for i in range(len(patterns)):\n        if patterns[i] not  in strings[i]:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/75", "origin_solution": "<def_stmt>find_tuples tuples_list k<block_start>result=[]<for_stmt>tup tuples_list<block_start><if_stmt>all(i%k<eq>0<for>i tup)<block_start>result.append(tup)<block_end><block_end><return>result<block_end>\n", "solution": "\ndef find_tuples (tuples_list, k):\n    result=[]\n    for tup in tuples_list:\n        if all(i%k==0 for i in tup):\n            result.append(tup)\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/77", "origin_solution": "<def_stmt>is_Diff n<block_start><return>n%11<eq>0<block_end>\n", "solution": "\ndef is_Diff (n):\n    return n%11==0\n    \n\n"}
{"task_id": "Mbpp/79", "origin_solution": "<def_stmt>word_len word<block_start><return>len(word)%2<ne>0<block_end>\n", "solution": "\ndef word_len (word):\n    return len(word)%2!=0\n    \n\n"}
{"task_id": "Mbpp/80", "origin_solution": "<def_stmt>tetrahedral_number n<block_start><return>n<times>(n+1)<times>(n+2)<floordiv>6<block_end>\n", "solution": "\ndef tetrahedral_number (n):\n    return n*(n+1)*(n+2)//6\n    \n\n"}
{"task_id": "Mbpp/82", "origin_solution": "<import_stmt>math<def_stmt>volume_sphere radius<block_start>volume=(4/3)<times>math.pi<times>(radius<power>3)<line_sep><return>volume<block_end>\n", "solution": "\nimport math\ndef volume_sphere (radius):\n    volume=(4/3)*math.pi*(radius**3)\n    return volume\n    \n\n"}
{"task_id": "Mbpp/84", "origin_solution": "<def_stmt>sequence n<block_start>\"\"\"\n    Calculate the nth number in the newman conway sequence.\n    \n    Args:\n    n (int): The position in the sequence to calculate.\n    \n    Returns:\n    int: The nth number in the newman conway sequence.\n    \"\"\"<if_stmt>n<eq>1<block_start><return>1<block_end><elif_stmt>n<eq>2<block_start><return>2<block_end><else_stmt><block_start>a,b=1 2<for_stmt>_ range(3 n+1)<block_start>a,b=b a+b<block_end><return>b<block_end><block_end>\n", "solution": "\ndef sequence (n):\n    \"\"\"\n    Calculate the nth number in the newman conway sequence.\n    \n    Args:\n    n (int): The position in the sequence to calculate.\n    \n    Returns:\n    int: The nth number in the newman conway sequence.\n    \"\"\"\n    if n==1:\n        return 1\n        \n    \n    elif n==2:\n        return 2\n        \n    \n    else :\n        a,b=1, 2\n        for _ in range(3, n+1):\n            a,b=b, a+b\n            \n        return b\n        \n\n\n"}
{"task_id": "Mbpp/85", "origin_solution": "<import_stmt>math<def_stmt>surfacearea_sphere r<block_start>surface_area=4<times>math.pi<times>r<power>2<line_sep><return>surface_area<block_end>\n", "solution": "\nimport math\ndef surfacearea_sphere (r):\n    surface_area=4*math.pi*r**2\n    return surface_area\n    \n\n"}
{"task_id": "Mbpp/86", "origin_solution": "<def_stmt>centered_hexagonal_number n<block_start><return>3<times>n<times>(n-1)+1<block_end>\n", "solution": "\ndef centered_hexagonal_number (n):\n    return 3*n*(n-1)+1\n    \n\n"}
{"task_id": "Mbpp/87", "origin_solution": "<def_stmt>merge_dictionaries_three dict1 dict2 dict3<block_start>merged_dict=dict1.copy()<line_sep>merged_dict.update(dict2)<line_sep>merged_dict.update(dict3)<line_sep><return>merged_dict<block_end>\n", "solution": "\ndef merge_dictionaries_three (dict1, dict2, dict3):\n    merged_dict=dict1.copy()\n    merged_dict.update(dict2)\n    merged_dict.update(dict3)\n    return merged_dict\n    \n\n"}
{"task_id": "Mbpp/88", "origin_solution": "<def_stmt>freq_count lst<block_start>freq={}<for_stmt>item lst<block_start><if_stmt>item<in>freq<block_start>freq[item]<augadd>1<block_end><else_stmt><block_start>freq[item]=1<block_end><block_end><return>freq<block_end>\n", "solution": "\ndef freq_count (lst):\n    freq={}\n    for item in lst:\n        if item in freq:\n            freq[item]+=1\n            \n        \n        else :\n            freq[item]=1\n            \n    \n    return freq\n    \n\n"}
{"task_id": "Mbpp/89", "origin_solution": "<def_stmt>closest_num n<block_start>i=int(n)<if_stmt>i<g>0<block_start>i<augsub>1<block_end><return>i<block_end>\n", "solution": "\ndef closest_num (n):\n    i=int(n)\n    if i>0:\n        i-=1\n        \n    return i\n    \n\n"}
{"task_id": "Mbpp/90", "origin_solution": "<def_stmt>len_log lst<block_start><return>max(len(word)<for>word lst)<block_end>\n", "solution": "\ndef len_log (lst):\n    return max(len(word) for word in lst)\n    \n\n"}
{"task_id": "Mbpp/91", "origin_solution": "<def_stmt>find_substring string_list substring<block_start><return>any(substring<in>s<for>s string_list)<block_end>\n", "solution": "\ndef find_substring (string_list, substring):\n    return any(substring in s for s in string_list)\n    \n\n"}
{"task_id": "Mbpp/92", "origin_solution": "<def_stmt>is_undulating number<block_start>str_num=str(number)<for_stmt>i range(len(str_num)-2)<block_start><if_stmt>str_num[i]<ne>str_num[i+1]<or>str_num[i+1]<ne>str_num[i+2]<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef is_undulating (number):\n    str_num=str(number)\n    for i in range(len(str_num)-2):\n        if str_num[i]!=str_num[i+1] or str_num[i+1]!=str_num[i+2]:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/93", "origin_solution": "<def_stmt>power a b<block_start><return>a<power>b<block_end>\n", "solution": "\ndef power (a, b):\n    return a**b\n    \n\n"}
{"task_id": "Mbpp/94", "origin_solution": "<def_stmt>index_minimum list_of_tuples<block_start>min_tuple=min(list_of_tuples key=<lambda>x:x[1])<line_sep><return>min_tuple[0]<block_end>\n", "solution": "\ndef index_minimum (list_of_tuples):\n    min_tuple=min(list_of_tuples, key=lambda x:x[1])\n    return min_tuple[0]\n    \n\n"}
{"task_id": "Mbpp/95", "origin_solution": "<def_stmt>Find_Min_Length list_of_lists<block_start><return>min(len(sublist)<for>sublist list_of_lists)<block_end>\n", "solution": "\ndef Find_Min_Length (list_of_lists):\n    return min(len(sublist) for sublist in list_of_lists)\n    \n\n"}
{"task_id": "Mbpp/96", "origin_solution": "<def_stmt>divisor n<block_start>count=0<for_stmt>i range(1 n+1)<block_start><if_stmt>n%i<eq>0<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef divisor (n):\n    count=0\n    for i in range(1, n+1):\n        if n%i==0:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/97", "origin_solution": "<def_stmt>frequency_lists lists<block_start>flattened_list=[item<for>sublist lists<for>item sublist]<line_sep>frequency_dict={}<for_stmt>item flattened_list<block_start><if_stmt>item<in>frequency_dict<block_start>frequency_dict[item]<augadd>1<block_end><else_stmt><block_start>frequency_dict[item]=1<block_end><block_end><return>frequency_dict<block_end>\n", "solution": "\ndef frequency_lists (lists):\n    flattened_list=[item for sublist in lists for item in sublist]\n    frequency_dict={}\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item]+=1\n            \n        \n        else :\n            frequency_dict[item]=1\n            \n    \n    return frequency_dict\n    \n\n"}
{"task_id": "Mbpp/98", "origin_solution": "<def_stmt>multiply_num nums<block_start>product=1<for_stmt>num nums<block_start>product<augmul>num<block_end><return>product/len(nums)<block_end>\n", "solution": "\ndef multiply_num (nums):\n    product=1\n    for num in nums:\n        product*=num\n        \n    return product/len(nums)\n    \n\n"}
{"task_id": "Mbpp/99", "origin_solution": "<def_stmt>decimal_to_binary decimal_num<block_start><if_stmt>decimal_num<eq>0<block_start><return>'0'<block_end>binary_str=''<while_stmt>decimal_num<g>0<block_start>binary_str=str(decimal_num%2)+binary_str<line_sep>decimal_num=decimal_num<floordiv>2<block_end><return>binary_str.lstrip('0')<or>'0'<block_end>\n", "solution": "\ndef decimal_to_binary (decimal_num):\n    if decimal_num==0:\n        return '0'\n        \n    binary_str=''\n    while decimal_num>0:\n        binary_str=str(decimal_num%2)+binary_str\n        decimal_num=decimal_num//2\n        \n    return binary_str.lstrip('0') or '0'\n    \n\n"}
{"task_id": "Mbpp/100", "origin_solution": "<def_stmt>next_smallest_palindrome n<block_start>n<augadd>1<while_stmt>str(n)<ne>str(n)[::-1]<block_start>n<augadd>1<block_end><return>n<block_end>\n", "solution": "\ndef next_smallest_palindrome (n):\n    n+=1\n    while str(n)!=str(n)[::-1]:\n        n+=1\n        \n    return n\n    \n\n"}
{"task_id": "Mbpp/101", "origin_solution": "<def_stmt>kth_element arr k<block_start><return>arr[k-1]<block_end>\n", "solution": "\ndef kth_element (arr, k):\n    return arr[k-1]\n    \n\n"}
{"task_id": "Mbpp/102", "origin_solution": "<def_stmt>snake_to_camel snake_str<block_start>components=snake_str.split('_')<line_sep><return>''.join(x.title()<for>x components)<block_end>\n", "solution": "\ndef snake_to_camel (snake_str):\n    components=snake_str.split('_')\n    return ''.join(x.title() for x in components)\n    \n\n"}
{"task_id": "Mbpp/103", "origin_solution": "<def_stmt>eulerian_num a b<block_start><if_stmt>a<l>2<or>b<l>0<block_start><return>0<block_end><if_stmt>a<eq>2<block_start><return>1<if>b<eq>0<else>0<block_end><if_stmt>a<eq>3<block_start><return>1<if>b<eq>1<else>0<block_end><if_stmt>a<eq>4<block_start><return>1<if>b<eq>0<or>b<eq>1<else>0<block_end><if_stmt>a<eq>5<block_start><return>1<if>b<eq>2<else>0<block_end><return>eulerian_num(a-1 b-1)+eulerian_num(a-1 b)+eulerian_num(a-1 b+1)<block_end>\n", "solution": "\ndef eulerian_num (a, b):\n    if a<2 or b<0:\n        return 0\n        \n    if a==2:\n        return 1 if b==0 else 0\n        \n    if a==3:\n        return 1 if b==1 else 0\n        \n    if a==4:\n        return 1 if b==0 or b==1 else 0\n        \n    if a==5:\n        return 1 if b==2 else 0\n        \n    return eulerian_num(a-1, b-1)+eulerian_num(a-1, b)+eulerian_num(a-1, b+1)\n    \n\n"}
{"task_id": "Mbpp/104", "origin_solution": "<def_stmt>sort_sublists list_of_lists<block_start><return>[[sorted(sublist)<for>sublist sublist]<for>sublist list_of_lists]<block_end>\n", "solution": "\ndef sort_sublists (list_of_lists):\n    return [[sorted(sublist) for sublist in sublist] for sublist in list_of_lists]\n    \n\n"}
{"task_id": "Mbpp/105", "origin_solution": "<def_stmt>count lst<block_start><return>sum(1<for>x lst<if>x)<block_end>\n", "solution": "\ndef count (lst):\n    return sum(1 for x in lst if x)\n    \n\n"}
{"task_id": "Mbpp/106", "origin_solution": "<def_stmt>add_lists list1 tuple1<block_start><return>tuple1+tuple(list1)<block_end>\n", "solution": "\ndef add_lists (list1, tuple1):\n    return tuple1+tuple(list1)\n    \n\n"}
{"task_id": "Mbpp/108", "origin_solution": "<def_stmt>merge_sorted_list list1 list2 list3<block_start><return>sorted(list1+list2+list3)<block_end>\n", "solution": "\ndef merge_sorted_list (list1, list2, list3):\n    return sorted(list1+list2+list3)\n    \n\n"}
{"task_id": "Mbpp/109", "origin_solution": "<def_stmt>odd_Equivalent str n<block_start>cnt=0<for_stmt>i range(len(str))<block_start><if_stmt>int(str[i])%2<eq>1<block_start>cnt<augadd>1<block_end><if_stmt>n%2<eq>1<and>i<ne>len(str)-1<block_start>n=n-1<block_end><if_stmt>n%2<eq>0<and>i<ne>0<block_start>n=n-1<block_end><block_end><return>cnt<block_end>\n", "solution": "\ndef odd_Equivalent (str, n):\n    cnt=0\n    for i in range(len(str)):\n        if int(str[i])%2==1:\n            cnt+=1\n            \n        if n%2==1 and i!=len(str)-1:\n            n=n-1\n            \n        if n%2==0 and i!=0:\n            n=n-1\n            \n    \n    return cnt\n    \n\n"}
{"task_id": "Mbpp/111", "origin_solution": "<def_stmt>common_in_nested_lists nested_lists<block_start>common_elements=set(nested_lists[0])<for_stmt>lst nested_lists[1:]<block_start>common_elements.intersection_update(lst)<block_end><return>common_elements<block_end>\n", "solution": "\ndef common_in_nested_lists (nested_lists):\n    common_elements=set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n    return common_elements\n    \n\n"}
{"task_id": "Mbpp/113", "origin_solution": "<def_stmt>check_integer s<block_start><try_stmt><block_start>int(s)<line_sep><return><true><block_end><except_stmt>ValueError<block_start><return><false><block_end><block_end>\n", "solution": "\ndef check_integer (s):\n    try:\n        int(s)\n        return  True \n        \n    \n    except ValueError:\n        return  False \n        \n\n\n"}
{"task_id": "Mbpp/116", "origin_solution": "<def_stmt>tuple_to_int t<block_start>result=0<for_stmt>i range(len(t))<block_start>result=result<times>10+t[i]<block_end><return>result<block_end>\n", "solution": "\ndef tuple_to_int (t):\n    result=0\n    for i in range(len(t)):\n        result=result*10+t[i]\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/118", "origin_solution": "<def_stmt>string_to_list s<block_start><return>s.split()<block_end>\n", "solution": "\ndef string_to_list (s):\n    return s.split()\n    \n\n"}
{"task_id": "Mbpp/119", "origin_solution": "<def_stmt>search nums<block_start><if_stmt>len(nums)<eq>1<block_start><return>nums[0]<block_end>left,right=0 len(nums)-1<while_stmt>left<l>right<block_start>mid=left+(right-left)<floordiv>2<if_stmt>nums[mid]<eq>nums[mid+1]<block_start>left=mid+2<block_end><else_stmt><block_start>right=mid<block_end><block_end><return>nums[left]<block_end>\n", "solution": "\ndef search (nums):\n    if len(nums)==1:\n        return nums[0]\n        \n    left,right=0, len(nums)-1\n    while left<right:\n        mid=left+(right-left)//2\n        if nums[mid]==nums[mid+1]:\n            left=mid+2\n            \n        \n        else :\n            right=mid\n            \n    \n    return nums[left]\n    \n\n"}
{"task_id": "Mbpp/120", "origin_solution": "<import_stmt>math<def_stmt>max_product_tuple tuples_list<block_start>max_product=float('-inf')<for_stmt>pair tuples_list<block_start>product=pair[0]<times>pair[1]<if_stmt>product<g>max_product<block_start>max_product=product<block_end><block_end><return>max_product<block_end>\n", "solution": "\nimport math\ndef max_product_tuple (tuples_list):\n    max_product=float('-inf')\n    for pair in tuples_list:\n        product=pair[0]*pair[1]\n        if product>max_product:\n            max_product=product\n            \n    \n    return max_product\n    \n\n"}
{"task_id": "Mbpp/123", "origin_solution": "<def_stmt>amicable_numbers_sum n<block_start>amicable_numbers=set()<for_stmt>i range(2 n)<block_start>sum_divisors=1<for_stmt>j range(i+1 n)<block_start><if_stmt>i%j<eq>0<block_start>sum_divisors<augadd>j<block_end><block_end><if_stmt>sum_divisors<ne>i<and>sum_divisors<l>n<and>sum_divisors<not><in>amicable_numbers<block_start>amicable_numbers.add(sum_divisors)<if_stmt>sum_divisors<ne>i<block_start>amicable_numbers.add(i)<block_end><block_end><block_end><return>sum(set(amicable_numbers))<block_end>\n", "solution": "\ndef amicable_numbers_sum (n):\n    amicable_numbers=set()\n    for i in range(2, n):\n        sum_divisors=1\n        for j in range(i+1, n):\n            if i%j==0:\n                sum_divisors+=j\n                \n        \n        if sum_divisors!=i and sum_divisors<n and sum_divisors not  in amicable_numbers:\n            amicable_numbers.add(sum_divisors)\n            if sum_divisors!=i:\n                amicable_numbers.add(i)\n                \n        \n    \n    return sum(set(amicable_numbers))\n    \n\n"}
{"task_id": "Mbpp/124", "origin_solution": "<import_stmt>cmath<def_stmt>angle_complex z<block_start><return>cmath.phase(z)<block_end>\n", "solution": "\nimport cmath\ndef angle_complex (z):\n    return cmath.phase(z)\n    \n\n"}
{"task_id": "Mbpp/125", "origin_solution": "<def_stmt>find_length s:str<arrow>int<block_start>max_len=0<line_sep>count_0=0<line_sep>count_1=0<for_stmt>char s<block_start><if_stmt>char<eq>'0'<block_start>count_0<augadd>1<block_end><else_stmt><block_start>count_1<augadd>1<block_end><if_stmt>count_0-count_1<g>max_len<block_start>max_len=count_0-count_1<block_end><if_stmt>count_1<eq>0<block_start>count_1<augadd>1<block_end><block_end><return>max_len<block_end>\n", "solution": "\ndef find_length (s:str)->int:\n    max_len=0\n    count_0=0\n    count_1=0\n    for char in s:\n        if char=='0':\n            count_0+=1\n            \n        \n        else :\n            count_1+=1\n            \n        if count_0-count_1>max_len:\n            max_len=count_0-count_1\n            \n        if count_1==0:\n            count_1+=1\n            \n    \n    return max_len\n    \n\n"}
{"task_id": "Mbpp/126", "origin_solution": "<def_stmt>sum_divisors a b<block_start><def_stmt>divisors n<block_start>result=set()<for_stmt>i range(1 int(n<power>0.5)+1)<block_start><if_stmt>n%i<eq>0<block_start>result.add(i)<if_stmt>i<ne>n<floordiv>i<block_start>result.add(n<floordiv>i)<block_end><block_end><block_end><return>result<block_end>divisors_a=divisors(a)<line_sep>divisors_b=divisors(b)<line_sep>common_divisors=divisors_a&divisors_b<line_sep><return>sum(common_divisors)<block_end>\n", "solution": "\ndef sum_divisors (a, b):\n    def divisors (n):\n        result=set()\n        for i in range(1, int(n**0.5)+1):\n            if n%i==0:\n                result.add(i)\n                if i!=n//i:\n                    result.add(n//i)\n                    \n            \n        \n        return result\n        \n    divisors_a=divisors(a)\n    divisors_b=divisors(b)\n    common_divisors=divisors_a&divisors_b\n    return sum(common_divisors)\n    \n\n"}
{"task_id": "Mbpp/127", "origin_solution": "<def_stmt>multiply_int a b<block_start><return>a<times>b<block_end>\n", "solution": "\ndef multiply_int (a, b):\n    return a*b\n    \n\n"}
{"task_id": "Mbpp/128", "origin_solution": "<def_stmt>long_words n string<block_start>words=string.split()<line_sep>long_words=[word<for>word words<if>len(word)<g>n]<line_sep><return>long_words<block_end>\n", "solution": "\ndef long_words (n, string):\n    words=string.split()\n    long_words=[word for word in words if len(word)>n]\n    return long_words\n    \n\n"}
{"task_id": "Mbpp/129", "origin_solution": "<def_stmt>magic_square_test square<block_start>n=len(square)<if_stmt>n<eq>0<block_start><return><false><block_end>flat_list=[item<for>sublist square<for>item sublist]<if_stmt>len(set(flat_list))<ne>n<times>n<block_start><return><false><block_end>magic_constant=sum(square[0])<for_stmt>i range(n)<block_start><if_stmt>sum(square[i])<ne>magic_constant<or>sum([square[j][i]<for>j range(n)])<ne>magic_constant<block_start><return><false><block_end><block_end><if_stmt>sum([square[i][i]<for>i range(n)])<ne>magic_constant<or>sum([square[i][n-i-1]<for>i range(n)])<ne>magic_constant<block_start><return><false><block_end><return><true><block_end>\n", "solution": "\ndef magic_square_test (square):\n    n=len(square)\n    if n==0:\n        return  False \n        \n    flat_list=[item for sublist in square for item in sublist]\n    if len(set(flat_list))!=n*n:\n        return  False \n        \n    magic_constant=sum(square[0])\n    for i in range(n):\n        if sum(square[i])!=magic_constant or sum([square[j][i] for j in range(n)])!=magic_constant:\n            return  False \n            \n    \n    if sum([square[i][i] for i in range(n)])!=magic_constant or sum([square[i][n-i-1] for i in range(n)])!=magic_constant:\n        return  False \n        \n    return  True \n    \n\n"}
{"task_id": "Mbpp/130", "origin_solution": "<import_from_stmt>collections Counter<def_stmt>max_occurrences arr<block_start>counter=Counter(arr)<line_sep>max_val=max(list(counter.values()))<for_stmt>key,val counter.items()<block_start><if_stmt>val<eq>max_val<block_start><return>key<block_end><block_end><block_end>\n", "solution": "\nfrom collections import Counter\ndef max_occurrences (arr):\n    counter=Counter(arr)\n    max_val=max(list(counter.values()))\n    for key,val in counter.items():\n        if val==max_val:\n            return key\n            \n    \n\n\n"}
{"task_id": "Mbpp/131", "origin_solution": "<def_stmt>reverse_vowels s:str<arrow>str<block_start>vowels=set('aeiouAEIOU')<line_sep>s=list(s)<line_sep>left,right=0 len(s)-1<while_stmt>left<l>right<block_start><while_stmt>left<l>right<and>s[left]<not><in>vowels<block_start>left<augadd>1<block_end><while_stmt>left<l>right<and>s[right]<not><in>vowels<block_start>right<augsub>1<block_end>s[left],s[right]=s[right] s[left]<line_sep>left,right=left+1 right-1<block_end><return>''.join(s)<block_end>\n", "solution": "\ndef reverse_vowels (s:str)->str:\n    vowels=set('aeiouAEIOU')\n    s=list(s)\n    left,right=0, len(s)-1\n    while left<right:\n        while left<right and s[left] not  in vowels:\n            left+=1\n            \n        while left<right and s[right] not  in vowels:\n            right-=1\n            \n        s[left],s[right]=s[right], s[left]\n        left,right=left+1, right-1\n        \n    return ''.join(s)\n    \n\n"}
{"task_id": "Mbpp/132", "origin_solution": "<def_stmt>tup_string tup<block_start><return>''.join(tup)<block_end>\n", "solution": "\ndef tup_string (tup):\n    return ''.join(tup)\n    \n\n"}
{"task_id": "Mbpp/133", "origin_solution": "<def_stmt>sum_negativenum numbers<block_start>sum=0<for_stmt>num numbers<block_start><if_stmt>num<l>0<block_start>sum<augadd>num<block_end><block_end><return>sum<block_end>\n", "solution": "\ndef sum_negativenum (numbers):\n    sum=0\n    for num in numbers:\n        if num<0:\n            sum+=num\n            \n    \n    return sum\n    \n\n"}
{"task_id": "Mbpp/135", "origin_solution": "<def_stmt>hexagonal_num n<block_start><return>n<times>(2<times>n-1)<block_end>\n", "solution": "\ndef hexagonal_num (n):\n    return n*(2*n-1)\n    \n\n"}
{"task_id": "Mbpp/137", "origin_solution": "<def_stmt>zero_count arr<block_start>zero_count=0<line_sep>non_zero_count=0<for_stmt>num arr<block_start><if_stmt>num<eq>0<block_start>zero_count<augadd>1<block_end><else_stmt><block_start>non_zero_count<augadd>1<block_end><block_end><if_stmt>non_zero_count<eq>0<block_start><return>0.00<block_end><else_stmt><block_start><return>zero_count/non_zero_count<block_end><block_end>\n", "solution": "\ndef zero_count (arr):\n    zero_count=0\n    non_zero_count=0\n    for num in arr:\n        if num==0:\n            zero_count+=1\n            \n        \n        else :\n            non_zero_count+=1\n            \n    \n    if non_zero_count==0:\n        return 0.00\n        \n    \n    else :\n        return zero_count/non_zero_count\n        \n\n\n"}
{"task_id": "Mbpp/138", "origin_solution": "<def_stmt>is_Sum_Of_Powers_Of_Two n<block_start><if_stmt>n<eq>1<block_start><return><false><block_end><while_stmt>n<ne>0<block_start><if_stmt>n%2<eq>1<block_start><return><false><block_end>n=n<floordiv>2<block_end><return><true><block_end>\n", "solution": "\ndef is_Sum_Of_Powers_Of_Two (n):\n    if n==1:\n        return  False \n        \n    while n!=0:\n        if n%2==1:\n            return  False \n            \n        n=n//2\n        \n    return  True \n    \n\n"}
{"task_id": "Mbpp/139", "origin_solution": "<import_stmt>math<def_stmt>circle_circumference radius:float<arrow>float<block_start>\"\"\"\n    Calculate the circumference of a circle given its radius.\n    \n    Args:\n    radius (float): The radius of the circle.\n    \n    Returns:\n    float: The circumference of the circle.\n    \"\"\"<line_sep><return>2 * math.pi * radius<block_end>\n", "solution": "\nimport math\ndef circle_circumference (radius:float)->float:\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n    \n    Args:\n    radius (float): The radius of the circle.\n    \n    Returns:\n    float: The circumference of the circle.\n    \"\"\"\n    return 2, * math.pi, * radius\n    \n\n"}
{"task_id": "Mbpp/140", "origin_solution": "<def_stmt>extract_singly lists<block_start>result=[]<for_stmt>sublist lists<block_start><for_stmt>item sublist<block_start>result.append(item)<block_end><block_end><return>set(result)<block_end>\n", "solution": "\ndef extract_singly (lists):\n    result=[]\n    for sublist in lists:\n        for item in sublist:\n            result.append(item)\n            \n    \n    return set(result)\n    \n\n"}
{"task_id": "Mbpp/141", "origin_solution": "<def_stmt>pancake_sort arr<block_start>\"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \"\"\"<for_stmt>i range(len(arr) 1 -1)<block_start>max_index=arr.index(max(arr[:i]))<if_stmt>max_index<eq>i-1<block_start><continue><block_end>arr[:max_index+1]=arr[:max_index+1][::-1]<line_sep>arr[:i]=arr[:i][::-1]<block_end><return>arr<block_end>\n", "solution": "\ndef pancake_sort (arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \"\"\"\n    for i in range(len(arr), 1, -1):\n        max_index=arr.index(max(arr[:i]))\n        if max_index==i-1:\n            continue \n            \n        arr[:max_index+1]=arr[:max_index+1][::-1]\n        arr[:i]=arr[:i][::-1]\n        \n    return arr\n    \n\n"}
{"task_id": "Mbpp/142", "origin_solution": "<def_stmt>count_samepair list1 list2 list3<block_start>count=0<for_stmt>i range(len(list1))<block_start><if_stmt>list1[i]<eq>list2[i]<eq>list3[i]<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_samepair (list1, list2, list3):\n    count=0\n    for i in range(len(list1)):\n        if list1[i]==list2[i]==list3[i]:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/145", "origin_solution": "<def_stmt>max_Abs_Diff arr<block_start>max_val=max(arr)<line_sep>min_val=min(arr)<line_sep><return>abs(max_val-min_val)<block_end>\n", "solution": "\ndef max_Abs_Diff (arr):\n    max_val=max(arr)\n    min_val=min(arr)\n    return abs(max_val-min_val)\n    \n\n"}
{"task_id": "Mbpp/160", "origin_solution": "<def_stmt>find_solution m b n<block_start><for_stmt>x range(n<floordiv>m+1)<block_start>y=(n-m<times>x)<floordiv>b<if_stmt>y<ge>0<and>m<times>x+y<eq>n<block_start><return>x y<block_end><block_end><return><none><block_end>\n", "solution": "\ndef find_solution (m, b, n):\n    for x in range(n//m+1):\n        y=(n-m*x)//b\n        if y>=0 and m*x+y==n:\n            return x, y\n            \n    \n    return  None \n    \n\n"}
{"task_id": "Mbpp/161", "origin_solution": "<def_stmt>remove_elements main_list remove_list<block_start><return>[i<for>i main_list<if>i<not><in>remove_list]<block_end>\n", "solution": "\ndef remove_elements (main_list, remove_list):\n    return [i for i in main_list if i not  in remove_list]\n    \n\n"}
{"task_id": "Mbpp/162", "origin_solution": "<def_stmt>sum_series n<block_start>total=0<for_stmt>i range(0 n<floordiv>2+1)<block_start>total<augadd>(n-2<times>i)<block_end><return>total<block_end>\n", "solution": "\ndef sum_series (n):\n    total=0\n    for i in range(0, n//2+1):\n        total+=(n-2*i)\n        \n    return total\n    \n\n"}
{"task_id": "Mbpp/165", "origin_solution": "<def_stmt>count_char_position s<block_start>count=0<for_stmt>char s<block_start><if_stmt>char.isalpha()<block_start>position=ord(char.lower())-ord('a')<if_stmt>position<l>26<and>s[position]<eq>char<block_start>count<augadd>1<block_end><block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_char_position (s):\n    count=0\n    for char in s:\n        if char.isalpha():\n            position=ord(char.lower())-ord('a')\n            if position<26 and s[position]==char:\n                count+=1\n                \n        \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/166", "origin_solution": "<def_stmt>find_even_pair arr<block_start>even_count=0<for_stmt>num arr<block_start><if_stmt>num%2<eq>0<block_start>even_count<augadd>1<block_end><block_end><return>even_count<times>(even_count-1)<floordiv>2+sum([num%2<eq>0<for>num arr])<times>(even_count-1)<floordiv>2<block_end>\n", "solution": "\ndef find_even_pair (arr):\n    even_count=0\n    for num in arr:\n        if num%2==0:\n            even_count+=1\n            \n    \n    return even_count*(even_count-1)//2+sum([num%2==0 for num in arr])*(even_count-1)//2\n    \n\n"}
{"task_id": "Mbpp/167", "origin_solution": "<def_stmt>next_power_of_2 n<block_start><if_stmt>n<eq>0<block_start><return>1<block_end><elif_stmt>n&(n-1)<eq>0<block_start><return>n<block_end><else_stmt><block_start><return>1<lshift>(n-1).bit_length()<block_end><block_end>\n", "solution": "\ndef next_power_of_2 (n):\n    if n==0:\n        return 1\n        \n    \n    elif n&(n-1)==0:\n        return n\n        \n    \n    else :\n        return 1<<(n-1).bit_length()\n        \n\n\n"}
{"task_id": "Mbpp/168", "origin_solution": "<def_stmt>frequency lst num<block_start><return>lst.count(num)<block_end>\n", "solution": "\ndef frequency (lst, num):\n    return lst.count(num)\n    \n\n"}
{"task_id": "Mbpp/170", "origin_solution": "<def_stmt>sum_range_list lst start end<block_start><return>sum(lst[start:end+1])<block_end>\n", "solution": "\ndef sum_range_list (lst, start, end):\n    return sum(lst[start:end+1])\n    \n\n"}
{"task_id": "Mbpp/171", "origin_solution": "<def_stmt>perimeter_pentagon side_length n=5<block_start><return>n<times>side_length<block_end>\n", "solution": "\ndef perimeter_pentagon (side_length, n=5):\n    return n*side_length\n    \n\n"}
{"task_id": "Mbpp/172", "origin_solution": "<def_stmt>count_occurance s:str<arrow>int<block_start>count=0<for_stmt>i range(len(s)-2)<block_start><if_stmt>s[i:i+3]<eq>\"std\"<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_occurance (s:str)->int:\n    count=0\n    for i in range(len(s)-2):\n        if s[i:i+3]==\"std\":\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/222", "origin_solution": "<def_stmt>check_type test_tup<block_start>first_element_type=type(test_tup[0])<for_stmt>element test_tup<block_start><if_stmt>type(element)<ne>first_element_type<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef check_type (test_tup):\n    first_element_type=type(test_tup[0])\n    for element in test_tup:\n        if type(element)!=first_element_type:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/223", "origin_solution": "<def_stmt>is_majority nums n target<block_start>count=0<for_stmt>num nums<block_start><if_stmt>num<eq>target<block_start>count<augadd>1<if_stmt>count<g>n<floordiv>2<block_start><return><true><block_end><block_end><block_end><return><false><block_end>\n", "solution": "\ndef is_majority (nums, n, target):\n    count=0\n    for num in nums:\n        if num==target:\n            count+=1\n            if count>n//2:\n                return  True \n                \n        \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/224", "origin_solution": "<def_stmt>count_Set_Bits n<block_start>count=0<while_stmt>n<block_start>count<augadd>n&1<line_sep>n<augrshift>1<block_end><return>count<block_end>\n", "solution": "\ndef count_Set_Bits (n):\n    count=0\n    while n:\n        count+=n&1\n        n>>=1\n        \n    return count\n    \n\n"}
{"task_id": "Mbpp/226", "origin_solution": "<def_stmt>odd_values_string s<block_start><return>''.join([s[i]<for>i range(len(s))<if>i%2<eq>0])<block_end>\n", "solution": "\ndef odd_values_string (s):\n    return ''.join([s[i] for i in range(len(s)) if i%2==0])\n    \n\n"}
{"task_id": "Mbpp/227", "origin_solution": "<def_stmt>min_of_three a b c<block_start><return>min(a b c)<block_end>\n", "solution": "\ndef min_of_three (a, b, c):\n    return min(a, b, c)\n    \n\n"}
{"task_id": "Mbpp/230", "origin_solution": "<def_stmt>replace_blank s char<block_start><return>s.replace(' ' char)<block_end>\n", "solution": "\ndef replace_blank (s, char):\n    return s.replace(' ', char)\n    \n\n"}
{"task_id": "Mbpp/232", "origin_solution": "<def_stmt>larg_nnum lst n<block_start><return>sorted(lst reverse=<true>)[:n]<block_end>\n", "solution": "\ndef larg_nnum (lst, n):\n    return sorted(lst, reverse= True )[:n]\n    \n\n"}
{"task_id": "Mbpp/233", "origin_solution": "<import_stmt>math<def_stmt>lateralsuface_cylinder radius height<block_start>lateral_surface_area=2<times>math.pi<times>radius<times>height<line_sep><return>lateral_surface_area<block_end>\n", "solution": "\nimport math\ndef lateralsuface_cylinder (radius, height):\n    lateral_surface_area=2*math.pi*radius*height\n    return lateral_surface_area\n    \n\n"}
{"task_id": "Mbpp/234", "origin_solution": "<def_stmt>volume_cube side_length<block_start><return>side_length<power>3<block_end>\n", "solution": "\ndef volume_cube (side_length):\n    return side_length**3\n    \n\n"}
{"task_id": "Mbpp/235", "origin_solution": "<def_stmt>even_bit_set_number n<block_start><return>n|((n&-n).bit_length()-1)<times>2<block_end>\n", "solution": "\ndef even_bit_set_number (n):\n    return n|((n&-n).bit_length()-1)*2\n    \n\n"}
{"task_id": "Mbpp/237", "origin_solution": "<def_stmt>check_occurences tuples_list<block_start>occurrences={}<for_stmt>tup tuples_list<block_start><if_stmt>tup<in>occurrences<block_start>occurrences[tup]<augadd>1<block_end><else_stmt><block_start>occurrences[tup]=1<block_end><block_end><return>occurrences<block_end>\n", "solution": "\ndef check_occurences (tuples_list):\n    occurrences={}\n    for tup in tuples_list:\n        if tup in occurrences:\n            occurrences[tup]+=1\n            \n        \n        else :\n            occurrences[tup]=1\n            \n    \n    return occurrences\n    \n\n"}
{"task_id": "Mbpp/238", "origin_solution": "<def_stmt>number_of_substrings s:str<arrow>int<block_start>n=len(s)<line_sep><return>n<times>(n+1)<floordiv>2<block_end>\n", "solution": "\ndef number_of_substrings (s:str)->int:\n    n=len(s)\n    return n*(n+1)//2\n    \n\n"}
{"task_id": "Mbpp/239", "origin_solution": "<def_stmt>get_total_number_of_sequences m n<block_start>dp=[[0]<times>(m+1)<for>_ range(n+1)]<for_stmt>i range(1 m+1)<block_start>dp[1][i]=1<block_end><for_stmt>i range(2 n+1)<block_start><for_stmt>j range(1 m+1)<block_start>dp[i][j]=sum(dp[i-1][j<floordiv>2:j+1])%(10<power>9+7)<block_end><block_end><return>dp[n][m]<block_end>\n", "solution": "\ndef get_total_number_of_sequences (m, n):\n    dp=[[0]*(m+1) for _ in range(n+1)]\n    for i in range(1, m+1):\n        dp[1][i]=1\n        \n    for i in range(2, n+1):\n        for j in range(1, m+1):\n            dp[i][j]=sum(dp[i-1][j//2:j+1])%(10**9+7)\n            \n    \n    return dp[n][m]\n    \n\n"}
{"task_id": "Mbpp/240", "origin_solution": "<def_stmt>replace_list list1 list2<block_start>list1[-1:]=list2<line_sep><return>list1<block_end>\n", "solution": "\ndef replace_list (list1, list2):\n    list1[-1:]=list2\n    return list1\n    \n\n"}
{"task_id": "Mbpp/242", "origin_solution": "<def_stmt>count_charac s<block_start><return>len(s)<block_end>\n", "solution": "\ndef count_charac (s):\n    return len(s)\n    \n\n"}
{"task_id": "Mbpp/244", "origin_solution": "<def_stmt>next_Perfect_Square n<block_start>i=int(n<power>0.5)<if_stmt>i<power>2<g>n<block_start><return>(i+1)<power>2<block_end><else_stmt><block_start><return>(i+1)<power>2<block_end><block_end>\n", "solution": "\ndef next_Perfect_Square (n):\n    i=int(n**0.5)\n    if i**2>n:\n        return (i+1)**2\n        \n    \n    else :\n        return (i+1)**2\n        \n\n\n"}
{"task_id": "Mbpp/245", "origin_solution": "<def_stmt>max_sum arr<block_start>n=len(arr)<line_sep>inc=[arr[0]]<times>n<line_sep>dec=[arr[-1]]<times>n<for_stmt>i range(1 n)<block_start>inc[i]=max(inc[i-1]+arr[i] arr[i])<block_end><for_stmt>i range(n-2 -1 -1)<block_start>dec[i]=max(dec[i+1]+arr[i] arr[i])<block_end>max_sum=0<for_stmt>i range(n)<block_start>max_sum=max(max_sum inc[i]+dec[i]-arr[i])<block_end><return>max_sum<block_end>\n", "solution": "\ndef max_sum (arr):\n    n=len(arr)\n    inc=[arr[0]]*n\n    dec=[arr[-1]]*n\n    for i in range(1, n):\n        inc[i]=max(inc[i-1]+arr[i], arr[i])\n        \n    for i in range(n-2, -1, -1):\n        dec[i]=max(dec[i+1]+arr[i], arr[i])\n        \n    max_sum=0\n    for i in range(n):\n        max_sum=max(max_sum, inc[i]+dec[i]-arr[i])\n        \n    return max_sum\n    \n\n"}
{"task_id": "Mbpp/247", "origin_solution": "<def_stmt>lps s<block_start>n=len(s)<line_sep>dp=[[0]<times>n<for>_ range(n)]<for_stmt>i range(n-1 -1 -1)<block_start>dp[i][i]=1<for_stmt>j range(i+1 n)<block_start><if_stmt>s[i]<eq>s[j]<block_start>dp[i][j]=dp[i+1][j-1]+2<block_end><else_stmt><block_start>dp[i][j]=max(dp[i+1][j] dp[i][j-1])<block_end><block_end><block_end><return>dp[0][n-1]<block_end>\n", "solution": "\ndef lps (s):\n    n=len(s)\n    dp=[[0]*n for _ in range(n)]\n    for i in range(n-1, -1, -1):\n        dp[i][i]=1\n        for j in range(i+1, n):\n            if s[i]==s[j]:\n                dp[i][j]=dp[i+1][j-1]+2\n                \n            \n            else :\n                dp[i][j]=max(dp[i+1][j], dp[i][j-1])\n                \n        \n    \n    return dp[0][n-1]\n    \n\n"}
{"task_id": "Mbpp/250", "origin_solution": "<def_stmt>count_X t element<block_start><return>t.count(element)<block_end>\n", "solution": "\ndef count_X (t, element):\n    return t.count(element)\n    \n\n"}
{"task_id": "Mbpp/251", "origin_solution": "<def_stmt>insert_element lst element<block_start>result=[]<for_stmt>item lst<block_start>result.insert(0 item)<line_sep>result.insert(0 element)<block_end><return>result<block_end>\n", "solution": "\ndef insert_element (lst, element):\n    result=[]\n    for item in lst:\n        result.insert(0, item)\n        result.insert(0, element)\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/252", "origin_solution": "<def_stmt>convert num<block_start><if_stmt>num<eq>1<block_start><return>(1.0 0.0)<block_end><else_stmt><block_start>real=(num/abs(num))<times>2.0<line_sep>angle=0.0<line_sep><return>(real angle)<block_end><block_end>\n", "solution": "\ndef convert (num):\n    if num==1:\n        return (1.0, 0.0)\n        \n    \n    else :\n        real=(num/abs(num))*2.0\n        angle=0.0\n        return (real, angle)\n        \n\n\n"}
{"task_id": "Mbpp/253", "origin_solution": "<def_stmt>count_integer lst<block_start><return>len([i<for>i lst<if>isinstance(i int)])<block_end>\n", "solution": "\ndef count_integer (lst):\n    return len([i for i in lst if isinstance(i, int)])\n    \n\n"}
{"task_id": "Mbpp/255", "origin_solution": "<import_from_stmt>itertools product<def_stmt>combinations_colors lst n<block_start><return>list(product(lst repeat=n))<block_end>\n", "solution": "\nfrom itertools import product\ndef combinations_colors (lst, n):\n    return list(product(lst, repeat=n))\n    \n\n"}
{"task_id": "Mbpp/256", "origin_solution": "<def_stmt>count_Primes_nums n<block_start><def_stmt>is_prime num<block_start><if_stmt>num<l>2<block_start><return><false><block_end><for_stmt>i range(2 int(num<power>0.5)+1)<block_start><if_stmt>num%i<eq>0<block_start><return><false><block_end><block_end><return><true><block_end>count=0<for_stmt>i range(2 n)<block_start><if_stmt>is_prime(i)<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_Primes_nums (n):\n    def is_prime (num):\n        if num<2:\n            return  False \n            \n        for i in range(2, int(num**0.5)+1):\n            if num%i==0:\n                return  False \n                \n        \n        return  True \n        \n    count=0\n    for i in range(2, n):\n        if is_prime(i):\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/257", "origin_solution": "<def_stmt>swap_numbers num1 num2<block_start><return>(num2 num1)<block_end>\n", "solution": "\ndef swap_numbers (num1, num2):\n    return (num2, num1)\n    \n\n"}
{"task_id": "Mbpp/259", "origin_solution": "<def_stmt>maximize_elements tuple1 tuple2<block_start>maximized=[]<for_stmt>t1,t2 zip(tuple1 tuple2)<block_start>max_t1=max(t1[0] t1[1])<if>isinstance(t1 tuple)<else>t1<line_sep>max_t2=max(t2[0] t2[1])<if>isinstance(t2 tuple)<else>t2<line_sep>maximized.append((max_t1 max_t2))<block_end><return>tuple(maximized)<block_end>\n", "solution": "\ndef maximize_elements (tuple1, tuple2):\n    maximized=[]\n    for t1,t2 in zip(tuple1, tuple2):\n        max_t1=max(t1[0], t1[1]) if isinstance(t1, tuple) else t1\n        max_t2=max(t2[0], t2[1]) if isinstance(t2, tuple) else t2\n        maximized.append((max_t1, max_t2))\n        \n    return tuple(maximized)\n    \n\n"}
{"task_id": "Mbpp/260", "origin_solution": "<def_stmt>newman_prime n<block_start><def_stmt>is_prime x<block_start><if_stmt>x<l>2<block_start><return><false><block_end><for_stmt>i range(2 int(x<power>0.5)+1)<block_start><if_stmt>x%i<eq>0<block_start><return><false><block_end><block_end><return><true><block_end>newman_num=2<while_stmt><true><block_start><if_stmt>is_prime(newman_num)<block_start><return>newman_num<block_end>newman_num<augadd>1<block_end><block_end>\n", "solution": "\ndef newman_prime (n):\n    def is_prime (x):\n        if x<2:\n            return  False \n            \n        for i in range(2, int(x**0.5)+1):\n            if x%i==0:\n                return  False \n                \n        \n        return  True \n        \n    newman_num=2\n    while  True :\n        if is_prime(newman_num):\n            return newman_num\n            \n        newman_num+=1\n        \n\n\n"}
{"task_id": "Mbpp/261", "origin_solution": "<def_stmt>division_elements test_tup1 test_tup2<block_start>result=tuple(ele1/ele2<for>ele1,ele2 zip(test_tup1 test_tup2))<line_sep><return>result<block_end>\n", "solution": "\ndef division_elements (test_tup1, test_tup2):\n    result=tuple(ele1/ele2 for ele1,ele2 in zip(test_tup1, test_tup2))\n    return result\n    \n\n"}
{"task_id": "Mbpp/262", "origin_solution": "<def_stmt>split_two_parts lst L<block_start>length=len(lst)<line_sep>first_part=lst[:L]<line_sep>second_part=lst[L:]<line_sep><return>(first_part second_part)<block_end>\n", "solution": "\ndef split_two_parts (lst, L):\n    length=len(lst)\n    first_part=lst[:L]\n    second_part=lst[L:]\n    return (first_part, second_part)\n    \n\n"}
{"task_id": "Mbpp/264", "origin_solution": "<def_stmt>dog_age dog_years<block_start><if_stmt>dog_years<l>1<block_start><return>\"Invalid input\"<block_end><if_stmt>dog_years<eq>1<block_start><return>15<block_end><elif_stmt>dog_years<eq>2<block_start><return>20<block_end><elif_stmt>dog_years<eq>3<block_start><return>25<block_end><elif_stmt>dog_years<eq>4<block_start><return>30<block_end><elif_stmt>dog_years<eq>5<block_start><return>35<block_end><elif_stmt>dog_years<eq>6<block_start><return>40<block_end><elif_stmt>dog_years<eq>7<block_start><return>45<block_end><elif_stmt>dog_years<eq>8<block_start><return>50<block_end><elif_stmt>dog_years<eq>9<block_start><return>55<block_end><elif_stmt>dog_years<eq>10<block_start><return>60<block_end><elif_stmt>dog_years<eq>11<block_start><return>65<block_end><elif_stmt>dog_years<eq>12<block_start><return>70<block_end><else_stmt><block_start><return>\"Invalid input\"<block_end><block_end>\n", "solution": "\ndef dog_age (dog_years):\n    if dog_years<1:\n        return \"Invalid input\"\n        \n    if dog_years==1:\n        return 15\n        \n    \n    elif dog_years==2:\n        return 20\n        \n    \n    elif dog_years==3:\n        return 25\n        \n    \n    elif dog_years==4:\n        return 30\n        \n    \n    elif dog_years==5:\n        return 35\n        \n    \n    elif dog_years==6:\n        return 40\n        \n    \n    elif dog_years==7:\n        return 45\n        \n    \n    elif dog_years==8:\n        return 50\n        \n    \n    elif dog_years==9:\n        return 55\n        \n    \n    elif dog_years==10:\n        return 60\n        \n    \n    elif dog_years==11:\n        return 65\n        \n    \n    elif dog_years==12:\n        return 70\n        \n    \n    else :\n        return \"Invalid input\"\n        \n\n\n"}
{"task_id": "Mbpp/265", "origin_solution": "<def_stmt>list_split lst n<block_start>result=[]<for_stmt>i range(0 len(lst) n)<block_start>result.append(lst[i:i+n])<block_end><return>result<block_end>\n", "solution": "\ndef list_split (lst, n):\n    result=[]\n    for i in range(0, len(lst), n):\n        result.append(lst[i:i+n])\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/266", "origin_solution": "<def_stmt>lateralsurface_cube side_length<block_start><return>6<times>side_length<power>2<block_end>\n", "solution": "\ndef lateralsurface_cube (side_length):\n    return 6*side_length**2\n    \n\n"}
{"task_id": "Mbpp/267", "origin_solution": "<def_stmt>square_Sum n<block_start>sum_of_squares=0<for_stmt>i range(1 2<times>n 2)<block_start>sum_of_squares<augadd>i<power>2<block_end><return>sum_of_squares<block_end>\n", "solution": "\ndef square_Sum (n):\n    sum_of_squares=0\n    for i in range(1, 2*n, 2):\n        sum_of_squares+=i**2\n        \n    return sum_of_squares\n    \n\n"}
{"task_id": "Mbpp/268", "origin_solution": "<def_stmt>find_star_num n<block_start>\"\"\"\n    Calculate the n'th star number.\n    \n    :param n: An integer representing the position of the star number to find.\n    :return: The n'th star number.\n    \"\"\"<if_stmt>n<eq>1<block_start><return>1<block_end><else_stmt><block_start><return>find_star_num(n-1)+6<times>(n-1)<times>(n-2)<floordiv>2+4<times>(n-1)<times>(n-2)<times>(n-3)<floordiv>6+find_star_num(n-4)<times>2048<floordiv>256<block_end><block_end>\n", "solution": "\ndef find_star_num (n):\n    \"\"\"\n    Calculate the n'th star number.\n    \n    :param n: An integer representing the position of the star number to find.\n    :return: The n'th star number.\n    \"\"\"\n    if n==1:\n        return 1\n        \n    \n    else :\n        return find_star_num(n-1)+6*(n-1)*(n-2)//2+4*(n-1)*(n-2)*(n-3)//6+find_star_num(n-4)*2048//256\n        \n\n\n"}
{"task_id": "Mbpp/269", "origin_solution": "<def_stmt>ascii_value char<block_start><return>ord(char)<block_end>\n", "solution": "\ndef ascii_value (char):\n    return ord(char)\n    \n\n"}
{"task_id": "Mbpp/270", "origin_solution": "<def_stmt>sum_even_and_even_index lst<block_start>sum=0<for_stmt>i range(0 len(lst) 2)<block_start><if_stmt>lst[i]%2<eq>0<block_start>sum<augadd>lst[i]<block_end><block_end><return>sum<block_end>\n", "solution": "\ndef sum_even_and_even_index (lst):\n    sum=0\n    for i in range(0, len(lst), 2):\n        if lst[i]%2==0:\n            sum+=lst[i]\n            \n    \n    return sum\n    \n\n"}
{"task_id": "Mbpp/271", "origin_solution": "<def_stmt>even_Power_Sum n<block_start>total_sum=0<for_stmt>i range(1 n+1)<block_start>total_sum<augadd>(2<times>i)<power>5<block_end><return>total_sum<block_end>\n", "solution": "\ndef even_Power_Sum (n):\n    total_sum=0\n    for i in range(1, n+1):\n        total_sum+=(2*i)**5\n        \n    return total_sum\n    \n\n"}
{"task_id": "Mbpp/272", "origin_solution": "<def_stmt>rear_extract tuple_list<block_start><return>[tup[-1]<for>tup tuple_list]<block_end>\n", "solution": "\ndef rear_extract (tuple_list):\n    return [tup[-1] for tup in tuple_list]\n    \n\n"}
{"task_id": "Mbpp/273", "origin_solution": "<def_stmt>substract_elements tuple1 tuple2<block_start>result=tuple(x-y<for>x,y zip(tuple1 tuple2))<line_sep><return>result<block_end>\n", "solution": "\ndef substract_elements (tuple1, tuple2):\n    result=tuple(x-y for x,y in zip(tuple1, tuple2))\n    return result\n    \n\n"}
{"task_id": "Mbpp/274", "origin_solution": "<import_from_stmt>math factorial<def_stmt>even_binomial_Coeff_Sum n<block_start>sum=0<for_stmt>i range(0 n+1 2)<block_start>binomial_coeff=factorial(n)<floordiv>(factorial(i)<times>factorial(n-i))<if_stmt>binomial_coeff%2<eq>0<block_start>sum<augadd>binomial_coeff<block_end><block_end><return>sum<block_end>\n", "solution": "\nfrom math import factorial\ndef even_binomial_Coeff_Sum (n):\n    sum=0\n    for i in range(0, n+1, 2):\n        binomial_coeff=factorial(n)//(factorial(i)*factorial(n-i))\n        if binomial_coeff%2==0:\n            sum+=binomial_coeff\n            \n    \n    return sum\n    \n\n"}
{"task_id": "Mbpp/276", "origin_solution": "<import_stmt>math<def_stmt>volume_cylinder radius height<block_start>volume=math.pi<times>radius<power>2<times>height<line_sep><return>volume<block_end>\n", "solution": "\nimport math\ndef volume_cylinder (radius, height):\n    volume=math.pi*radius**2*height\n    return volume\n    \n\n"}
{"task_id": "Mbpp/277", "origin_solution": "<def_stmt>dict_filter d n<block_start><return>{k:v<for>k,v d.items()<if>v<ge>n}<block_end>\n", "solution": "\ndef dict_filter (d, n):\n    return {k:v for k,v in d.items() if v>=n}\n    \n\n"}
{"task_id": "Mbpp/278", "origin_solution": "<def_stmt>count_first_elements t<block_start>count=0<for_stmt>i t<block_start><if_stmt>isinstance(i tuple)<block_start><break><block_end>count<augadd>1<block_end><return>count<block_end>\n", "solution": "\ndef count_first_elements (t):\n    count=0\n    for i in t:\n        if isinstance(i, tuple):\n            break \n            \n        count+=1\n        \n    return count\n    \n\n"}
{"task_id": "Mbpp/279", "origin_solution": "<def_stmt>is_num_decagonal n<block_start><return>n<times>(7<times>n-5)<floordiv>2<block_end>\n", "solution": "\ndef is_num_decagonal (n):\n    return n*(7*n-5)//2\n    \n\n"}
{"task_id": "Mbpp/280", "origin_solution": "<def_stmt>sequential_search arr target<block_start><for_stmt>i range(len(arr))<block_start><if_stmt>arr[i]<eq>target<block_start><return>(<true> i)<block_end><block_end><return>(<false> -1)<block_end>\n", "solution": "\ndef sequential_search (arr, target):\n    for i in range(len(arr)):\n        if arr[i]==target:\n            return ( True , i)\n            \n    \n    return ( False , -1)\n    \n\n"}
{"task_id": "Mbpp/281", "origin_solution": "<def_stmt>all_unique lst<block_start><return>len(lst)<eq>len(set(lst))<block_end>\n", "solution": "\ndef all_unique (lst):\n    return len(lst)==len(set(lst))\n    \n\n"}
{"task_id": "Mbpp/282", "origin_solution": "<def_stmt>sub_list list1 list2<block_start><return>[x-y<for>x,y zip(list1 list2)]<block_end>\n", "solution": "\ndef sub_list (list1, list2):\n    return [x-y for x,y in zip(list1, list2)]\n    \n\n"}
{"task_id": "Mbpp/283", "origin_solution": "<def_stmt>validate num<block_start>freq={}<for_stmt>digit str(num)<block_start><if_stmt>digit<in>freq<block_start>freq[digit]<augadd>1<block_end><else_stmt><block_start>freq[digit]=1<block_end><block_end><for_stmt>digit,frequency freq.items()<block_start><if_stmt>frequency<g>int(digit)<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef validate (num):\n    freq={}\n    for digit in str(num):\n        if digit in freq:\n            freq[digit]+=1\n            \n        \n        else :\n            freq[digit]=1\n            \n    \n    for digit,frequency in freq.items():\n        if frequency>int(digit):\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/284", "origin_solution": "<def_stmt>check_element lst element<block_start><return>all(x<eq>element<for>x lst)<block_end>\n", "solution": "\ndef check_element (lst, element):\n    return all(x==element for x in lst)\n    \n\n"}
{"task_id": "Mbpp/285", "origin_solution": "<import_stmt>re<def_stmt>text_match_two_three text<block_start>pattern=r\"ab{2,3}\"<line_sep>match=re.search(pattern text)<line_sep><return>match<is><not><none><block_end>\n", "solution": "\nimport re\ndef text_match_two_three (text):\n    pattern=r\"ab{2,3}\"\n    match=re.search(pattern, text)\n    return match is  not  None \n    \n\n"}
{"task_id": "Mbpp/286", "origin_solution": "<def_stmt>max_sub_array_sum_repeated arr k arr_size<block_start>max_sum=float('-inf')<line_sep>current_sum=0<for_stmt>i range(len(arr))<block_start>current_sum<augadd>arr[i]<if_stmt>current_sum<g>max_sum<block_start>max_sum=current_sum<block_end><if_stmt>current_sum<l>0<block_start>current_sum=0<block_end><block_end><if_stmt>k<eq>1<block_start><return>max_sum<block_end>extended_arr=arr<times>k<line_sep>new_arr=extended_arr+extended_arr[:arr_size]<line_sep>max_sum=float('-inf')<line_sep>current_sum=0<for_stmt>i range(len(new_arr))<block_start>current_sum<augadd>new_arr[i]<if_stmt>current_sum<g>max_sum<block_start>max_sum=current_sum<block_end><if_stmt>current_sum<l>0<block_start>current_sum=0<block_end><block_end><return>max_sum<block_end>\n", "solution": "\ndef max_sub_array_sum_repeated (arr, k, arr_size):\n    max_sum=float('-inf')\n    current_sum=0\n    for i in range(len(arr)):\n        current_sum+=arr[i]\n        if current_sum>max_sum:\n            max_sum=current_sum\n            \n        if current_sum<0:\n            current_sum=0\n            \n    \n    if k==1:\n        return max_sum\n        \n    extended_arr=arr*k\n    new_arr=extended_arr+extended_arr[:arr_size]\n    max_sum=float('-inf')\n    current_sum=0\n    for i in range(len(new_arr)):\n        current_sum+=new_arr[i]\n        if current_sum>max_sum:\n            max_sum=current_sum\n            \n        if current_sum<0:\n            current_sum=0\n            \n    \n    return max_sum\n    \n\n"}
{"task_id": "Mbpp/287", "origin_solution": "<def_stmt>square_Sum n<block_start>total=0<for_stmt>i range(1 n+1)<block_start>total<augadd>(2<times>i)<power>2<block_end><return>total<block_end>\n", "solution": "\ndef square_Sum (n):\n    total=0\n    for i in range(1, n+1):\n        total+=(2*i)**2\n        \n    return total\n    \n\n"}
{"task_id": "Mbpp/290", "origin_solution": "<def_stmt>max_length lists<block_start>max_length=max(len(lst)<for>lst lists)<line_sep><return>max_length [lst<for>lst lists<if>len(lst)<eq>max_length]<block_end>\n", "solution": "\ndef max_length (lists):\n    max_length=max(len(lst) for lst in lists)\n    return max_length, [lst for lst in lists if len(lst)==max_length]\n    \n\n"}
{"task_id": "Mbpp/292", "origin_solution": "<def_stmt>find dividend divisor<block_start><return>dividend<floordiv>divisor<block_end>\n", "solution": "\ndef find (dividend, divisor):\n    return dividend//divisor\n    \n\n"}
{"task_id": "Mbpp/293", "origin_solution": "<import_stmt>math<def_stmt>otherside_rightangle a b<block_start>c=math.sqrt(a<power>2+b<power>2)<line_sep><return>c<block_end>\n", "solution": "\nimport math\ndef otherside_rightangle (a, b):\n    c=math.sqrt(a**2+b**2)\n    return c\n    \n\n"}
{"task_id": "Mbpp/294", "origin_solution": "<def_stmt>max_val lst<block_start><return>max((i<for>i lst<if>isinstance(i int)) default=<none>)<block_end>\n", "solution": "\ndef max_val (lst):\n    return max((i for i in lst if isinstance(i, int)), default= None )\n    \n\n"}
{"task_id": "Mbpp/296", "origin_solution": "<def_stmt>get_Inv_Count arr<block_start>inv_count=0<for_stmt>i range(len(arr))<block_start><for_stmt>j range(i+1 len(arr))<block_start><if_stmt>arr[i]<g>arr[j]<block_start>inv_count<augadd>1<block_end><block_end><block_end><return>inv_count<block_end>\n", "solution": "\ndef get_Inv_Count (arr):\n    inv_count=0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]>arr[j]:\n                inv_count+=1\n                \n        \n    \n    return inv_count\n    \n\n"}
{"task_id": "Mbpp/297", "origin_solution": "<def_stmt>flatten_list nested_list<block_start>flat_list=[]<for_stmt>i nested_list<block_start><if_stmt>isinstance(i list)<block_start>flat_list.extend(flatten_list(i))<block_end><else_stmt><block_start>flat_list.append(i)<block_end><block_end><return>flat_list<block_end>\n", "solution": "\ndef flatten_list (nested_list):\n    flat_list=[]\n    for i in nested_list:\n        if isinstance(i, list):\n            flat_list.extend(flatten_list(i))\n            \n        \n        else :\n            flat_list.append(i)\n            \n    \n    return flat_list\n    \n\n"}
{"task_id": "Mbpp/299", "origin_solution": "<def_stmt>max_aggregate lst<block_start>max_name=''<line_sep>max_value=0<for_stmt>name,value lst<block_start><if_stmt>value<g>max_value<block_start>max_name=name<line_sep>max_value=value<block_end><block_end><return>(max_name max_value)<block_end>\n", "solution": "\ndef max_aggregate (lst):\n    max_name=''\n    max_value=0\n    for name,value in lst:\n        if value>max_value:\n            max_name=name\n            max_value=value\n            \n    \n    return (max_name, max_value)\n    \n\n"}
{"task_id": "Mbpp/300", "origin_solution": "<import_from_stmt>math comb<def_stmt>count_binary_seq n:int<arrow>float<block_start>\"\"\"\n    Count the number of binary sequences of length 2n such that the sum of the first n bits\n    is equal to the sum of the last n bits.\n    \n    Args:\n    n (int): The length of the binary sequence.\n    \n    Returns:\n    float: The count of such binary sequences.\n    \"\"\"<line_sep>count=0<for_stmt>k range(n+1)<block_start>count<augadd>comb(n k)<power>2<block_end><return>count<times>2.0/n<block_end>\n", "solution": "\nfrom math import comb\ndef count_binary_seq (n:int)->float:\n    \"\"\"\n    Count the number of binary sequences of length 2n such that the sum of the first n bits\n    is equal to the sum of the last n bits.\n    \n    Args:\n    n (int): The length of the binary sequence.\n    \n    Returns:\n    float: The count of such binary sequences.\n    \"\"\"\n    count=0\n    for k in range(n+1):\n        count+=comb(n, k)**2\n        \n    return count*2.0/n\n    \n\n"}
{"task_id": "Mbpp/301", "origin_solution": "<def_stmt>dict_depth d<block_start><if_stmt>isinstance(d dict)<block_start><return>1+max(dict_depth(v)<for>v d.values())<block_end><return>0<block_end>\n", "solution": "\ndef dict_depth (d):\n    if isinstance(d, dict):\n        return 1+max(dict_depth(v) for v in d.values())\n        \n    return 0\n    \n\n"}
{"task_id": "Mbpp/305", "origin_solution": "<def_stmt>start_withp words<block_start>p_words=[word<for>word words<if>word.startswith('p')]<line_sep>p_words.sort()<line_sep><return>p_words[0] p_words[1]<if>len(p_words)<g>1<else><none><block_end>\n", "solution": "\ndef start_withp (words):\n    p_words=[word for word in words if word.startswith('p')]\n    p_words.sort()\n    return p_words[0], p_words[1] if len(p_words)>1 else  None \n    \n\n"}
{"task_id": "Mbpp/306", "origin_solution": "<def_stmt>max_sum_increasing_subseq nums k t<block_start>max_sum=[0]<times>len(nums)<line_sep>max_sum[0]=nums[0]<for_stmt>i range(1 len(nums))<block_start><for_stmt>j range(i)<block_start><if_stmt>nums[i]<g>nums[j]<block_start>max_sum[i]=max(max_sum[i] max_sum[j]+nums[i])<block_end><block_end>max_sum[i]=max(max_sum[i] nums[i])<block_end>max_sum2=[0]<times>len(nums)<line_sep>max_sum2[-1]=nums[-1]<for_stmt>i range(len(nums)-2 -1 -1)<block_start><for_stmt>j range(i+1 len(nums))<block_start><if_stmt>nums[i]<g>nums[j]<block_start>max_sum2[i]=max(max_sum2[i] max_sum2[j]+nums[i])<block_end><block_end>max_sum2[i]=max(max_sum2[i] nums[i])<block_end>max_sum3=max_sum2[k]<line_sep><return>max_sum3<if>max_sum3<g>max_sum2[0]<else>max_sum2[0]<block_end>\n", "solution": "\ndef max_sum_increasing_subseq (nums, k, t):\n    max_sum=[0]*len(nums)\n    max_sum[0]=nums[0]\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i]>nums[j]:\n                max_sum[i]=max(max_sum[i], max_sum[j]+nums[i])\n                \n        \n        max_sum[i]=max(max_sum[i], nums[i])\n        \n    max_sum2=[0]*len(nums)\n    max_sum2[-1]=nums[-1]\n    for i in range(len(nums)-2, -1, -1):\n        for j in range(i+1, len(nums)):\n            if nums[i]>nums[j]:\n                max_sum2[i]=max(max_sum2[i], max_sum2[j]+nums[i])\n                \n        \n        max_sum2[i]=max(max_sum2[i], nums[i])\n        \n    max_sum3=max_sum2[k]\n    return max_sum3 if max_sum3>max_sum2[0] else max_sum2[0]\n    \n\n"}
{"task_id": "Mbpp/308", "origin_solution": "<def_stmt>large_product nums1 nums2 N<block_start>result=[]<line_sep>nums1.sort(reverse=<true>)<line_sep>nums2.sort(reverse=<true>)<for_stmt>i range(N)<block_start><if_stmt>nums1[0]<eq>0<block_start>result.append(0)<block_end><elif_stmt>nums2[0]<eq>0<block_start>result.append(0)<block_end><else_stmt><block_start>product1=nums1[0]<times>nums2[0]<line_sep>product2=nums1[0]<times>nums2[-1]<line_sep>product3=nums1[-1]<times>nums2[0]<line_sep>product4=nums1[-1]<times>nums2[-1]<line_sep>result.append(max(product1 product2 product3 product4))<block_end>nums1.pop(0)<line_sep>nums2.pop(0)<block_end><return>result<block_end>\n", "solution": "\ndef large_product (nums1, nums2, N):\n    result=[]\n    nums1.sort(reverse= True )\n    nums2.sort(reverse= True )\n    for i in range(N):\n        if nums1[0]==0:\n            result.append(0)\n            \n        \n        elif nums2[0]==0:\n            result.append(0)\n            \n        \n        else :\n            product1=nums1[0]*nums2[0]\n            product2=nums1[0]*nums2[-1]\n            product3=nums1[-1]*nums2[0]\n            product4=nums1[-1]*nums2[-1]\n            result.append(max(product1, product2, product3, product4))\n            \n        nums1.pop(0)\n        nums2.pop(0)\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/309", "origin_solution": "<def_stmt>maximum a b<block_start><return>a<if>a<g>b<else>b<block_end>\n", "solution": "\ndef maximum (a, b):\n    return a if a>b else b\n    \n\n"}
{"task_id": "Mbpp/310", "origin_solution": "<def_stmt>string_to_tuple s<block_start><return>tuple(s)<block_end>\n", "solution": "\ndef string_to_tuple (s):\n    return tuple(s)\n    \n\n"}
{"task_id": "Mbpp/311", "origin_solution": "<def_stmt>set_left_most_unset_bit n<block_start><return>n|(1<lshift>(n.bit_length()-1))<block_end>\n", "solution": "\ndef set_left_most_unset_bit (n):\n    return n|(1<<(n.bit_length()-1))\n    \n\n"}
{"task_id": "Mbpp/312", "origin_solution": "<import_stmt>math<def_stmt>volume_cone radius height<block_start>\"\"\"Calculate the volume of a cone given its radius and height.\"\"\"<line_sep>volume=(1/3)<times>math.pi<times>radius<power>2<times>height<line_sep><return>volume<block_end>\n", "solution": "\nimport math\ndef volume_cone (radius, height):\n    \"\"\"Calculate the volume of a cone given its radius and height.\"\"\"\n    volume=(1/3)*math.pi*radius**2*height\n    return volume\n    \n\n"}
{"task_id": "Mbpp/388", "origin_solution": "<def_stmt>highest_Power_of_2 n<block_start>power=0<while_stmt>(1<lshift>power)<le>n<block_start>power<augadd>1<block_end><return>1<lshift>(power-1)<block_end>\n", "solution": "\ndef highest_Power_of_2 (n):\n    power=0\n    while (1<<power)<=n:\n        power+=1\n        \n    return 1<<(power-1)\n    \n\n"}
{"task_id": "Mbpp/389", "origin_solution": "<def_stmt>find_lucas n<block_start><if_stmt>n<eq>1<block_start><return>2<block_end><elif_stmt>n<eq>2<block_start><return>1<block_end><else_stmt><block_start>a,b=2 1<for_stmt>_ range(3 n+1)<block_start>a,b=b a+b<block_end><return>b<block_end><block_end>\n", "solution": "\ndef find_lucas (n):\n    if n==1:\n        return 2\n        \n    \n    elif n==2:\n        return 1\n        \n    \n    else :\n        a,b=2, 1\n        for _ in range(3, n+1):\n            a,b=b, a+b\n            \n        return b\n        \n\n\n"}
{"task_id": "Mbpp/390", "origin_solution": "<def_stmt>add_string input_list format_string<block_start><return>[format_string.format(item)<for>item input_list]<block_end>\n", "solution": "\ndef add_string (input_list, format_string):\n    return [format_string.format(item) for item in input_list]\n    \n\n"}
{"task_id": "Mbpp/391", "origin_solution": "<def_stmt>convert_list_dictionary keys values<block_start><if_stmt>len(keys)<ne>len(values)<or>len(keys)<eq>0<or>len(values)<eq>0<block_start><return>[]<block_end>result={}<for_stmt>i range(len(keys))<block_start>result[keys[i]]={keys[i]:values[i]}<block_end><return>list(result.values())<block_end>\n", "solution": "\ndef convert_list_dictionary (keys, values):\n    if len(keys)!=len(values) or len(keys)==0 or len(values)==0:\n        return []\n        \n    result={}\n    for i in range(len(keys)):\n        result[keys[i]]={keys[i]:values[i]}\n        \n    return list(result.values())\n    \n\n"}
{"task_id": "Mbpp/392", "origin_solution": "<def_stmt>get_max_sum n<block_start>memo={}<def_stmt>helper n<block_start><if_stmt>n<eq>0<block_start><return>0<block_end><if_stmt>n<in>memo<block_start><return>memo[n]<block_end>result=max(helper(n<floordiv>2)+helper(n<floordiv>3)+helper(n<floordiv>4)+helper(n<floordiv>5) n)<line_sep>memo[n]=result<line_sep><return>result<block_end><return>helper(n)<block_end>\n", "solution": "\ndef get_max_sum (n):\n    memo={}\n    def helper (n):\n        if n==0:\n            return 0\n            \n        if n in memo:\n            return memo[n]\n            \n        result=max(helper(n//2)+helper(n//3)+helper(n//4)+helper(n//5), n)\n        memo[n]=result\n        return result\n        \n    return helper(n)\n    \n\n"}
{"task_id": "Mbpp/394", "origin_solution": "<def_stmt>check_distinct test_tup<block_start><return>len(test_tup)<eq>len(set(test_tup))<block_end>\n", "solution": "\ndef check_distinct (test_tup):\n    return len(test_tup)==len(set(test_tup))\n    \n\n"}
{"task_id": "Mbpp/395", "origin_solution": "<def_stmt>first_non_repeating_character s<block_start>char_count={}<for_stmt>char s<block_start><if_stmt>char<in>char_count<block_start>char_count[char]<augadd>1<block_end><else_stmt><block_start>char_count[char]=1<block_end><block_end><for_stmt>char s<block_start><if_stmt>char_count[char]<eq>1<block_start><return>char<block_end><block_end><return><none><block_end>\n", "solution": "\ndef first_non_repeating_character (s):\n    char_count={}\n    for char in s:\n        if char in char_count:\n            char_count[char]+=1\n            \n        \n        else :\n            char_count[char]=1\n            \n    \n    for char in s:\n        if char_count[char]==1:\n            return char\n            \n    \n    return  None \n    \n\n"}
{"task_id": "Mbpp/397", "origin_solution": "<def_stmt>median_numbers a b c<block_start>numbers=[a b c]<line_sep>numbers.sort()<line_sep><return>numbers[1]<block_end>\n", "solution": "\ndef median_numbers (a, b, c):\n    numbers=[a, b, c]\n    numbers.sort()\n    return numbers[1]\n    \n\n"}
{"task_id": "Mbpp/398", "origin_solution": "<def_stmt>sum_of_digits lst<block_start>total=0<for_stmt>i lst<block_start><if_stmt>isinstance(i list)<block_start>total<augadd>sum_of_digits(i)<block_end><else_stmt><block_start>total<augadd>sum(int(digit)<for>digit str(i))<block_end><block_end><return>total<block_end>\n", "solution": "\ndef sum_of_digits (lst):\n    total=0\n    for i in lst:\n        if isinstance(i, list):\n            total+=sum_of_digits(i)\n            \n        \n        else :\n            total+=sum(int(digit) for digit in str(i))\n            \n    \n    return total\n    \n\n"}
{"task_id": "Mbpp/404", "origin_solution": "<def_stmt>minimum a b<block_start><return>a<if>a<l>b<else>b<block_end>\n", "solution": "\ndef minimum (a, b):\n    return a if a<b else b\n    \n\n"}
{"task_id": "Mbpp/405", "origin_solution": "<def_stmt>check_tuplex tuplex element<block_start><return>element<in>tuplex<block_end>\n", "solution": "\ndef check_tuplex (tuplex, element):\n    return element in tuplex\n    \n\n"}
{"task_id": "Mbpp/406", "origin_solution": "<def_stmt>find_Parity n<block_start><return>n%2<ne>0<block_end>\n", "solution": "\ndef find_Parity (n):\n    return n%2!=0\n    \n\n"}
{"task_id": "Mbpp/409", "origin_solution": "<def_stmt>min_product_tuple tuples_list<block_start>min_product=float('inf')<for_stmt>i range(len(tuples_list))<block_start><for_stmt>j range(i+1 len(tuples_list))<block_start>product=tuples_list[i][0]<times>tuples_list[j][0]<if_stmt>product<l>min_product<block_start>min_product=product<block_end>product=tuples_list[i][1]<times>tuples_list[j][1]<if_stmt>product<l>min_product<block_start>min_product=product<block_end><block_end><block_end><return>min_product<block_end>\n", "solution": "\ndef min_product_tuple (tuples_list):\n    min_product=float('inf')\n    for i in range(len(tuples_list)):\n        for j in range(i+1, len(tuples_list)):\n            product=tuples_list[i][0]*tuples_list[j][0]\n            if product<min_product:\n                min_product=product\n                \n            product=tuples_list[i][1]*tuples_list[j][1]\n            if product<min_product:\n                min_product=product\n                \n        \n    \n    return min_product\n    \n\n"}
{"task_id": "Mbpp/410", "origin_solution": "<def_stmt>min_val lst<block_start><return>min(lst)<block_end>\n", "solution": "\ndef min_val (lst):\n    return min(lst)\n    \n\n"}
{"task_id": "Mbpp/412", "origin_solution": "<def_stmt>remove_odd lst<block_start><return>[num<for>num lst<if>num%2<eq>0]<block_end>\n", "solution": "\ndef remove_odd (lst):\n    return [num for num in lst if num%2==0]\n    \n\n"}
{"task_id": "Mbpp/413", "origin_solution": "<def_stmt>extract_nth_element list_of_tuples n<block_start><return>[t[n]<for>t list_of_tuples]<block_end>\n", "solution": "\ndef extract_nth_element (list_of_tuples, n):\n    return [t[n] for t in list_of_tuples]\n    \n\n"}
{"task_id": "Mbpp/414", "origin_solution": "<def_stmt>overlapping seq1 seq2<block_start><return>any(item<in>seq2<for>item seq1)<block_end>\n", "solution": "\ndef overlapping (seq1, seq2):\n    return any(item in seq2 for item in seq1)\n    \n\n"}
{"task_id": "Mbpp/415", "origin_solution": "<def_stmt>max_Product arr<block_start>max1,max2=float('-inf') float('-inf')<line_sep>min1,min2=float('inf') float('inf')<for_stmt>num arr<block_start><if_stmt>num<g>max1<block_start>max2,max1=max1 num<block_end><elif_stmt>num<g>max2<block_start>max2=num<block_end><if_stmt>num<l>min1<block_start>min2,min1=min1 num<block_end><elif_stmt>num<l>min2<block_start>min2=num<block_end><block_end><return>(max1<times>max2 min1<times>min2)<if>max1<times>max2<g>min1<times>min2<else>(min1<times>min2 max1<times>max2)<block_end>\n", "solution": "\ndef max_Product (arr):\n    max1,max2=float('-inf'), float('-inf')\n    min1,min2=float('inf'), float('inf')\n    for num in arr:\n        if num>max1:\n            max2,max1=max1, num\n            \n        \n        elif num>max2:\n            max2=num\n            \n        if num<min1:\n            min2,min1=min1, num\n            \n        \n        elif num<min2:\n            min2=num\n            \n    \n    return (max1*max2, min1*min2) if max1*max2>min1*min2 else (min1*min2, max1*max2)\n    \n\n"}
{"task_id": "Mbpp/418", "origin_solution": "<def_stmt>Find_Max lst<block_start><return>max(lst key=len)<block_end>\n", "solution": "\ndef Find_Max (lst):\n    return max(lst, key=len)\n    \n\n"}
{"task_id": "Mbpp/419", "origin_solution": "<def_stmt>round_and_sum input_list<block_start>total=0<for_stmt>number input_list<block_start>total<augadd>round(number)<block_end><return>total<times>len(input_list)<block_end>\n", "solution": "\ndef round_and_sum (input_list):\n    total=0\n    for number in input_list:\n        total+=round(number)\n        \n    return total*len(input_list)\n    \n\n"}
{"task_id": "Mbpp/420", "origin_solution": "<def_stmt>cube_Sum n<block_start>total=0<for_stmt>i range(1 n+1)<block_start>total<augadd>(2<times>i)<power>3<block_end><return>total<block_end>\n", "solution": "\ndef cube_Sum (n):\n    total=0\n    for i in range(1, n+1):\n        total+=(2*i)**3\n        \n    return total\n    \n\n"}
{"task_id": "Mbpp/421", "origin_solution": "<def_stmt>concatenate_tuple t:tuple delimiter:str<arrow>str<block_start><return>delimiter.join(map(str t))<block_end>\n", "solution": "\ndef concatenate_tuple (t:tuple, delimiter:str)->str:\n    return delimiter.join(map(str, t))\n    \n\n"}
{"task_id": "Mbpp/422", "origin_solution": "<def_stmt>find_Average_Of_Cube n<block_start>total=0<for_stmt>i range(1 n+1)<block_start>total<augadd>i<power>3<block_end><return>total/n<block_end>\n", "solution": "\ndef find_Average_Of_Cube (n):\n    total=0\n    for i in range(1, n+1):\n        total+=i**3\n        \n    return total/n\n    \n\n"}
{"task_id": "Mbpp/424", "origin_solution": "<def_stmt>extract_rear test_tup<block_start><return>[c[-1]<for>c test_tup]<block_end>\n", "solution": "\ndef extract_rear (test_tup):\n    return [c[-1] for c in test_tup]\n    \n\n"}
{"task_id": "Mbpp/425", "origin_solution": "<def_stmt>count_element_in_list lst element<block_start>count=0<for_stmt>sublist lst<block_start><if_stmt>element<in>sublist<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_element_in_list (lst, element):\n    count=0\n    for sublist in lst:\n        if element in sublist:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/426", "origin_solution": "<def_stmt>filter_oddnumbers numbers<block_start><return>[num<for>num numbers<if>num%2<ne>0]<block_end>\n", "solution": "\ndef filter_oddnumbers (numbers):\n    return [num for num in numbers if num%2!=0]\n    \n\n"}
{"task_id": "Mbpp/427", "origin_solution": "<def_stmt>change_date_format date<block_start><return>date[-2:]+'-'+date[0:2]+'-'+date[3:5]<block_end>\n", "solution": "\ndef change_date_format (date):\n    return date[-2:]+'-'+date[0:2]+'-'+date[3:5]\n    \n\n"}
{"task_id": "Mbpp/428", "origin_solution": "<def_stmt>shell_sort arr<block_start>gap=len(arr)<floordiv>2<while_stmt>gap<g>0<block_start><for_stmt>i range(gap len(arr))<block_start>temp=arr[i]<line_sep>j=i<while_stmt>j<ge>gap<and>arr[j-gap]<g>temp<block_start>arr[j]=arr[j-gap]<line_sep>j<augsub>gap<block_end>arr[j]=temp<block_end>gap<augfloordiv>2<block_end><return>arr<block_end>\n", "solution": "\ndef shell_sort (arr):\n    gap=len(arr)//2\n    while gap>0:\n        for i in range(gap, len(arr)):\n            temp=arr[i]\n            j=i\n            while j>=gap and arr[j-gap]>temp:\n                arr[j]=arr[j-gap]\n                j-=gap\n                \n            arr[j]=temp\n            \n        gap//=2\n        \n    return arr\n    \n\n"}
{"task_id": "Mbpp/429", "origin_solution": "<def_stmt>and_tuples tup1 tup2<block_start>res=[]<for_stmt>i range(len(tup1))<block_start><if_stmt>i<l>len(tup2)<block_start>res.append(tup1[i]-tup2[i])<block_end><else_stmt><block_start>res.append(0)<block_end><block_end><return>tuple(res)<block_end>\n", "solution": "\ndef and_tuples (tup1, tup2):\n    res=[]\n    for i in range(len(tup1)):\n        if i<len(tup2):\n            res.append(tup1[i]-tup2[i])\n            \n        \n        else :\n            res.append(0)\n            \n    \n    return tuple(res)\n    \n\n"}
{"task_id": "Mbpp/430", "origin_solution": "<def_stmt>parabola_directrix a b c<block_start>\"\"\"\n    Calculate the directrix of a parabola given its vertex coordinates (a, b) and its focal length c.\n\n    :param a: x-coordinate of the vertex\n    :param b: y-coordinate of the vertex\n    :param c: focal length\n    :return: The directrix of the parabola\n    \"\"\"<line_sep>directrix=-b/(2<times>a)<line_sep><return>directrix<block_end>\n", "solution": "\ndef parabola_directrix (a, b, c):\n    \"\"\"\n    Calculate the directrix of a parabola given its vertex coordinates (a, b) and its focal length c.\n\n    :param a: x-coordinate of the vertex\n    :param b: y-coordinate of the vertex\n    :param c: focal length\n    :return: The directrix of the parabola\n    \"\"\"\n    directrix=-b/(2*a)\n    return directrix\n    \n\n"}
{"task_id": "Mbpp/432", "origin_solution": "<def_stmt>median_trapezium a b c<block_start><return>(b+c)/2<block_end>\n", "solution": "\ndef median_trapezium (a, b, c):\n    return (b+c)/2\n    \n\n"}
{"task_id": "Mbpp/433", "origin_solution": "<def_stmt>check_greater arr num<block_start><for_stmt>i arr<block_start><if_stmt>i<g>num<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef check_greater (arr, num):\n    for i in arr:\n        if i>num:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/435", "origin_solution": "<def_stmt>last_Digit n<block_start><return>n%10<block_end>\n", "solution": "\ndef last_Digit (n):\n    return n%10\n    \n\n"}
{"task_id": "Mbpp/436", "origin_solution": "<def_stmt>neg_nos lst<block_start><return>[i<for>i lst<if>i<l>0]<block_end>\n", "solution": "\ndef neg_nos (lst):\n    return [i for i in lst if i<0]\n    \n\n"}
{"task_id": "Mbpp/437", "origin_solution": "<def_stmt>remove_odd s<block_start>result=\"\"<for_stmt>char s<block_start><if_stmt>ord(char)%2<eq>0<block_start>result<augadd>char<block_end><block_end><return>result<block_end>\n", "solution": "\ndef remove_odd (s):\n    result=\"\"\n    for char in s:\n        if ord(char)%2==0:\n            result+=char\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/439", "origin_solution": "<def_stmt>multiple_to_single numbers<block_start>result=0<for_stmt>i range(len(numbers))<block_start>result=result<times>10+numbers[i]<block_end><return>result<block_end>\n", "solution": "\ndef multiple_to_single (numbers):\n    result=0\n    for i in range(len(numbers)):\n        result=result*10+numbers[i]\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/440", "origin_solution": "<import_stmt>re<def_stmt>find_adverb_position sentence<block_start>adverb_pattern=r'\\b(\\b(?:quickly|easily|quick|fast|slowly|slow|young|old|hot|cold|sick|healthy|rich|poor|happy|sad|angry|surprised|confused|stuck|frustrated|embarrassed|anxious|worried|fearful|anxious|frustrated|embarrassed|anxious|frightened|fearful|angry|surprised|confused|stuck|lazy|active|tired|bored|content|unhappy|joyful|merry|cheerful|worried|frightened|fearful|angry|surprised|confused|stuck|lazy|active|tired|bored|content|unhappy|joyful|merry|cheerful)\\b'<line_sep>match=re.search(adverb_pattern sentence)<if_stmt>match<block_start>adverb=match.group(0)<line_sep>start_pos=match.start()<line_sep>end_pos=match.end()<line_sep><return>(start_pos end_pos adverb)<block_end><else_stmt><block_start><return><none><block_end><block_end>\n", "solution": "\nimport re\ndef find_adverb_position (sentence):\n    adverb_pattern=r'\\b(\\b(?:quickly|easily|quick|fast|slowly|slow|young|old|hot|cold|sick|healthy|rich|poor|happy|sad|angry|surprised|confused|stuck|frustrated|embarrassed|anxious|worried|fearful|anxious|frustrated|embarrassed|anxious|frightened|fearful|angry|surprised|confused|stuck|lazy|active|tired|bored|content|unhappy|joyful|merry|cheerful|worried|frightened|fearful|angry|surprised|confused|stuck|lazy|active|tired|bored|content|unhappy|joyful|merry|cheerful)\\b'\n    match=re.search(adverb_pattern, sentence)\n    if match:\n        adverb=match.group(0)\n        start_pos=match.start()\n        end_pos=match.end()\n        return (start_pos, end_pos, adverb)\n        \n    \n    else :\n        return  None \n        \n\n\n"}
{"task_id": "Mbpp/441", "origin_solution": "<def_stmt>surfacearea_cube n<block_start><return>6<times>n<power>2<block_end>\n", "solution": "\ndef surfacearea_cube (n):\n    return 6*n**2\n    \n\n"}
{"task_id": "Mbpp/445", "origin_solution": "<def_stmt>index_multiplication test_tup1 test_tup2<block_start>res=tuple(tuple(a<times>b<for>a,b zip(tup1 tup2))<for>tup1,tup2 zip(test_tup1 test_tup2))<line_sep><return>res<block_end>\n", "solution": "\ndef index_multiplication (test_tup1, test_tup2):\n    res=tuple(tuple(a*b for a,b in zip(tup1, tup2)) for tup1,tup2 in zip(test_tup1, test_tup2))\n    return res\n    \n\n"}
{"task_id": "Mbpp/446", "origin_solution": "<def_stmt>count_Occurrence iterable_list elements_list<block_start>count=0<for_stmt>i iterable_list<block_start><if_stmt>i<in>elements_list<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_Occurrence (iterable_list, elements_list):\n    count=0\n    for i in iterable_list:\n        if i in elements_list:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/447", "origin_solution": "<def_stmt>cube_nums nums<block_start><return>[num<power>3<for>num nums]<block_end>\n", "solution": "\ndef cube_nums (nums):\n    return [num**3 for num in nums]\n    \n\n"}
{"task_id": "Mbpp/448", "origin_solution": "<def_stmt>cal_sum n<block_start>p=[0 2 2 4 2 8 2 14 2 28 2 34 2 44 2 54 2 66]<if_stmt>n<l>len(p)<block_start><return>p[n]<block_end><else_stmt><block_start><return>sum(cal_sum(i)<for>i range(n+1))<block_end><block_end>\n", "solution": "\ndef cal_sum (n):\n    p=[0, 2, 2, 4, 2, 8, 2, 14, 2, 28, 2, 34, 2, 44, 2, 54, 2, 66]\n    if n<len(p):\n        return p[n]\n        \n    \n    else :\n        return sum(cal_sum(i) for i in range(n+1))\n        \n\n\n"}
{"task_id": "Mbpp/450", "origin_solution": "<def_stmt>extract_string string_list size<block_start><return>string_list[-size:]<if>size<le>len(string_list)<else>[]<block_end>\n", "solution": "\ndef extract_string (string_list, size):\n    return string_list[-size:] if size<=len(string_list) else []\n    \n\n"}
{"task_id": "Mbpp/451", "origin_solution": "<def_stmt>remove_whitespaces s<block_start><return>s.replace(' ' '')<block_end>\n", "solution": "\ndef remove_whitespaces (s):\n    return s.replace(' ', '')\n    \n\n"}
{"task_id": "Mbpp/453", "origin_solution": "<def_stmt>sumofFactors n<block_start>sum=0<for_stmt>i range(2 n+1)<block_start><if_stmt>n%i<eq>0<and>i%2<eq>0<block_start>sum<augadd>i<block_end><block_end><return>sum<block_end>\n", "solution": "\ndef sumofFactors (n):\n    sum=0\n    for i in range(2, n+1):\n        if n%i==0 and i%2==0:\n            sum+=i\n            \n    \n    return sum\n    \n\n"}
{"task_id": "Mbpp/454", "origin_solution": "<import_stmt>re<def_stmt>text_match_wordz text<block_start>\"\"\"\n    Check if the given text contains a word that matches the pattern 'z'.\n    \n    Args:\n    text (str): The text to search within.\n    \n    Returns:\n    bool: True if a match is found, False otherwise.\n    \"\"\"<line_sep>pattern=r'\\bz\\b'<line_sep>match=re.search(pattern text)<line_sep><return>match<is><not><none><block_end>\n", "solution": "\nimport re\ndef text_match_wordz (text):\n    \"\"\"\n    Check if the given text contains a word that matches the pattern 'z'.\n    \n    Args:\n    text (str): The text to search within.\n    \n    Returns:\n    bool: True if a match is found, False otherwise.\n    \"\"\"\n    pattern=r'\\bz\\b'\n    match=re.search(pattern, text)\n    return match is  not  None \n    \n\n"}
{"task_id": "Mbpp/455", "origin_solution": "<def_stmt>check_monthnumb_number month_num<block_start>month_days=[31 28 31 30 31 30 31 31 30 31 30 31]<if_stmt>month_num<l>1<or>month_num<g>12<block_start><return><false><block_end><if_stmt>month_num<eq>2<block_start><if_stmt>month_days[1]<eq>29<block_start><return><false><block_end><block_end><if_stmt>month_num<in>[4 6 9 11]<block_start><return><true><block_end><return><false><block_end>\n", "solution": "\ndef check_monthnumb_number (month_num):\n    month_days=[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if month_num<1 or month_num>12:\n        return  False \n        \n    if month_num==2:\n        if month_days[1]==29:\n            return  False \n            \n    \n    if month_num in [4, 6, 9, 11]:\n        return  True \n        \n    return  False \n    \n\n"}
{"task_id": "Mbpp/456", "origin_solution": "<def_stmt>reverse_string_list string_list<block_start>reversed_list=[]<for_stmt>string string_list<block_start>reversed_list.append(string[::-1])<block_end><return>reversed_list<block_end>\n", "solution": "\ndef reverse_string_list (string_list):\n    reversed_list=[]\n    for string in string_list:\n        reversed_list.append(string[::-1])\n        \n    return reversed_list\n    \n\n"}
{"task_id": "Mbpp/457", "origin_solution": "<def_stmt>Find_Min lst<block_start>min_length=float('inf')<line_sep>min_list=[]<for_stmt>sublist lst<block_start><if_stmt>len(sublist)<l>min_length<block_start>min_length=len(sublist)<line_sep>min_list=sublist<block_end><block_end><return>min_list<block_end>\n", "solution": "\ndef Find_Min (lst):\n    min_length=float('inf')\n    min_list=[]\n    for sublist in lst:\n        if len(sublist)<min_length:\n            min_length=len(sublist)\n            min_list=sublist\n            \n    \n    return min_list\n    \n\n"}
{"task_id": "Mbpp/458", "origin_solution": "<def_stmt>rectangle_area length width<block_start><return>length<times>width<block_end>\n", "solution": "\ndef rectangle_area (length, width):\n    return length*width\n    \n\n"}
{"task_id": "Mbpp/459", "origin_solution": "<def_stmt>remove_uppercase s<block_start>result=[]<for_stmt>char s<block_start><if_stmt>char.islower()<block_start>result.append(char)<block_end><block_end><return>''.join(result)<block_end>\n", "solution": "\ndef remove_uppercase (s):\n    result=[]\n    for char in s:\n        if char.islower():\n            result.append(char)\n            \n    \n    return ''.join(result)\n    \n\n"}
{"task_id": "Mbpp/460", "origin_solution": "<def_stmt>Extract list_of_lists<block_start><return>[item[0]<for>item list_of_lists]<block_end>\n", "solution": "\ndef Extract (list_of_lists):\n    return [item[0] for item in list_of_lists]\n    \n\n"}
{"task_id": "Mbpp/462", "origin_solution": "<import_from_stmt>itertools chain combinations<def_stmt>combinations_list lst<block_start>result=[]<for_stmt>i range(len(lst)+1)<block_start>result.extend(combinations(lst i))<block_end><return>[list(item)<for>item result]<block_end>\n", "solution": "\nfrom itertools import chain, combinations\ndef combinations_list (lst):\n    result=[]\n    for i in range(len(lst)+1):\n        result.extend(combinations(lst, i))\n        \n    return [list(item) for item in result]\n    \n\n"}
{"task_id": "Mbpp/463", "origin_solution": "<def_stmt>max_subarray_product nums<block_start><if_stmt><not>nums<block_start><return>0<block_end>max_product=nums[0]<line_sep>min_product=nums[0]<line_sep>result=nums[0]<for_stmt>i range(1 len(nums))<block_start>temp=max_product<line_sep>max_product=max(nums[i] max_product<times>nums[i] min_product<times>nums[i])<line_sep>min_product=min(nums[i] temp<times>nums[i] min_product<times>nums[i])<line_sep>result=max(result max_product)<block_end><return>result<block_end>\n", "solution": "\ndef max_subarray_product (nums):\n    if  not nums:\n        return 0\n        \n    max_product=nums[0]\n    min_product=nums[0]\n    result=nums[0]\n    for i in range(1, len(nums)):\n        temp=max_product\n        max_product=max(nums[i], max_product*nums[i], min_product*nums[i])\n        min_product=min(nums[i], temp*nums[i], min_product*nums[i])\n        result=max(result, max_product)\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/465", "origin_solution": "<def_stmt>drop_empty dictionary<block_start><return>{k:v<for>k,v dictionary.items()<if>v<is><not><none>}<block_end>\n", "solution": "\ndef drop_empty (dictionary):\n    return {k:v for k,v in dictionary.items() if v is  not  None }\n    \n\n"}
{"task_id": "Mbpp/468", "origin_solution": "<def_stmt>max_product arr<block_start>n=len(arr)<line_sep>max_product=[0]<times>n<line_sep>max_product[0]=arr[0]<for_stmt>i range(1 n)<block_start>max_product[i]=max(arr[i]<times>max_product[i-1] arr[i])<block_end><return>max(max_product)<block_end>\n", "solution": "\ndef max_product (arr):\n    n=len(arr)\n    max_product=[0]*n\n    max_product[0]=arr[0]\n    for i in range(1, n):\n        max_product[i]=max(arr[i]*max_product[i-1], arr[i])\n        \n    return max(max_product)\n    \n\n"}
{"task_id": "Mbpp/470", "origin_solution": "<def_stmt>add_pairwise test_tup<block_start>res=tuple(test_tup[i]+test_tup[i+1]<for>i range(len(test_tup)-1))<line_sep><return>res<block_end>\n", "solution": "\ndef add_pairwise (test_tup):\n    res=tuple(test_tup[i]+test_tup[i+1] for i in range(len(test_tup)-1))\n    return res\n    \n\n"}
{"task_id": "Mbpp/471", "origin_solution": "<def_stmt>find_remainder arr n<block_start>product=1<for_stmt>num arr<block_start>product=(product<times>num)%n<block_end><return>product<block_end>\n", "solution": "\ndef find_remainder (arr, n):\n    product=1\n    for num in arr:\n        product=(product*num)%n\n        \n    return product\n    \n\n"}
{"task_id": "Mbpp/472", "origin_solution": "<def_stmt>check_Consecutive arr<block_start>arr.sort()<for_stmt>i range(len(arr)-1)<block_start><if_stmt>arr[i]+1<ne>arr[i+1]<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef check_Consecutive (arr):\n    arr.sort()\n    for i in range(len(arr)-1):\n        if arr[i]+1!=arr[i+1]:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/473", "origin_solution": "<def_stmt>tuple_intersection test_list1 test_list2<block_start>res=set([tuple(sorted(ele))<for>ele test_list1])&set([tuple(sorted(ele))<for>ele test_list2])<line_sep><return>res<block_end>\n", "solution": "\ndef tuple_intersection (test_list1, test_list2):\n    res=set([tuple(sorted(ele)) for ele in test_list1])&set([tuple(sorted(ele)) for ele in test_list2])\n    return res\n    \n\n"}
{"task_id": "Mbpp/474", "origin_solution": "<def_stmt>replace_char s old new<block_start><return>s.replace(old new)<block_end>\n", "solution": "\ndef replace_char (s, old, new):\n    return s.replace(old, new)\n    \n\n"}
{"task_id": "Mbpp/475", "origin_solution": "<def_stmt>sort_counter counter_dict<block_start><return>sorted(counter_dict.items() key=<lambda>x:x[1])<block_end>\n", "solution": "\ndef sort_counter (counter_dict):\n    return sorted(counter_dict.items(), key=lambda x:x[1])\n    \n\n"}
{"task_id": "Mbpp/476", "origin_solution": "<def_stmt>big_sum arr<block_start><return>min(arr)+max(arr)<block_end>\n", "solution": "\ndef big_sum (arr):\n    return min(arr)+max(arr)\n    \n\n"}
{"task_id": "Mbpp/477", "origin_solution": "<def_stmt>is_lower s<block_start><return>s.lower()<block_end>\n", "solution": "\ndef is_lower (s):\n    return s.lower()\n    \n\n"}
{"task_id": "Mbpp/478", "origin_solution": "<def_stmt>remove_lowercase s<block_start>result=\"\"<for_stmt>char s<block_start><if_stmt>char.isupper()<block_start>result<augadd>char<block_end><block_end><return>result<block_end>\n", "solution": "\ndef remove_lowercase (s):\n    result=\"\"\n    for char in s:\n        if char.isupper():\n            result+=char\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/479", "origin_solution": "<def_stmt>first_Digit n<block_start><while_stmt>n<ge>10<block_start>n=n<floordiv>10<block_end><return>n<block_end>\n", "solution": "\ndef first_Digit (n):\n    while n>=10:\n        n=n//10\n        \n    return n\n    \n\n"}
{"task_id": "Mbpp/554", "origin_solution": "<def_stmt>Split arr<block_start><return>[i<for>i arr<if>i%2<ne>0]<block_end>\n", "solution": "\ndef Split (arr):\n    return [i for i in arr if i%2!=0]\n    \n\n"}
{"task_id": "Mbpp/555", "origin_solution": "<def_stmt>difference n<block_start>sum_of_cubes=sum([i<power>3<for>i range(1 n+1)])<line_sep>sum_of_numbers=sum([i<for>i range(1 n+1)])<line_sep><return>sum_of_cubes-sum_of_numbers<block_end>\n", "solution": "\ndef difference (n):\n    sum_of_cubes=sum([i**3 for i in range(1, n+1)])\n    sum_of_numbers=sum([i for i in range(1, n+1)])\n    return sum_of_cubes-sum_of_numbers\n    \n\n"}
{"task_id": "Mbpp/556", "origin_solution": "<def_stmt>find_Odd_Pair arr n<block_start>odd_count=0<for_stmt>i range(n)<block_start><if_stmt>(arr[i]%2)<block_start>odd_count<augadd>1<block_end><block_end><return>odd_count<times>2<block_end>\n", "solution": "\ndef find_Odd_Pair (arr, n):\n    odd_count=0\n    for i in range(n):\n        if (arr[i]%2):\n            odd_count+=1\n            \n    \n    return odd_count*2\n    \n\n"}
{"task_id": "Mbpp/557", "origin_solution": "<def_stmt>toggle_string s<block_start><return>''.join([char.lower()<if>char.isupper()<else>char.upper()<for>char s])<block_end>\n", "solution": "\ndef toggle_string (s):\n    return ''.join([char.lower() if char.isupper() else char.upper() for char in s])\n    \n\n"}
{"task_id": "Mbpp/558", "origin_solution": "<def_stmt>digit_distance_nums num1 num2<block_start>distance=abs(num1-num2)<line_sep>distance_str=str(distance)<line_sep>total_distance=0<for_stmt>digit distance_str<block_start>total_distance<augadd>int(digit)<block_end><return>total_distance<block_end>\n", "solution": "\ndef digit_distance_nums (num1, num2):\n    distance=abs(num1-num2)\n    distance_str=str(distance)\n    total_distance=0\n    for digit in distance_str:\n        total_distance+=int(digit)\n        \n    return total_distance\n    \n\n"}
{"task_id": "Mbpp/559", "origin_solution": "<def_stmt>max_sub_array_sum nums k<block_start>max_sum=float('-inf')<line_sep>current_sum=0<for_stmt>num nums<block_start>current_sum=max(num current_sum+num)<line_sep>max_sum=max(max_sum current_sum)<block_end><return>max_sum<if>max_sum<g>k<else>k<block_end>\n", "solution": "\ndef max_sub_array_sum (nums, k):\n    max_sum=float('-inf')\n    current_sum=0\n    for num in nums:\n        current_sum=max(num, current_sum+num)\n        max_sum=max(max_sum, current_sum)\n        \n    return max_sum if max_sum>k else k\n    \n\n"}
{"task_id": "Mbpp/560", "origin_solution": "<def_stmt>union_elements test_tup1 test_tup2<block_start>res=set(test_tup1).union(set(test_tup2))<line_sep><return>tuple(sorted(res))<block_end>\n", "solution": "\ndef union_elements (test_tup1, test_tup2):\n    res=set(test_tup1).union(set(test_tup2))\n    return tuple(sorted(res))\n    \n\n"}
{"task_id": "Mbpp/562", "origin_solution": "<def_stmt>Find_Max_Length lst<block_start><return>max(len(sublist)<for>sublist lst)<block_end>\n", "solution": "\ndef Find_Max_Length (lst):\n    return max(len(sublist) for sublist in lst)\n    \n\n"}
{"task_id": "Mbpp/563", "origin_solution": "<def_stmt>extract_values s<block_start>result=[]<line_sep>current=[]<line_sep>in_quotes=<false><for_stmt>char s<block_start><if_stmt>char<eq>'\"'<block_start>in_quotes=<not>in_quotes<if_stmt><not>in_quotes<block_start>result.append(''.join(current))<line_sep>current=[]<block_end><block_end><elif_stmt>in_quotes<block_start>current.append(char)<block_end><block_end><return>result<block_end>\n", "solution": "\ndef extract_values (s):\n    result=[]\n    current=[]\n    in_quotes= False \n    for char in s:\n        if char=='\"':\n            in_quotes= not in_quotes\n            if  not in_quotes:\n                result.append(''.join(current))\n                current=[]\n                \n        \n        \n        elif in_quotes:\n            current.append(char)\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/564", "origin_solution": "<def_stmt>count_Pairs arr n<block_start>count=0<for_stmt>i range(n)<block_start><for_stmt>j range(i+1 n)<block_start><if_stmt>arr[i]<ne>arr[j]<block_start>count<augadd>1<block_end><block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_Pairs (arr, n):\n    count=0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i]!=arr[j]:\n                count+=1\n                \n        \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/565", "origin_solution": "<def_stmt>split s<block_start><return>list(s)<block_end>\n", "solution": "\ndef split (s):\n    return list(s)\n    \n\n"}
{"task_id": "Mbpp/566", "origin_solution": "<def_stmt>sum_digits n<block_start><if_stmt>n<eq>0<block_start><return>0<block_end><else_stmt><block_start><return>n%10+sum_digits(n<floordiv>10)<block_end><block_end>\n", "solution": "\ndef sum_digits (n):\n    if n==0:\n        return 0\n        \n    \n    else :\n        return n%10+sum_digits(n//10)\n        \n\n\n"}
{"task_id": "Mbpp/567", "origin_solution": "<def_stmt>issort_list input_list<block_start><for_stmt>i range(len(input_list)-1)<block_start><if_stmt>input_list[i]<g>input_list[i+1]<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef issort_list (input_list):\n    for i in range(len(input_list)-1):\n        if input_list[i]>input_list[i+1]:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/568", "origin_solution": "<def_stmt>empty_list n<block_start><return>[{}<for>_ range(n)]<block_end>\n", "solution": "\ndef empty_list (n):\n    return [{} for _ in range(n)]\n    \n\n"}
{"task_id": "Mbpp/569", "origin_solution": "<def_stmt>sort_sublists lst<block_start><return>[sorted(sublist)<for>sublist lst]<block_end>\n", "solution": "\ndef sort_sublists (lst):\n    return [sorted(sublist) for sublist in lst]\n    \n\n"}
{"task_id": "Mbpp/572", "origin_solution": "<def_stmt>two_unique_nums nums_list<block_start>unique_nums=[]<for_stmt>num nums_list<block_start><if_stmt>num<not><in>unique_nums<block_start>unique_nums.append(num)<block_end><block_end><return>unique_nums<block_end>\n", "solution": "\ndef two_unique_nums (nums_list):\n    unique_nums=[]\n    for num in nums_list:\n        if num not  in unique_nums:\n            unique_nums.append(num)\n            \n    \n    return unique_nums\n    \n\n"}
{"task_id": "Mbpp/573", "origin_solution": "<def_stmt>unique_product nums<block_start>unique_nums=set(nums)<line_sep>product=1<for_stmt>num unique_nums<block_start>product<augmul>num<block_end><return>product<block_end>\n", "solution": "\ndef unique_product (nums):\n    unique_nums=set(nums)\n    product=1\n    for num in unique_nums:\n        product*=num\n        \n    return product\n    \n\n"}
{"task_id": "Mbpp/576", "origin_solution": "<def_stmt>is_Sub_Array sub main<block_start>len_sub=len(sub)<line_sep>len_main=len(main)<if_stmt>len_sub<g>len_main<block_start><return><false><block_end><for_stmt>i range(len_main-len_sub+1)<block_start><if_stmt>main[i:i+len_sub]<eq>sub<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef is_Sub_Array (sub, main):\n    len_sub=len(sub)\n    len_main=len(main)\n    if len_sub>len_main:\n        return  False \n        \n    for i in range(len_main-len_sub+1):\n        if main[i:i+len_sub]==sub:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/577", "origin_solution": "<def_stmt>last_Digit_Factorial n<block_start><if_stmt>n<l>0<block_start><return>\"Invalid input\"<block_end>factorial=1<for_stmt>i range(1 n+1)<block_start>factorial<augmul>i<line_sep>factorial=factorial%10<block_end><return>factorial<block_end>\n", "solution": "\ndef last_Digit_Factorial (n):\n    if n<0:\n        return \"Invalid input\"\n        \n    factorial=1\n    for i in range(1, n+1):\n        factorial*=i\n        factorial=factorial%10\n        \n    return factorial\n    \n\n"}
{"task_id": "Mbpp/578", "origin_solution": "<def_stmt>interleave_lists list1 list2 list3<block_start>result=[]<for_stmt>i range(len(list1))<block_start>result.append(list1[i])<line_sep>result.append(list2[i])<line_sep>result.append(list3[i])<block_end><return>result<block_end>\n", "solution": "\ndef interleave_lists (list1, list2, list3):\n    result=[]\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/579", "origin_solution": "<def_stmt>find_dissimilar t1 t2<block_start><return>tuple(set(t1)-set(t2)) tuple(set(t2)-set(t1))<block_end>\n", "solution": "\ndef find_dissimilar (t1, t2):\n    return tuple(set(t1)-set(t2)), tuple(set(t2)-set(t1))\n    \n\n"}
{"task_id": "Mbpp/580", "origin_solution": "<def_stmt>extract_even mixed_tuple<block_start>result=[]<for_stmt>item mixed_tuple<block_start><if_stmt>isinstance(item tuple)<block_start>result.append(extract_even(item))<block_end><elif_stmt>isinstance(item int)<and>item%2<eq>0<block_start>result.append(item)<block_end><block_end><return>tuple(result)<block_end>\n", "solution": "\ndef extract_even (mixed_tuple):\n    result=[]\n    for item in mixed_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n            \n        \n        elif isinstance(item, int) and item%2==0:\n            result.append(item)\n            \n    \n    return tuple(result)\n    \n\n"}
{"task_id": "Mbpp/581", "origin_solution": "<def_stmt>surface_Area side_length height<block_start>base_area=side_length<power>2<line_sep>lateral_area=2<times>side_length<times>height<line_sep>total_area=base_area+lateral_area<line_sep><return>total_area<block_end>\n", "solution": "\ndef surface_Area (side_length, height):\n    base_area=side_length**2\n    lateral_area=2*side_length*height\n    total_area=base_area+lateral_area\n    return total_area\n    \n\n"}
{"task_id": "Mbpp/583", "origin_solution": "<def_stmt>catalan_number n<block_start><if_stmt>n<le>1<block_start><return>1<block_end>catalan=[0<for>i range(n+1)]<line_sep>catalan[0]=1<line_sep>catalan[1]=1<for_stmt>i range(2 n+1)<block_start>catalan[i]=0<for_stmt>j range(i)<block_start>catalan[i]=catalan[i]+catalan[j]<times>catalan[i-j-1]<block_end><block_end><return>catalan[n]<block_end>\n", "solution": "\ndef catalan_number (n):\n    if n<=1:\n        return 1\n        \n    catalan=[0 for i in range(n+1)]\n    catalan[0]=1\n    catalan[1]=1\n    for i in range(2, n+1):\n        catalan[i]=0\n        for j in range(i):\n            catalan[i]=catalan[i]+catalan[j]*catalan[i-j-1]\n            \n    \n    return catalan[n]\n    \n\n"}
{"task_id": "Mbpp/585", "origin_solution": "<def_stmt>expensive_items dataset n<block_start>sorted_data=sorted(dataset key=<lambda>x:x['price'] reverse=<true>)<line_sep><return>sorted_data[:n]<block_end>\n", "solution": "\ndef expensive_items (dataset, n):\n    sorted_data=sorted(dataset, key=lambda x:x['price'], reverse= True )\n    return sorted_data[:n]\n    \n\n"}
{"task_id": "Mbpp/586", "origin_solution": "<def_stmt>split_Arr arr n<block_start><return>arr[n:]+arr[:n]<block_end>\n", "solution": "\ndef split_Arr (arr, n):\n    return arr[n:]+arr[:n]\n    \n\n"}
{"task_id": "Mbpp/587", "origin_solution": "<def_stmt>list_tuple lst<block_start><return>tuple(lst)<block_end>\n", "solution": "\ndef list_tuple (lst):\n    return tuple(lst)\n    \n\n"}
{"task_id": "Mbpp/588", "origin_solution": "<def_stmt>big_diff lst<block_start><return>max(lst)-min(lst)<block_end>\n", "solution": "\ndef big_diff (lst):\n    return max(lst)-min(lst)\n    \n\n"}
{"task_id": "Mbpp/589", "origin_solution": "<def_stmt>perfect_squares start end<block_start>squares=[]<for_stmt>i range(int(start<power>0.5) int(end<power>0.5)+1)<block_start>squares.append(i<times>i)<block_end><return>sorted(squares)<block_end>\n", "solution": "\ndef perfect_squares (start, end):\n    squares=[]\n    for i in range(int(start**0.5), int(end**0.5)+1):\n        squares.append(i*i)\n        \n    return sorted(squares)\n    \n\n"}
{"task_id": "Mbpp/590", "origin_solution": "<import_stmt>math<def_stmt>polar_rect r theta<block_start>x=r<times>math.cos(theta)<line_sep>y=r<times>math.sin(theta)<line_sep><return>(x y) (-2+2.4492935982947064e-16j)<block_end>\n", "solution": "\nimport math\ndef polar_rect (r, theta):\n    x=r*math.cos(theta)\n    y=r*math.sin(theta)\n    return (x, y), (-2+2.4492935982947064e-16j)\n    \n\n"}
{"task_id": "Mbpp/591", "origin_solution": "<def_stmt>swap_List lst<block_start><if_stmt>len(lst)<g>1<block_start>lst[0],lst[-1]=lst[-1] lst[0]<block_end><return>lst<block_end>\n", "solution": "\ndef swap_List (lst):\n    if len(lst)>1:\n        lst[0],lst[-1]=lst[-1], lst[0]\n        \n    return lst\n    \n\n"}
{"task_id": "Mbpp/592", "origin_solution": "<import_from_stmt>math factorial<def_stmt>binomial_coefficient n k<block_start><return>factorial(n)<floordiv>(factorial(k)<times>factorial(n-k))<block_end><def_stmt>sum_Of_product n<block_start>sum=0<for_stmt>i range(n)<block_start><for_stmt>j range(i+1 n)<block_start>sum<augadd>binomial_coefficient(i j)<times>binomial_coefficient(j+1 i-j)<block_end><block_end><return>sum<block_end>\n", "solution": "\nfrom math import factorial\ndef binomial_coefficient (n, k):\n    return factorial(n)//(factorial(k)*factorial(n-k))\n    \ndef sum_Of_product (n):\n    sum=0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum+=binomial_coefficient(i, j)*binomial_coefficient(j+1, i-j)\n            \n    \n    return sum\n    \n\n"}
{"task_id": "Mbpp/593", "origin_solution": "<def_stmt>removezero_ip ip_address<block_start>ip_parts=ip_address.split('.')<line_sep>ip_parts=[str(int(part))<for>part ip_parts]<line_sep><return>'.'.join(ip_parts)<block_end>\n", "solution": "\ndef removezero_ip (ip_address):\n    ip_parts=ip_address.split('.')\n    ip_parts=[str(int(part)) for part in ip_parts]\n    return '.'.join(ip_parts)\n    \n\n"}
{"task_id": "Mbpp/594", "origin_solution": "<def_stmt>diff_even_odd lst<block_start>even=lst[0]<if>lst[0]%2<eq>0<else><none><line_sep>odd=lst[0]<if>lst[0]%2<ne>0<else><none><while_stmt>even<is><not><none><and>even<not><in>lst<block_start>even=lst[lst.index(even)+1]<if>lst[lst.index(even)+1]%2<eq>0<else>lst[lst.index(even)+2]<if>lst[lst.index(even)+2]%2<ne>0<else><none><block_end><while_stmt>odd<is><not><none><and>odd<not><in>lst<block_start>odd=lst[lst.index(odd)+1]<if>lst[lst.index(odd)+1]%2<ne>0<else>lst[lst.index(odd)+2]<if>lst[lst.index(odd)+2]%2<eq>0<else><none><block_end><return>odd-even<if>odd<is><not><none><and>even<is><not><none><else><none><block_end>\n", "solution": "\ndef diff_even_odd (lst):\n    even=lst[0] if lst[0]%2==0 else  None \n    odd=lst[0] if lst[0]%2!=0 else  None \n    while even is  not  None  and even not  in lst:\n        even=lst[lst.index(even)+1] if lst[lst.index(even)+1]%2==0 else lst[lst.index(even)+2] if lst[lst.index(even)+2]%2!=0 else  None \n        \n    while odd is  not  None  and odd not  in lst:\n        odd=lst[lst.index(odd)+1] if lst[lst.index(odd)+1]%2!=0 else lst[lst.index(odd)+2] if lst[lst.index(odd)+2]%2==0 else  None \n        \n    return odd-even if odd is  not  None  and even is  not  None  else  None \n    \n\n"}
{"task_id": "Mbpp/596", "origin_solution": "<import_stmt>sys<def_stmt>tuple_size t<block_start><return>sys.getsizeof(t)<block_end>\n", "solution": "\nimport sys\ndef tuple_size (t):\n    return sys.getsizeof(t)\n    \n\n"}
{"task_id": "Mbpp/597", "origin_solution": "<def_stmt>find_kth arr1 arr2 k<block_start>i,j=0 0<while_stmt><true><block_start><if_stmt>i<eq>len(arr1)<block_start><return>arr2[j+k-1]<block_end><if_stmt>j<eq>len(arr2)<block_start><return>arr1[i+k-1]<block_end><if_stmt>k<eq>1<block_start><return>min(arr1[i] arr2[j])<block_end>mid1=(i+k)<floordiv>2-1<line_sep>mid2=(j+k)<floordiv>2-1<if_stmt>arr1[mid1]<le>arr2[mid2]<block_start>k<augsub>(mid1-i+1)<line_sep>i=mid1+1<block_end><else_stmt><block_start>k<augsub>(mid2-j+1)<line_sep>j=mid2+1<block_end><block_end><block_end>\n", "solution": "\ndef find_kth (arr1, arr2, k):\n    i,j=0, 0\n    while  True :\n        if i==len(arr1):\n            return arr2[j+k-1]\n            \n        if j==len(arr2):\n            return arr1[i+k-1]\n            \n        if k==1:\n            return min(arr1[i], arr2[j])\n            \n        mid1=(i+k)//2-1\n        mid2=(j+k)//2-1\n        if arr1[mid1]<=arr2[mid2]:\n            k-=(mid1-i+1)\n            i=mid1+1\n            \n        \n        else :\n            k-=(mid2-j+1)\n            j=mid2+1\n            \n    \n\n\n"}
{"task_id": "Mbpp/598", "origin_solution": "<def_stmt>armstrong_number num<block_start>order=len(str(num))<line_sep>sum=0<line_sep>temp=num<while_stmt>temp<g>0<block_start>digit=temp%10<line_sep>sum<augadd>digit<power>order<line_sep>temp<augfloordiv>10<block_end><return>num<eq>sum<block_end>\n", "solution": "\ndef armstrong_number (num):\n    order=len(str(num))\n    sum=0\n    temp=num\n    while temp>0:\n        digit=temp%10\n        sum+=digit**order\n        temp//=10\n        \n    return num==sum\n    \n\n"}
{"task_id": "Mbpp/599", "origin_solution": "<def_stmt>sum_average n<block_start>total=sum(range(1 n+1))<line_sep>average=total/n<line_sep><return>total average<block_end>\n", "solution": "\ndef sum_average (n):\n    total=sum(range(1, n+1))\n    average=total/n\n    return total, average\n    \n\n"}
{"task_id": "Mbpp/600", "origin_solution": "<def_stmt>is_Even n<block_start><return>n%2<eq>0<block_end>\n", "solution": "\ndef is_Even (n):\n    return n%2==0\n    \n\n"}
{"task_id": "Mbpp/602", "origin_solution": "<def_stmt>first_repeated_char s<block_start>seen=set()<for_stmt>char s<block_start><if_stmt>char<in>seen<block_start><return>char<block_end>seen.add(char)<block_end><return><none><block_end>\n", "solution": "\ndef first_repeated_char (s):\n    seen=set()\n    for char in s:\n        if char in seen:\n            return char\n            \n        seen.add(char)\n        \n    return  None \n    \n\n"}
{"task_id": "Mbpp/603", "origin_solution": "<def_stmt>get_ludic n<block_start>ludic_numbers=[]<for_stmt>i range(1 n+1)<block_start><if_stmt>is_lucasian(i)<block_start>ludic_numbers.append(i)<block_end><block_end><return>ludic_numbers<block_end><def_stmt>is_lucasian n<block_start><if_stmt>n<l>11<block_start><return><false><block_end><if_stmt>n<eq>11<block_start><return><true><block_end>a,b=1 2<for_stmt>_ range(3 n+1)<block_start>a,b=b a+b<if_stmt>b<eq>n<or>a<eq>n<block_start><return><true><block_end><if_stmt>b<g>n<block_start><return><false><block_end><block_end><return><false><block_end>\n", "solution": "\ndef get_ludic (n):\n    ludic_numbers=[]\n    for i in range(1, n+1):\n        if is_lucasian(i):\n            ludic_numbers.append(i)\n            \n    \n    return ludic_numbers\n    \ndef is_lucasian (n):\n    if n<11:\n        return  False \n        \n    if n==11:\n        return  True \n        \n    a,b=1, 2\n    for _ in range(3, n+1):\n        a,b=b, a+b\n        if b==n or a==n:\n            return  True \n            \n        if b>n:\n            return  False \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/604", "origin_solution": "<def_stmt>reverse_words s<block_start><return>' '.join(s.split()[::-1])<block_end>\n", "solution": "\ndef reverse_words (s):\n    return ' '.join(s.split()[::-1])\n    \n\n"}
{"task_id": "Mbpp/605", "origin_solution": "<def_stmt>prime_num n<block_start><if_stmt>n<le>1<block_start><return><false><block_end><if_stmt>n<eq>2<block_start><return><true><block_end><if_stmt>n%2<eq>0<block_start><return><false><block_end>i=3<while_stmt>i<times>i<le>n<block_start><if_stmt>n%i<eq>0<block_start><return><false><block_end>i<augadd>2<block_end><return><true><block_end>\n", "solution": "\ndef prime_num (n):\n    if n<=1:\n        return  False \n        \n    if n==2:\n        return  True \n        \n    if n%2==0:\n        return  False \n        \n    i=3\n    while i*i<=n:\n        if n%i==0:\n            return  False \n            \n        i+=2\n        \n    return  True \n    \n\n"}
{"task_id": "Mbpp/606", "origin_solution": "<import_stmt>math<def_stmt>radian_degree degrees<block_start><return>degrees<times>(math.pi/180)<block_end>\n", "solution": "\nimport math\ndef radian_degree (degrees):\n    return degrees*(math.pi/180)\n    \n\n"}
{"task_id": "Mbpp/607", "origin_solution": "<import_stmt>re<def_stmt>find_literals text pattern<block_start>match=re.search(pattern text)<if_stmt>match<block_start><return>match.group() match.start() match.end()<block_end><return><none> <none> <none><block_end>\n", "solution": "\nimport re\ndef find_literals (text, pattern):\n    match=re.search(pattern, text)\n    if match:\n        return match.group(), match.start(), match.end()\n        \n    return  None ,  None ,  None \n    \n\n"}
{"task_id": "Mbpp/608", "origin_solution": "<def_stmt>bell_Number n<block_start>bell=[[0<for>i range(n+1)]<for>j range(n+1)]<line_sep>bell[0][0]=1<for_stmt>i range(1 n+1)<block_start>bell[i][0]=bell[i-1][i-1]<for_stmt>j range(1 i+1)<block_start>bell[i][j]=bell[i-1][j-1]+bell[i][j-1]<block_end><block_end><return>bell[n][0]<block_end>\n", "solution": "\ndef bell_Number (n):\n    bell=[[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0]=1\n    for i in range(1, n+1):\n        bell[i][0]=bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j]=bell[i-1][j-1]+bell[i][j-1]\n            \n    \n    return bell[n][0]\n    \n\n"}
{"task_id": "Mbpp/610", "origin_solution": "<def_stmt>remove_kth_element arr k<block_start><return>[arr[:k-1]+arr[k+1:]<for>k range(len(arr))<if>k<ne>k-1]<block_end>\n", "solution": "\ndef remove_kth_element (arr, k):\n    return [arr[:k-1]+arr[k+1:] for k in range(len(arr)) if k!=k-1]\n    \n\n"}
{"task_id": "Mbpp/611", "origin_solution": "<def_stmt>max_of_nth matrix n<block_start><return>max(row[n]<for>row matrix)<block_end>\n", "solution": "\ndef max_of_nth (matrix, n):\n    return max(row[n] for row in matrix)\n    \n\n"}
{"task_id": "Mbpp/612", "origin_solution": "<def_stmt>merge list_of_lists<block_start>first_elements=[sublist[0]<for>sublist list_of_lists]<line_sep>second_elements=[sublist[1]<for>sublist list_of_lists]<line_sep><return>[first_elements second_elements]<block_end>\n", "solution": "\ndef merge (list_of_lists):\n    first_elements=[sublist[0] for sublist in list_of_lists]\n    second_elements=[sublist[1] for sublist in list_of_lists]\n    return [first_elements, second_elements]\n    \n\n"}
{"task_id": "Mbpp/614", "origin_solution": "<def_stmt>cummulative_sum tuples<block_start>total=0<for_stmt>sublist tuples<block_start><for_stmt>item sublist<block_start>total<augadd>item<block_end><block_end><return>total<block_end>\n", "solution": "\ndef cummulative_sum (tuples):\n    total=0\n    for sublist in tuples:\n        for item in sublist:\n            total+=item\n            \n    \n    return total\n    \n\n"}
{"task_id": "Mbpp/615", "origin_solution": "<def_stmt>average_tuple tuples<block_start><return>[sum(t)/len(t)<for>t tuples]<block_end>\n", "solution": "\ndef average_tuple (tuples):\n    return [sum(t)/len(t) for t in tuples]\n    \n\n"}
{"task_id": "Mbpp/616", "origin_solution": "<def_stmt>tuple_modulo t1 t2<block_start><return>tuple(t1[i]%t2[i]<for>i range(len(t1)))<block_end>\n", "solution": "\ndef tuple_modulo (t1, t2):\n    return tuple(t1[i]%t2[i] for i in range(len(t1)))\n    \n\n"}
{"task_id": "Mbpp/618", "origin_solution": "<def_stmt>div_list list1 list2<block_start><return>[float(i)/float(j)<for>i,j zip(list1 list2)]<block_end>\n", "solution": "\ndef div_list (list1, list2):\n    return [float(i)/float(j) for i,j in zip(list1, list2)]\n    \n\n"}
{"task_id": "Mbpp/619", "origin_solution": "<def_stmt>move_num s<block_start>num_list=[char<for>char s<if>char.isdigit()]<line_sep>non_num_list=[char<for>char s<if><not>char.isdigit()]<line_sep>result=''.join(non_num_list+num_list)<line_sep><return>result<block_end>\n", "solution": "\ndef move_num (s):\n    num_list=[char for char in s if char.isdigit()]\n    non_num_list=[char for char in s if  not char.isdigit()]\n    result=''.join(non_num_list+num_list)\n    return result\n    \n\n"}
{"task_id": "Mbpp/620", "origin_solution": "<def_stmt>largest_subset nums<block_start>nums.sort()<line_sep>n=len(nums)<line_sep>dp=[1]<times>n<for_stmt>i range(1 n)<block_start><for_stmt>j range(i)<block_start><if_stmt>nums[i]%nums[j] ==0<block_start>dp[i]=max(dp[i] dp[j]+1)<block_end><block_end><block_end><return>max(dp)<block_end>\n", "solution": "\ndef largest_subset (nums):\n    nums.sort()\n    n=len(nums)\n    dp=[1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i]%nums[j] ==0:\n                dp[i]=max(dp[i], dp[j]+1)\n                \n        \n    \n    return max(dp)\n    \n\n"}
{"task_id": "Mbpp/622", "origin_solution": "<def_stmt>get_median nums1 nums2 n<block_start>m,n=len(nums1) len(nums2)<if_stmt>m<g>n<block_start><return>get_median(nums2 nums1 n m)<block_end>imin,imax,half_len=0 m (m+n+1)<floordiv>2<while_stmt>imin<le>imax<block_start>i=(imin+imax)<floordiv>2<line_sep>j=half_len-i<if_stmt>i<l>m<and>nums2[j-1]<g>nums1[i]<block_start>imin=i+1<block_end><elif_stmt>i<g>0<and>nums1[i-1]<g>nums2[j]<block_start>imax=i-1<block_end><else_stmt><block_start><if_stmt>i<eq>0<block_start>max_of_left=nums2[j-1]<block_end><elif_stmt>j<eq>0<block_start>max_of_left=nums1[i-1]<block_end><else_stmt><block_start>max_of_left=max(nums1[i-1] nums2[j-1])<block_end><if_stmt>(m+n)%2<eq>1<block_start><return>max_of_left<block_end><if_stmt>i<eq>m<block_start>min_of_right=nums2[j]<block_end><elif_stmt>j<eq>n<block_start>min_of_right=nums1[i]<block_end><else_stmt><block_start>min_of_right=min(nums1[i] nums2[j])<block_end><return>(max_of_left+min_of_right)/2.0<block_end><block_end><block_end>\n", "solution": "\ndef get_median (nums1, nums2, n):\n    m,n=len(nums1), len(nums2)\n    if m>n:\n        return get_median(nums2, nums1, n, m)\n        \n    imin,imax,half_len=0, m, (m+n+1)//2\n    while imin<=imax:\n        i=(imin+imax)//2\n        j=half_len-i\n        if i<m and nums2[j-1]>nums1[i]:\n            imin=i+1\n            \n        \n        elif i>0 and nums1[i-1]>nums2[j]:\n            imax=i-1\n            \n        \n        else :\n            if i==0:\n                max_of_left=nums2[j-1]\n                \n            \n            elif j==0:\n                max_of_left=nums1[i-1]\n                \n            \n            else :\n                max_of_left=max(nums1[i-1], nums2[j-1])\n                \n            if (m+n)%2==1:\n                return max_of_left\n                \n            if i==m:\n                min_of_right=nums2[j]\n                \n            \n            elif j==n:\n                min_of_right=nums1[i]\n                \n            \n            else :\n                min_of_right=min(nums1[i], nums2[j])\n                \n            return (max_of_left+min_of_right)/2.0\n            \n    \n\n\n"}
{"task_id": "Mbpp/623", "origin_solution": "<def_stmt>nth_nums nums power<block_start><return>[num<power>power<for>num nums]<block_end>\n", "solution": "\ndef nth_nums (nums, power):\n    return [num**power for num in nums]\n    \n\n"}
{"task_id": "Mbpp/624", "origin_solution": "<def_stmt>is_upper s<block_start><return>s.upper()<block_end>\n", "solution": "\ndef is_upper (s):\n    return s.upper()\n    \n\n"}
{"task_id": "Mbpp/626", "origin_solution": "<import_stmt>math<def_stmt>triangle_area radius<block_start><if_stmt>radius<l>0<block_start><return><none><block_end><return>radius<power>2<times>math.asin(radius/2)<block_end>\n", "solution": "\nimport math\ndef triangle_area (radius):\n    if radius<0:\n        return  None \n        \n    return radius**2*math.asin(radius/2)\n    \n\n"}
{"task_id": "Mbpp/628", "origin_solution": "<def_stmt>replace_spaces s<block_start><return>s.replace(' ' '%20')<block_end>\n", "solution": "\ndef replace_spaces (s):\n    return s.replace(' ', '%20')\n    \n\n"}
{"task_id": "Mbpp/629", "origin_solution": "<def_stmt>Split numbers<block_start><return>[num<for>num numbers<if>num%2<eq>0]<block_end>\n", "solution": "\ndef Split (numbers):\n    return [num for num in numbers if num%2==0]\n    \n\n"}
{"task_id": "Mbpp/630", "origin_solution": "<def_stmt>get_coordinates coord<block_start>x,y=coord<line_sep><return>[[x+dx y+dy]<for>dx range(-1 2)<for>dy range(-1 2)<if>(dx dy)<ne>(0 0)]<block_end>\n", "solution": "\ndef get_coordinates (coord):\n    x,y=coord\n    return [[x+dx, y+dy] for dx in range(-1, 2) for dy in range(-1, 2) if (dx, dy)!=(0, 0)]\n    \n\n"}
{"task_id": "Mbpp/631", "origin_solution": "<def_stmt>replace_spaces input_string<block_start>output_string=\"\"<for_stmt>char input_string<block_start><if_stmt>char.isspace()<block_start>output_string<augadd>\"_\"<block_end><elif_stmt>char.isalpha()<block_start>output_string<augadd>char.upper()<if>char.islower()<else>char.lower()<block_end><else_stmt><block_start>output_string<augadd>char<block_end><block_end><return>output_string<block_end>\n", "solution": "\ndef replace_spaces (input_string):\n    output_string=\"\"\n    for char in input_string:\n        if char.isspace():\n            output_string+=\"_\"\n            \n        \n        elif char.isalpha():\n            output_string+=char.upper() if char.islower() else char.lower()\n            \n        \n        else :\n            output_string+=char\n            \n    \n    return output_string\n    \n\n"}
{"task_id": "Mbpp/632", "origin_solution": "<def_stmt>move_zero arr<block_start>non_zero=[x<for>x arr<if>x<ne>0]<line_sep>num_zeros=len(arr)-len(non_zero)<line_sep>zeros=[0]<times>num_zeros<line_sep><return>non_zero+zeros<block_end>\n", "solution": "\ndef move_zero (arr):\n    non_zero=[x for x in arr if x!=0]\n    num_zeros=len(arr)-len(non_zero)\n    zeros=[0]*num_zeros\n    return non_zero+zeros\n    \n\n"}
{"task_id": "Mbpp/633", "origin_solution": "<def_stmt>pair_xor_Sum arr n<block_start>xor_sum=0<for_stmt>i range(n)<block_start><for_stmt>j range(i+1 n)<block_start>xor_sum<augadd>arr[i]^arr[j]<block_end><block_end><return>xor_sum<block_end>\n", "solution": "\ndef pair_xor_Sum (arr, n):\n    xor_sum=0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum+=arr[i]^arr[j]\n            \n    \n    return xor_sum\n    \n\n"}
{"task_id": "Mbpp/635", "origin_solution": "<def_stmt>heap_sort arr<block_start>n=len(arr)<for_stmt>i range(n -1 -1)<block_start>heapify(arr n i)<block_end><for_stmt>i range(n-1 0 -1)<block_start>arr[i],arr[0]=arr[0] arr[i]<line_sep>heapify(arr i 0)<block_end><return>arr<block_end><def_stmt>heapify arr n i<block_start>largest=i<line_sep>l=2<times>i+1<line_sep>r=2<times>i+2<if_stmt>l<l>n<and>arr[i]<l>arr[l]<block_start>largest=l<block_end><if_stmt>r<l>n<and>arr[largest]<l>arr[r]<block_start>largest=r<block_end><if_stmt>largest<ne>i<block_start>arr[i],arr[largest]=arr[largest] arr[i]<line_sep>heapify(arr n largest)<block_end><block_end>\n", "solution": "\ndef heap_sort (arr):\n    n=len(arr)\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n        \n    for i in range(n-1, 0, -1):\n        arr[i],arr[0]=arr[0], arr[i]\n        heapify(arr, i, 0)\n        \n    return arr\n    \ndef heapify (arr, n, i):\n    largest=i\n    l=2*i+1\n    r=2*i+2\n    if l<n and arr[i]<arr[l]:\n        largest=l\n        \n    if r<n and arr[largest]<arr[r]:\n        largest=r\n        \n    if largest!=i:\n        arr[i],arr[largest]=arr[largest], arr[i]\n        heapify(arr, n, largest)\n        \n\n\n"}
{"task_id": "Mbpp/637", "origin_solution": "<def_stmt>noprofit_noloss profit loss<block_start><return>profit<eq>0<and>loss<eq>0<block_end>\n", "solution": "\ndef noprofit_noloss (profit, loss):\n    return profit==0 and loss==0\n    \n\n"}
{"task_id": "Mbpp/638", "origin_solution": "<def_stmt>wind_chill velocity temp<block_start>\"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \n    Args:\n    velocity: Wind velocity in km/h.\n    temp: Temperature in celsius.\n    \n    Returns:\n    Wind chill index rounded to the next integer.\n    \"\"\"<line_sep>wchil=13.12+0.6215<times>temp-11.37<times>velocity+0.3965<times>temp<times>velocity+0.03965<times>temp<times>temp-0.1129<times>temp<times>temp<times>velocity-0.00075<times>temp<times>temp<times>temp+0.0545<times>temp<times>temp<times>temp<times>velocity+0.0075<times>temp<times>temp<times>temp<times>temp-0.0005<times>temp<times>temp<times>temp<times>temp<times>velocity-0.0536<times>temp<times>temp<times>temp<times>temp<times>temp-0.0023<times>temp<times>temp<times>temp<times>temp<times>temp<times>velocity+0.0005<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>velocity+0.0536<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>velocity+0.125<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>velocity+0.065<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>velocity+0.025<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>velocity+0.008<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>velocity+0.001<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>velocity+0.0001<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>velocity+0.00001<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>temp<times>velocity+0.000001<times>temp<times>temp", "solution": "\ndef wind_chill velocity temp\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \n    Args:\n    velocity: Wind velocity in km/h.\n    temp: Temperature in celsius.\n    \n    Returns:\n    Wind chill index rounded to the next integer.\n    \"\"\"\n    wchil=13.12+0.6215*temp-11.37*velocity+0.3965*temp*velocity+0.03965*temp*temp-0.1129*temp*temp*velocity-0.00075*temp*temp*temp+0.0545*temp*temp*temp*velocity+0.0075*temp*temp*temp*temp-0.0005*temp*temp*temp*temp*velocity-0.0536*temp*temp*temp*temp*temp-0.0023*temp*temp*temp*temp*temp*velocity+0.0005*temp*temp*temp*temp*temp*temp*velocity+0.0536*temp*temp*temp*temp*temp*temp*temp*velocity+0.125*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.065*temp*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.025*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.008*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.001*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.0001*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.00001*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.000001*temp*temp"}
{"task_id": "Mbpp/639", "origin_solution": "<def_stmt>sample_nam names<block_start>total=0<for_stmt>name names<block_start><if_stmt>name[0].isupper()<block_start>total<augadd>len(name)<block_end><block_end><return>total<block_end>\n", "solution": "\ndef sample_nam (names):\n    total=0\n    for name in names:\n        if name[0].isupper():\n            total+=len(name)\n            \n    \n    return total\n    \n\n"}
{"task_id": "Mbpp/641", "origin_solution": "<def_stmt>is_nonagonal n<block_start><return>n<times>(7<times>n-5)<floordiv>2<block_end>\n", "solution": "\ndef is_nonagonal (n):\n    return n*(7*n-5)//2\n    \n\n"}
{"task_id": "Mbpp/643", "origin_solution": "<def_stmt>text_match_wordz_middle text<block_start>words=text.split()<for_stmt>word words<block_start><if_stmt>word[1:-1].lower()<eq>'z'<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef text_match_wordz_middle (text):\n    words=text.split()\n    for word in words:\n        if word[1:-1].lower()=='z':\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/644", "origin_solution": "<def_stmt>reverse_Array_Upto_K arr k<block_start>\"\"\"\n    Reverses the elements of the array 'arr' up to the given position 'k'.\n    \n    Parameters:\n    arr (list): The input list to be reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The reversed list.\n    \"\"\"<if_stmt>k<l>0<or>k<ge>len(arr)<block_start><return>arr<block_end><return>arr[:k+1][::-1]+arr[k+1:]<block_end>\n", "solution": "\ndef reverse_Array_Upto_K (arr, k):\n    \"\"\"\n    Reverses the elements of the array 'arr' up to the given position 'k'.\n    \n    Parameters:\n    arr (list): The input list to be reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The reversed list.\n    \"\"\"\n    if k<0 or k>=len(arr):\n        return arr\n        \n    return arr[:k+1][::-1]+arr[k+1:]\n    \n\n"}
{"task_id": "Mbpp/720", "origin_solution": "<def_stmt>add_dict_to_tuple t d<block_start><return>t+(d )<block_end>\n", "solution": "\ndef add_dict_to_tuple (t, d):\n    return t+(d, )\n    \n\n"}
{"task_id": "Mbpp/721", "origin_solution": "<def_stmt>maxAverageOfPath grid<block_start>N=len(grid)<line_sep>dp=[[0]<times>N<for>_ range(N)]<line_sep>dp[0][0]=grid[0][0]<for_stmt>i range(1 N)<block_start>dp[0][i]=dp[0][i-1]+grid[0][i]<line_sep>dp[i][0]=dp[i-1][0]+grid[i][0]<block_end><for_stmt>i range(1 N)<block_start><for_stmt>j range(1 N)<block_start>dp[i][j]=min(dp[i-1][j] dp[i][j-1])+grid[i][j]<block_end><block_end>max_avg=0<for_stmt>i range(N)<block_start><for_stmt>j range(N)<block_start><for_stmt>k range(i+1 N)<block_start><for_stmt>l range(j+1 N)<block_start><if_stmt>i<eq>0<and>j<eq>0<block_start><continue><block_end><elif_stmt>i<eq>0<block_start>dp[i][l]=dp[i][l-1]+grid[i][l]<line_sep>dp[l][i]=dp[l-1][i]+grid[l][i]<block_end><elif_stmt>j<eq>0<block_start>dp[i][l]=dp[i-1][l]+grid[i][l]<line_sep>dp[l][j]=dp[l-1][j]+grid[l][j]<block_end><else_stmt><block_start>dp[i][l]=dp[i-1][l]+grid[i][l]<line_sep>dp[l][j]=dp[l][j-1]+grid[l][j]<block_end>avg=(dp[i][l]+dp[l][j])/2<if_stmt>avg<g>max_avg<block_start>max_avg=avg<block_end><block_end><block_end><block_end><block_end><return>max_avg<block_end>\n", "solution": "\ndef maxAverageOfPath (grid):\n    N=len(grid)\n    dp=[[0]*N for _ in range(N)]\n    dp[0][0]=grid[0][0]\n    for i in range(1, N):\n        dp[0][i]=dp[0][i-1]+grid[0][i]\n        dp[i][0]=dp[i-1][0]+grid[i][0]\n        \n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j]=min(dp[i-1][j], dp[i][j-1])+grid[i][j]\n            \n    \n    max_avg=0\n    for i in range(N):\n        for j in range(N):\n            for k in range(i+1, N):\n                for l in range(j+1, N):\n                    if i==0 and j==0:\n                        continue \n                        \n                    \n                    elif i==0:\n                        dp[i][l]=dp[i][l-1]+grid[i][l]\n                        dp[l][i]=dp[l-1][i]+grid[l][i]\n                        \n                    \n                    elif j==0:\n                        dp[i][l]=dp[i-1][l]+grid[i][l]\n                        dp[l][j]=dp[l-1][j]+grid[l][j]\n                        \n                    \n                    else :\n                        dp[i][l]=dp[i-1][l]+grid[i][l]\n                        dp[l][j]=dp[l][j-1]+grid[l][j]\n                        \n                    avg=(dp[i][l]+dp[l][j])/2\n                    if avg>max_avg:\n                        max_avg=avg\n                        \n                \n            \n        \n    \n    return max_avg\n    \n\n"}
{"task_id": "Mbpp/722", "origin_solution": "<def_stmt>filter_data student_dict min_height min_weight<block_start>filtered_students={}<for_stmt>student,(height weight) student_dict.items()<block_start><if_stmt>height<g>min_height<and>weight<g>min_weight<block_start>filtered_students[student]=(height weight)<block_end><block_end><return>filtered_students<block_end>\n", "solution": "\ndef filter_data (student_dict, min_height, min_weight):\n    filtered_students={}\n    for student,(height, weight) in student_dict.items():\n        if height>min_height and weight>min_weight:\n            filtered_students[student]=(height, weight)\n            \n    \n    return filtered_students\n    \n\n"}
{"task_id": "Mbpp/723", "origin_solution": "<def_stmt>count_same_pair list1 list2<block_start>count=0<for_stmt>i range(len(list1))<block_start><if_stmt>list1[i]<eq>list2[i]<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_same_pair (list1, list2):\n    count=0\n    for i in range(len(list1)):\n        if list1[i]==list2[i]:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/724", "origin_solution": "<def_stmt>power_base_sum base power<block_start>total=0<for_stmt>i range(power)<block_start>total<augadd>base%10<line_sep>base<augfloordiv>10<block_end><return>total<block_end>\n", "solution": "\ndef power_base_sum (base, power):\n    total=0\n    for i in range(power):\n        total+=base%10\n        base//=10\n        \n    return total\n    \n\n"}
{"task_id": "Mbpp/725", "origin_solution": "<import_stmt>re<def_stmt>extract_quotation text<block_start>pattern=r'\"(.*?)\"'<line_sep>matches=re.findall(pattern text)<line_sep><return>matches<block_end>\n", "solution": "\nimport re\ndef extract_quotation (text):\n    pattern=r'\"(.*?)\"'\n    matches=re.findall(pattern, text)\n    return matches\n    \n\n"}
{"task_id": "Mbpp/726", "origin_solution": "<def_stmt>multiply_elements t<block_start><if_stmt>len(t)<eq>1<block_start><return>()<block_end>result=tuple(t[i]<times>t[i+1]<for>i range(len(t)-1))<line_sep><return>result<block_end>\n", "solution": "\ndef multiply_elements (t):\n    if len(t)==1:\n        return ()\n        \n    result=tuple(t[i]*t[i+1] for i in range(len(t)-1))\n    return result\n    \n\n"}
{"task_id": "Mbpp/728", "origin_solution": "<def_stmt>sum_list list1 list2<block_start><return>[x+y<for>x,y zip(list1 list2)]<block_end>\n", "solution": "\ndef sum_list (list1, list2):\n    return [x+y for x,y in zip(list1, list2)]\n    \n\n"}
{"task_id": "Mbpp/730", "origin_solution": "<def_stmt>consecutive_duplicates lst<block_start><if_stmt><not>lst<block_start><return>[]<block_end>result=[lst[0]]<for_stmt>i range(1 len(lst))<block_start><if_stmt>lst[i]<ne>lst[i-1]<block_start>result.append(lst[i])<block_end><block_end><return>result<block_end>\n", "solution": "\ndef consecutive_duplicates (lst):\n    if  not lst:\n        return []\n        \n    result=[lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i]!=lst[i-1]:\n            result.append(lst[i])\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/731", "origin_solution": "<import_stmt>math<def_stmt>lateralsurface_cone r h<block_start>lateral_surface_area=math.pi<times>(r+h)<times>math.sqrt(r<power>2+h<power>2)<line_sep><return>lateral_surface_area<block_end>\n", "solution": "\nimport math\ndef lateralsurface_cone (r, h):\n    lateral_surface_area=math.pi*(r+h)*math.sqrt(r**2+h**2)\n    return lateral_surface_area\n    \n\n"}
{"task_id": "Mbpp/732", "origin_solution": "<def_stmt>replace_specialchar text<block_start><return>text.replace(' ' ':').replace(',' ':').replace('.' ':')<block_end>\n", "solution": "\ndef replace_specialchar (text):\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')\n    \n\n"}
{"task_id": "Mbpp/733", "origin_solution": "<def_stmt>find_first_occurrence arr target<block_start>left,right=0 len(arr)-1<line_sep>result=-1<while_stmt>left<le>right<block_start>mid=(left+right)<floordiv>2<if_stmt>arr[mid]<eq>target<block_start>result=mid<line_sep>right=mid-1<block_end><elif_stmt>arr[mid]<l>target<block_start>left=mid+1<block_end><else_stmt><block_start>right=mid-1<block_end><block_end><return>result<block_end>\n", "solution": "\ndef find_first_occurrence (arr, target):\n    left,right=0, len(arr)-1\n    result=-1\n    while left<=right:\n        mid=(left+right)//2\n        if arr[mid]==target:\n            result=mid\n            right=mid-1\n            \n        \n        elif arr[mid]<target:\n            left=mid+1\n            \n        \n        else :\n            right=mid-1\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/734", "origin_solution": "<def_stmt>sum_Of_Subarray_Prod arr<block_start>total=0<for_stmt>i range(len(arr))<block_start>product=1<for_stmt>j range(i len(arr))<block_start>product<augmul>arr[j]<line_sep>total<augadd>product<block_end><block_end><return>total<block_end>\n", "solution": "\ndef sum_Of_Subarray_Prod (arr):\n    total=0\n    for i in range(len(arr)):\n        product=1\n        for j in range(i, len(arr)):\n            product*=arr[j]\n            total+=product\n            \n    \n    return total\n    \n\n"}
{"task_id": "Mbpp/735", "origin_solution": "<def_stmt>toggle_middle_bits n<block_start>binary=bin(n)[2:]<if_stmt>len(binary)<le>2<block_start><return>n<block_end>binary=binary[0]+''.join('1'<if>bit<eq>'0'<else>'0'<for>bit binary[1:-1])+binary[-1]<line_sep><return>int(binary 2)<block_end>\n", "solution": "\ndef toggle_middle_bits (n):\n    binary=bin(n)[2:]\n    if len(binary)<=2:\n        return n\n        \n    binary=binary[0]+''.join('1' if bit=='0' else '0' for bit in binary[1:-1])+binary[-1]\n    return int(binary, 2)\n    \n\n"}
{"task_id": "Mbpp/736", "origin_solution": "<def_stmt>left_insertion sorted_list value<block_start>low=0<line_sep>high=len(sorted_list)<while_stmt>low<l>high<block_start>mid=(low+high)<floordiv>2<if_stmt>sorted_list[mid]<l>value<block_start>low=mid+1<block_end><else_stmt><block_start>high=mid<block_end><block_end><return>low<block_end>\n", "solution": "\ndef left_insertion (sorted_list, value):\n    low=0\n    high=len(sorted_list)\n    while low<high:\n        mid=(low+high)//2\n        if sorted_list[mid]<value:\n            low=mid+1\n            \n        \n        else :\n            high=mid\n            \n    \n    return low\n    \n\n"}
{"task_id": "Mbpp/737", "origin_solution": "<import_stmt>re<def_stmt>check_str s<block_start>pattern=r\"^[aeiouAEIOU]\"<if_stmt>re.match(pattern s)<block_start><return><true><block_end><else_stmt><block_start><return><false><block_end><block_end>\n", "solution": "\nimport re\ndef check_str (s):\n    pattern=r\"^[aeiouAEIOU]\"\n    if re.match(pattern, s):\n        return  True \n        \n    \n    else :\n        return  False \n        \n\n\n"}
{"task_id": "Mbpp/739", "origin_solution": "<def_stmt>find_Index n<block_start><def_stmt>triangular_number k<block_start><return>k<times>(k+1)<floordiv>2<block_end>start=1<while_stmt>len(str(triangular_number(start)))<l>n<block_start>start<augadd>1<block_end>end=start+1<while_stmt>len(str(triangular_number(end)))<l>n+1<block_start>end<augadd>1<block_end><while_stmt>triangular_number(start)<ge>triangular_number(end)<block_start>start<augadd>1<block_end><return>start+triangular_number(start-1)<floordiv>2-1<block_end>\n", "solution": "\ndef find_Index (n):\n    def triangular_number (k):\n        return k*(k+1)//2\n        \n    start=1\n    while len(str(triangular_number(start)))<n:\n        start+=1\n        \n    end=start+1\n    while len(str(triangular_number(end)))<n+1:\n        end+=1\n        \n    while triangular_number(start)>=triangular_number(end):\n        start+=1\n        \n    return start+triangular_number(start-1)//2-1\n    \n\n"}
{"task_id": "Mbpp/740", "origin_solution": "<def_stmt>tuple_to_dict t<block_start><return>{t[i]:t[i+1]<for>i range(0 len(t)-1 2)}<block_end>\n", "solution": "\ndef tuple_to_dict (t):\n    return {t[i]:t[i+1] for i in range(0, len(t)-1, 2)}\n    \n\n"}
{"task_id": "Mbpp/741", "origin_solution": "<def_stmt>all_Characters_Same s<block_start><return>len(set(s))<eq>1<block_end>\n", "solution": "\ndef all_Characters_Same (s):\n    return len(set(s))==1\n    \n\n"}
{"task_id": "Mbpp/742", "origin_solution": "<import_stmt>math<def_stmt>area_tetrahedron a<block_start>\"\"\"\n    Calculate the area of a tetrahedron.\n    \n    Parameters:\n    a (float): The length of the edge of the tetrahedron's base.\n    \n    Returns:\n    float: The area of the tetrahedron.\n    \"\"\"<line_sep>s=(a<times>a<times>a)/(4.0<times>math.sqrt(2))<line_sep>area=math.sqrt(s<times>(s-a)<times>(s-a)<times>(s-a))/4.0<line_sep><return>area<block_end>\n", "solution": "\nimport math\ndef area_tetrahedron (a):\n    \"\"\"\n    Calculate the area of a tetrahedron.\n    \n    Parameters:\n    a (float): The length of the edge of the tetrahedron's base.\n    \n    Returns:\n    float: The area of the tetrahedron.\n    \"\"\"\n    s=(a*a*a)/(4.0*math.sqrt(2))\n    area=math.sqrt(s*(s-a)*(s-a)*(s-a))/4.0\n    return area\n    \n\n"}
{"task_id": "Mbpp/743", "origin_solution": "<def_stmt>rotate_right lst k<block_start>k=k%len(lst)<line_sep><return>lst[-k:]+lst[:-k]<block_end>\n", "solution": "\ndef rotate_right (lst, k):\n    k=k%len(lst)\n    return lst[-k:]+lst[:-k]\n    \n\n"}
{"task_id": "Mbpp/744", "origin_solution": "<def_stmt>check_none test_tuple<block_start><for_stmt>i test_tuple<block_start><if_stmt>i<is><none><block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef check_none (test_tuple):\n    for i in test_tuple:\n        if i is  None :\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/745", "origin_solution": "<def_stmt>divisible_by_digits startnum ti endnum<block_start>result=[]<for_stmt>num range(startnum ti+1)<block_start><if_stmt>all(num%i<eq>0<for>i range(10)<if>num<floordiv>10<power>i<ne>0)<block_start>result.append(num)<block_end><block_end><return>result<block_end>\n", "solution": "\ndef divisible_by_digits (startnum, ti, endnum):\n    result=[]\n    for num in range(startnum, ti+1):\n        if all(num%i==0 for i in range(10) if num//10**i!=0):\n            result.append(num)\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/748", "origin_solution": "<def_stmt>capital_words_spaces s<block_start>words=s.split()<for_stmt>i range(len(words))<block_start><if_stmt>words[i][0].isupper()<block_start>words[i]=words[i]+' '<block_end><block_end><return>''.join(words)<block_end>\n", "solution": "\ndef capital_words_spaces (s):\n    words=s.split()\n    for i in range(len(words)):\n        if words[i][0].isupper():\n            words[i]=words[i]+' '\n            \n    \n    return ''.join(words)\n    \n\n"}
{"task_id": "Mbpp/749", "origin_solution": "<def_stmt>sort_numeric_strings input_list<block_start><return>sorted(input_list key=<lambda>x:int(x))<block_end>\n", "solution": "\ndef sort_numeric_strings (input_list):\n    return sorted(input_list, key=lambda x:int(x))\n    \n\n"}
{"task_id": "Mbpp/750", "origin_solution": "<def_stmt>add_tuple lst tpl<block_start><return>lst+tpl<block_end>\n", "solution": "\ndef add_tuple (lst, tpl):\n    return lst+tpl\n    \n\n"}
{"task_id": "Mbpp/751", "origin_solution": "<def_stmt>check_min_heap arr<block_start>n=len(arr)<for_stmt>i range(n)<block_start>left_child=2<times>i+1<line_sep>right_child=2<times>i+2<if_stmt>left_child<l>n<and>arr[i]<g>arr[left_child]<block_start><return><false><block_end><if_stmt>right_child<l>n<and>arr[i]<g>arr[right_child]<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef check_min_heap (arr):\n    n=len(arr)\n    for i in range(n):\n        left_child=2*i+1\n        right_child=2*i+2\n        if left_child<n and arr[i]>arr[left_child]:\n            return  False \n            \n        if right_child<n and arr[i]>arr[right_child]:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/752", "origin_solution": "<def_stmt>jacobsthal_num n:int<arrow>int<block_start><if_stmt>n<eq>0<block_start><return>0<block_end><elif_stmt>n<eq>1<block_start><return>1<block_end><else_stmt><block_start><return>2<times>jacobsthal_num(n-1)+jacobsthal_num(n-2)<block_end><block_end>\n", "solution": "\ndef jacobsthal_num (n:int)->int:\n    if n==0:\n        return 0\n        \n    \n    elif n==1:\n        return 1\n        \n    \n    else :\n        return 2*jacobsthal_num(n-1)+jacobsthal_num(n-2)\n        \n\n\n"}
{"task_id": "Mbpp/753", "origin_solution": "<def_stmt>min_k test_cases k<block_start>sorted_list=sorted(test_cases key=<lambda>x:x[1])<line_sep><return>sorted_list[:k]<block_end>\n", "solution": "\ndef min_k (test_cases, k):\n    sorted_list=sorted(test_cases, key=lambda x:x[1])\n    return sorted_list[:k]\n    \n\n"}
{"task_id": "Mbpp/754", "origin_solution": "<def_stmt>extract_index_list l1 l2 l3<block_start>common_elements=[]<for_stmt>i range(len(l1))<block_start><if_stmt>l1[i]<eq>l2[i]<eq>l3[i]<block_start>common_elements.append(l1[i])<block_end><block_end><return>common_elements<block_end>\n", "solution": "\ndef extract_index_list (l1, l2, l3):\n    common_elements=[]\n    for i in range(len(l1)):\n        if l1[i]==l2[i]==l3[i]:\n            common_elements.append(l1[i])\n            \n    \n    return common_elements\n    \n\n"}
{"task_id": "Mbpp/755", "origin_solution": "<def_stmt>second_smallest numbers<block_start>unique_numbers=list(set(numbers))<if_stmt>len(unique_numbers)<l>2<block_start><return><none><block_end>unique_numbers.sort()<line_sep><return>unique_numbers[1]<block_end>\n", "solution": "\ndef second_smallest (numbers):\n    unique_numbers=list(set(numbers))\n    if len(unique_numbers)<2:\n        return  None \n        \n    unique_numbers.sort()\n    return unique_numbers[1]\n    \n\n"}
{"task_id": "Mbpp/757", "origin_solution": "<def_stmt>count_reverse_pairs str_list<block_start>reverse_pairs=0<for_stmt>i range(len(str_list))<block_start><for_stmt>j range(i+1 len(str_list))<block_start><if_stmt>str_list[i]<eq>str_list[j][::-1]<block_start>reverse_pairs<augadd>1<block_end><block_end><block_end><return>reverse_pairs<block_end>\n", "solution": "\ndef count_reverse_pairs (str_list):\n    reverse_pairs=0\n    for i in range(len(str_list)):\n        for j in range(i+1, len(str_list)):\n            if str_list[i]==str_list[j][::-1]:\n                reverse_pairs+=1\n                \n        \n    \n    return reverse_pairs\n    \n\n"}
{"task_id": "Mbpp/758", "origin_solution": "<def_stmt>unique_sublists input_list<block_start>output_dict={}<for_stmt>sublist input_list<block_start>t=tuple(sublist)<if_stmt>t<in>output_dict<block_start>output_dict[t]<augadd>1<block_end><else_stmt><block_start>output_dict[t]=1<block_end><block_end><return>output_dict<block_end>\n", "solution": "\ndef unique_sublists (input_list):\n    output_dict={}\n    for sublist in input_list:\n        t=tuple(sublist)\n        if t in output_dict:\n            output_dict[t]+=1\n            \n        \n        else :\n            output_dict[t]=1\n            \n    \n    return output_dict\n    \n\n"}
{"task_id": "Mbpp/759", "origin_solution": "<def_stmt>is_decimal s<block_start><try_stmt><block_start>float(s)<if_stmt>'.'<in>s<block_start>fractional_part=s.split('.')[1]<if_stmt>fractional_part.count('.')<g>1<block_start><return><false><block_end><if_stmt>int(fractional_part)<ne>fractional_part<block_start><return><false><block_end><block_end><return><true><block_end><except_stmt>ValueError<block_start><return><false><block_end><block_end>\n", "solution": "\ndef is_decimal (s):\n    try:\n        float(s)\n        if '.' in s:\n            fractional_part=s.split('.')[1]\n            if fractional_part.count('.')>1:\n                return  False \n                \n            if int(fractional_part)!=fractional_part:\n                return  False \n                \n        \n        return  True \n        \n    \n    except ValueError:\n        return  False \n        \n\n\n"}
{"task_id": "Mbpp/760", "origin_solution": "<def_stmt>unique_Element numbers<block_start><return>len(set(numbers))<eq>1<block_end>\n", "solution": "\ndef unique_Element (numbers):\n    return len(set(numbers))==1\n    \n\n"}
{"task_id": "Mbpp/762", "origin_solution": "<def_stmt>check_monthnumber_number month_number<block_start>months_with_30_days=[1 3 5 7 8 10 12]<if_stmt>month_number<in>months_with_30_days<block_start><return><true><block_end><else_stmt><block_start><return><false><block_end><block_end>\n", "solution": "\ndef check_monthnumber_number (month_number):\n    months_with_30_days=[1, 3, 5, 7, 8, 10, 12]\n    if month_number in months_with_30_days:\n        return  True \n        \n    \n    else :\n        return  False \n        \n\n\n"}
{"task_id": "Mbpp/763", "origin_solution": "<def_stmt>find_min_diff arr target<block_start>arr.sort()<line_sep>min_diff=float('inf')<for_stmt>i range(len(arr)-1)<block_start>diff=arr[i+1]-arr[i]<if_stmt>diff<l>min_diff<block_start>min_diff=diff<block_end><block_end><return>min_diff<if>min_diff<le>target<else>-1<block_end>\n", "solution": "\ndef find_min_diff (arr, target):\n    arr.sort()\n    min_diff=float('inf')\n    for i in range(len(arr)-1):\n        diff=arr[i+1]-arr[i]\n        if diff<min_diff:\n            min_diff=diff\n            \n    \n    return min_diff if min_diff<=target else -1\n    \n\n"}
{"task_id": "Mbpp/764", "origin_solution": "<def_stmt>number_ctr s<block_start><return>len(s)<if>s.isdigit()<else>0<block_end>\n", "solution": "\ndef number_ctr (s):\n    return len(s) if s.isdigit() else 0\n    \n\n"}
{"task_id": "Mbpp/765", "origin_solution": "<def_stmt>is_polite n<block_start>polite_numbers=[7]<line_sep>last_polite=7<for_stmt>i range(8 n+1)<block_start><if_stmt>i&(i-1)<eq>0<block_start>polite_numbers.append(i)<line_sep>last_polite=i<block_end><block_end><return>polite_numbers[n]<block_end>\n", "solution": "\ndef is_polite (n):\n    polite_numbers=[7]\n    last_polite=7\n    for i in range(8, n+1):\n        if i&(i-1)==0:\n            polite_numbers.append(i)\n            last_polite=i\n            \n    \n    return polite_numbers[n]\n    \n\n"}
{"task_id": "Mbpp/766", "origin_solution": "<def_stmt>pair_wise lst<block_start><return>[(lst[i] lst[i+1])<for>i range(len(lst)-1)]<block_end>\n", "solution": "\ndef pair_wise (lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]\n    \n\n"}
{"task_id": "Mbpp/767", "origin_solution": "<def_stmt>get_pairs_count lst target_sum<block_start>\"\"\"\n    Count the number of pairs in the list that sum up to the target sum.\n\n    Args:\n    lst: A list of integers.\n    target_sum: The target sum for the pairs.\n\n    Returns:\n    An integer count of pairs that sum up to the target sum.\n    \"\"\"<line_sep>freq={}<for_stmt>num lst<block_start><if_stmt>num<in>freq<block_start>freq[num]<augadd>1<block_end><else_stmt><block_start>freq[num]=1<block_end><block_end>count=0<for_stmt>num lst<block_start>complement=target_sum-num<if_stmt>complement<in>freq<block_start>count<augadd>freq[complement]<if_stmt>complement<eq>num<block_start>count<augsub>1<block_end><block_end><block_end><return>count<floordiv>2<block_end>\n", "solution": "\ndef get_pairs_count (lst, target_sum):\n    \"\"\"\n    Count the number of pairs in the list that sum up to the target sum.\n\n    Args:\n    lst: A list of integers.\n    target_sum: The target sum for the pairs.\n\n    Returns:\n    An integer count of pairs that sum up to the target sum.\n    \"\"\"\n    freq={}\n    for num in lst:\n        if num in freq:\n            freq[num]+=1\n            \n        \n        else :\n            freq[num]=1\n            \n    \n    count=0\n    for num in lst:\n        complement=target_sum-num\n        if complement in freq:\n            count+=freq[complement]\n            if complement==num:\n                count-=1\n                \n        \n    \n    return count//2\n    \n\n"}
{"task_id": "Mbpp/769", "origin_solution": "<def_stmt>Diff list1 list2<block_start>result=[]<for_stmt>i range(len(list1))<block_start><if_stmt>list1[i]<not><in>list2<block_start>result.append(list1[i])<block_end><block_end><for_stmt>i range(len(list2))<block_start><if_stmt>list2[i]<not><in>list1<block_start>result.append(list2[i])<block_end><block_end><return>result<block_end>\n", "solution": "\ndef Diff (list1, list2):\n    result=[]\n    for i in range(len(list1)):\n        if list1[i] not  in list2:\n            result.append(list1[i])\n            \n    \n    for i in range(len(list2)):\n        if list2[i] not  in list1:\n            result.append(list2[i])\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/770", "origin_solution": "<def_stmt>odd_num_sum n<block_start>sum=0<for_stmt>i range(1 n+1)<block_start>sum<augadd>(i<times>2-1)<power>4<block_end><return>sum<block_end>\n", "solution": "\ndef odd_num_sum (n):\n    sum=0\n    for i in range(1, n+1):\n        sum+=(i*2-1)**4\n        \n    return sum\n    \n\n"}
{"task_id": "Mbpp/771", "origin_solution": "<def_stmt>check_expression expression<block_start>stack=[]<line_sep>mapping={\")\":\"(\" \"}\":\"{\" \"]\":\"[\"}<for_stmt>char expression<block_start><if_stmt>char<in>mapping.values()<block_start>stack.append(char)<block_end><elif_stmt>char<in>mapping.keys()<block_start><if_stmt>stack<eq>[]<or>mapping[char]<ne>stack.pop()<block_start><return><false><block_end><block_end><else_stmt><block_start><continue><block_end><block_end><return>stack<eq>[]<block_end>\n", "solution": "\ndef check_expression (expression):\n    stack=[]\n    mapping={\")\":\"(\", \"}\":\"{\", \"]\":\"[\"}\n    for char in expression:\n        if char in mapping.values():\n            stack.append(char)\n            \n        \n        elif char in mapping.keys():\n            if stack==[] or mapping[char]!=stack.pop():\n                return  False \n                \n        \n        \n        else :\n            continue \n            \n    \n    return stack==[]\n    \n\n"}
{"task_id": "Mbpp/772", "origin_solution": "<def_stmt>remove_length s k<block_start>words=s.split()<line_sep>result=[word<for>word words<if>len(word)<ne>k]<line_sep><return>' '.join(result)<block_end>\n", "solution": "\ndef remove_length (s, k):\n    words=s.split()\n    result=[word for word in words if len(word)!=k]\n    return ' '.join(result)\n    \n\n"}
{"task_id": "Mbpp/773", "origin_solution": "<def_stmt>occurance_substring string substring<block_start>start=string.find(substring)<if_stmt>start<eq>-1<block_start><return><none><block_end>end=start+len(substring)<line_sep><return>(substring start end)<block_end>\n", "solution": "\ndef occurance_substring (string, substring):\n    start=string.find(substring)\n    if start==-1:\n        return  None \n        \n    end=start+len(substring)\n    return (substring, start, end)\n    \n\n"}
{"task_id": "Mbpp/775", "origin_solution": "<def_stmt>odd_position lst<block_start><for_stmt>i range(1 len(lst) 2)<block_start><if_stmt>lst[i]%2<eq>0<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef odd_position (lst):\n    for i in range(1, len(lst), 2):\n        if lst[i]%2==0:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/777", "origin_solution": "<def_stmt>find_sum arr<block_start>unique_elements=set(arr)<line_sep>sum_of_non_repeated=sum([x<for>x unique_elements<if>arr.count(x)<eq>1])<line_sep><return>sum_of_non_repeated<block_end>\n", "solution": "\ndef find_sum (arr):\n    unique_elements=set(arr)\n    sum_of_non_repeated=sum([x for x in unique_elements if arr.count(x)==1])\n    return sum_of_non_repeated\n    \n\n"}
{"task_id": "Mbpp/778", "origin_solution": "<def_stmt>pack_consecutive_duplicates lst<block_start><if_stmt><not>lst<block_start><return>[]<block_end>result=[]<line_sep>current_group=[lst[0]]<for_stmt>element lst[1:]<block_start><if_stmt>element<eq>current_group[-1]<block_start>current_group.append(element)<block_end><else_stmt><block_start>result.append(current_group)<line_sep>current_group=[element]<block_end><block_end>result.append(current_group)<line_sep><return>result<block_end>\n", "solution": "\ndef pack_consecutive_duplicates (lst):\n    if  not lst:\n        return []\n        \n    result=[]\n    current_group=[lst[0]]\n    for element in lst[1:]:\n        if element==current_group[-1]:\n            current_group.append(element)\n            \n        \n        else :\n            result.append(current_group)\n            current_group=[element]\n            \n    \n    result.append(current_group)\n    return result\n    \n\n"}
{"task_id": "Mbpp/780", "origin_solution": "<import_from_stmt>itertools combinations<def_stmt>find_combinations tuple_list<block_start>result=[]<for_stmt>i range(2 len(tuple_list)+1)<block_start><for_stmt>subset combinations(tuple_list i)<block_start>sums=tuple(sum(subset))<line_sep>result.append(sums)<block_end><block_end><return>result<block_end>\n", "solution": "\nfrom itertools import combinations\ndef find_combinations (tuple_list):\n    result=[]\n    for i in range(2, len(tuple_list)+1):\n        for subset in combinations(tuple_list, i):\n            sums=tuple(sum(subset))\n            result.append(sums)\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/781", "origin_solution": "<def_stmt>count_divisors n<block_start>count=0<for_stmt>i range(1 n+1)<block_start><if_stmt>n%i<eq>0<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_divisors (n):\n    count=0\n    for i in range(1, n+1):\n        if n%i==0:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/782", "origin_solution": "<def_stmt>odd_length_sum arr<block_start>total=0<for_stmt>i range(0 len(arr) 2)<block_start>total<augadd>sum(arr[i:])<block_end><return>total<block_end>\n", "solution": "\ndef odd_length_sum (arr):\n    total=0\n    for i in range(0, len(arr), 2):\n        total+=sum(arr[i:])\n        \n    return total\n    \n\n"}
{"task_id": "Mbpp/784", "origin_solution": "<def_stmt>mul_even_odd lst<block_start>even_product=1<line_sep>odd_product=1<for_stmt>num lst<block_start><if_stmt>num%2<eq>0<block_start>even_product<augmul>num<block_end><else_stmt><block_start>odd_product<augmul>num<block_end><block_end><return>even_product<times>odd_product<block_end>\n", "solution": "\ndef mul_even_odd (lst):\n    even_product=1\n    odd_product=1\n    for num in lst:\n        if num%2==0:\n            even_product*=num\n            \n        \n        else :\n            odd_product*=num\n            \n    \n    return even_product*odd_product\n    \n\n"}
{"task_id": "Mbpp/785", "origin_solution": "<def_stmt>tuple_str_int s<block_start>s=s.strip(\"()\")<line_sep><return>tuple(int(x)<for>x s.split(\", \"))<block_end>\n", "solution": "\ndef tuple_str_int (s):\n    s=s.strip(\"()\")\n    return tuple(int(x) for x in s.split(\", \"))\n    \n\n"}
{"task_id": "Mbpp/786", "origin_solution": "<def_stmt>right_insertion lst value<block_start><for_stmt>i range(len(lst))<block_start><if_stmt>value<le>lst[i]<block_start><return>i<block_end><block_end><return>len(lst)<block_end>\n", "solution": "\ndef right_insertion (lst, value):\n    for i in range(len(lst)):\n        if value<=lst[i]:\n            return i\n            \n    \n    return len(lst)\n    \n\n"}
{"task_id": "Mbpp/787", "origin_solution": "<import_stmt>re<def_stmt>text_match_three text<block_start>\"\"\"\n    Matches a string that has an a followed by three 'b'.\n    \n    Args:\n    text (str): The string to be checked.\n    \n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"<line_sep>pattern=r'ab{3}'<line_sep><return>bool(re.search(pattern text))<block_end>\n", "solution": "\nimport re\ndef text_match_three (text):\n    \"\"\"\n    Matches a string that has an a followed by three 'b'.\n    \n    Args:\n    text (str): The string to be checked.\n    \n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern=r'ab{3}'\n    return bool(re.search(pattern, text))\n    \n\n"}
{"task_id": "Mbpp/788", "origin_solution": "<def_stmt>new_tuple given_string given_list<block_start><return>tuple(given_string)<block_end>\n", "solution": "\ndef new_tuple (given_string, given_list):\n    return tuple(given_string)\n    \n\n"}
{"task_id": "Mbpp/790", "origin_solution": "<def_stmt>even_position arr<block_start><for_stmt>i range(0 len(arr) 2)<block_start><if_stmt>arr[i]%2<ne>0<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef even_position (arr):\n    for i in range(0, len(arr), 2):\n        if arr[i]%2!=0:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/791", "origin_solution": "<def_stmt>remove_nested tup<block_start>result=[]<for_stmt>item tup<block_start><if_stmt>isinstance(item tuple)<block_start>result.append(remove_nested(item))<block_end><else_stmt><block_start>result.append(item)<block_end><block_end><return>tuple(result)<block_end>\n", "solution": "\ndef remove_nested (tup):\n    result=[]\n    for item in tup:\n        if isinstance(item, tuple):\n            result.append(remove_nested(item))\n            \n        \n        else :\n            result.append(item)\n            \n    \n    return tuple(result)\n    \n\n"}
{"task_id": "Mbpp/792", "origin_solution": "<def_stmt>count_list lst<block_start><return>len(lst)<block_end>\n", "solution": "\ndef count_list (lst):\n    return len(lst)\n    \n\n"}
{"task_id": "Mbpp/793", "origin_solution": "<def_stmt>last arr target<block_start>left,right=0 len(arr)-1<while_stmt>left<le>right<block_start>mid=(left+right)<floordiv>2<if_stmt>arr[mid]<le>target<block_start>left=mid+1<block_end><else_stmt><block_start>right=mid-1<block_end><block_end><return>right<if>right<ge>0<and>arr[right]<eq>target<else>-1<block_end>\n", "solution": "\ndef last (arr, target):\n    left,right=0, len(arr)-1\n    while left<=right:\n        mid=(left+right)//2\n        if arr[mid]<=target:\n            left=mid+1\n            \n        \n        else :\n            right=mid-1\n            \n    \n    return right if right>=0 and arr[right]==target else -1\n    \n\n"}
{"task_id": "Mbpp/794", "origin_solution": "<import_stmt>re<def_stmt>text_starta_endb text<block_start>\"\"\"\n    Matches a string that starts with 'a', followed by anything, and ends with 'b'.\n    \n    :param text: The input string to be matched.\n    :return: A boolean indicating whether the string matches the pattern.\n    \"\"\"<line_sep>pattern=r'^a.*b$'<line_sep><return>bool(re.match(pattern text))<block_end>\n", "solution": "\nimport re\ndef text_starta_endb (text):\n    \"\"\"\n    Matches a string that starts with 'a', followed by anything, and ends with 'b'.\n    \n    :param text: The input string to be matched.\n    :return: A boolean indicating whether the string matches the pattern.\n    \"\"\"\n    pattern=r'^a.*b$'\n    return bool(re.match(pattern, text))\n    \n\n"}
{"task_id": "Mbpp/796", "origin_solution": "<def_stmt>return_sum d<block_start><return>sum(d.values())<block_end>\n", "solution": "\ndef return_sum (d):\n    return sum(d.values())\n    \n\n"}
{"task_id": "Mbpp/797", "origin_solution": "<def_stmt>sum_in_range l r<block_start>sum=0<for_stmt>i range(l r+1)<block_start><if_stmt>i%2<ne>0<block_start>sum<augadd>i<block_end><block_end><return>sum<block_end>\n", "solution": "\ndef sum_in_range (l, r):\n    sum=0\n    for i in range(l, r+1):\n        if i%2!=0:\n            sum+=i\n            \n    \n    return sum\n    \n\n"}
{"task_id": "Mbpp/798", "origin_solution": "<def_stmt>_sum arr<block_start><return>sum(arr)<block_end>\n", "solution": "\ndef _sum (arr):\n    return sum(arr)\n    \n\n"}
{"task_id": "Mbpp/799", "origin_solution": "<def_stmt>left_rotate num d<block_start>mask=(1<lshift>32)-1<line_sep><return>((num<lshift>d)&mask)|(num<rshift>(32-d))<block_end>\n", "solution": "\ndef left_rotate (num, d):\n    mask=(1<<32)-1\n    return ((num<<d)&mask)|(num>>(32-d))\n    \n\n"}
{"task_id": "Mbpp/800", "origin_solution": "<def_stmt>remove_all_spaces s<block_start><return>s.replace(' ' '')<block_end>\n", "solution": "\ndef remove_all_spaces (s):\n    return s.replace(' ', '')\n    \n\n"}
{"task_id": "Mbpp/801", "origin_solution": "<def_stmt>test_three_equal a b c<block_start><return>max(a b c)-min(a b c)+1<if>max(a b c)<ne>min(a b c)<else>0<block_end>\n", "solution": "\ndef test_three_equal (a, b, c):\n    return max(a, b, c)-min(a, b, c)+1 if max(a, b, c)!=min(a, b, c) else 0\n    \n\n"}
{"task_id": "Mbpp/803", "origin_solution": "<def_stmt>is_perfect_square num<block_start><if_stmt>num<l>0<block_start><return><false><block_end>root=int(num<power>0.5)<line_sep><return>root<times>root<eq>num<block_end>\n", "solution": "\ndef is_perfect_square (num):\n    if num<0:\n        return  False \n        \n    root=int(num**0.5)\n    return root*root==num\n    \n\n"}
{"task_id": "Mbpp/804", "origin_solution": "<def_stmt>is_product_even nums<block_start>product=1<for_stmt>num nums<block_start><if_stmt>num%2<eq>0<block_start>product<augmul>num<block_end><block_end><return>product%2<eq>0<block_end>\n", "solution": "\ndef is_product_even (nums):\n    product=1\n    for num in nums:\n        if num%2==0:\n            product*=num\n            \n    \n    return product%2==0\n    \n\n"}
{"task_id": "Mbpp/805", "origin_solution": "<def_stmt>max_sum_list lists<block_start><return>max(lists key=sum)<block_end>\n", "solution": "\ndef max_sum_list (lists):\n    return max(lists, key=sum)\n    \n\n"}
{"task_id": "Mbpp/806", "origin_solution": "<def_stmt>max_run_uppercase s<block_start>max_run=0<line_sep>current_run=0<for_stmt>char s<block_start><if_stmt>char.isupper()<block_start>current_run<augadd>1<line_sep>max_run=max(max_run current_run)<block_end><else_stmt><block_start>current_run=0<block_end><block_end><return>max_run<block_end>\n", "solution": "\ndef max_run_uppercase (s):\n    max_run=0\n    current_run=0\n    for char in s:\n        if char.isupper():\n            current_run+=1\n            max_run=max(max_run, current_run)\n            \n        \n        else :\n            current_run=0\n            \n    \n    return max_run\n    \n\n"}
{"task_id": "Mbpp/807", "origin_solution": "<def_stmt>first_odd nums<block_start>\"\"\"\n    Find the first odd number in a given list of numbers.\n\n    Args:\n    nums (list): A list of numbers.\n\n    Returns:\n    int: The first odd number in the list. If no odd number is found, returns None.\n    \"\"\"<for_stmt>num nums<block_start><if_stmt>num%2<ne>0<block_start><return>num<block_end><block_end><return><none><block_end>\n", "solution": "\ndef first_odd (nums):\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n\n    Args:\n    nums (list): A list of numbers.\n\n    Returns:\n    int: The first odd number in the list. If no odd number is found, returns None.\n    \"\"\"\n    for num in nums:\n        if num%2!=0:\n            return num\n            \n    \n    return  None \n    \n\n"}
{"task_id": "Mbpp/808", "origin_solution": "<def_stmt>check_K tup k<block_start><return>k<in>tup<block_end>\n", "solution": "\ndef check_K (tup, k):\n    return k in tup\n    \n\n"}
{"task_id": "Mbpp/809", "origin_solution": "<def_stmt>check_smaller t1 t2<block_start><for_stmt>i range(len(t1))<block_start><if_stmt>t1[i]<ge>t2[i]<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef check_smaller (t1, t2):\n    for i in range(len(t1)):\n        if t1[i]>=t2[i]:\n            return  False \n            \n    \n    return  True \n    \n\n"}
