{"task_id": "Mbpp/2", "origin_solution": "<def_stmt>similar_elements list1 list2<block_start><return>set(list1)&set(list2)<block_end>\n", "solution": "\ndef similar_elements (list1, list2):\n    return set(list1)&set(list2)\n    \n\n"}
{"task_id": "Mbpp/3", "origin_solution": "<def_stmt>is_not_prime n<block_start><if_stmt>n<le>1<block_start><return><true><block_end><if_stmt>n<le>3<block_start><return><false><block_end><if_stmt>n%2<eq>0<or>n%3<eq>0<block_start><return><false><block_end>i=5<while_stmt>i<times>i<le>n<block_start><if_stmt>n%i<eq>0<or>n%(i+2)<eq>0<block_start><return><false><block_end>i<augadd>6<block_end><return><true><block_end>\n", "solution": "\ndef is_not_prime (n):\n    if n<=1:\n        return  True \n        \n    if n<=3:\n        return  False \n        \n    if n%2==0 or n%3==0:\n        return  False \n        \n    i=5\n    while i*i<=n:\n        if n%i==0 or n%(i+2)==0:\n            return  False \n            \n        i+=6\n        \n    return  True \n    \n\n"}
{"task_id": "Mbpp/4", "origin_solution": "<import_stmt>heapq<def_stmt>heap_queue_largest nums n<block_start>largest_nums=heapq.nlargest(n nums)<line_sep><return>largest_nums<block_end>\n", "solution": "\nimport heapq\ndef heap_queue_largest (nums, n):\n    largest_nums=heapq.nlargest(n, nums)\n    return largest_nums\n    \n\n"}
{"task_id": "Mbpp/6", "origin_solution": "<def_stmt>differ_At_One_Bit_Pos a b<block_start>xor_result=a^b<line_sep><return>xor_result&0x01<eq>1<block_end>\n", "solution": "\ndef differ_At_One_Bit_Pos (a, b):\n    xor_result=a^b\n    return xor_result&0x01==1\n    \n\n"}
{"task_id": "Mbpp/7", "origin_solution": "<def_stmt>find_char_long sentence<block_start>words=sentence.split()<line_sep><return>[word<for>word words<if>len(word)<ge>4]<block_end>\n", "solution": "\ndef find_char_long (sentence):\n    words=sentence.split()\n    return [word for word in words if len(word)>=4]\n    \n\n"}
{"task_id": "Mbpp/8", "origin_solution": "<def_stmt>square_nums nums<block_start><return>[num<power>2<for>num nums]<block_end>\n", "solution": "\ndef square_nums (nums):\n    return [num**2 for num in nums]\n    \n\n"}
{"task_id": "Mbpp/9", "origin_solution": "<def_stmt>find_Rotations s<block_start>n=len(s)<for_stmt>i range(1 n+1)<block_start>rotated=s[i:]+s[:i]<if_stmt>rotated<eq>s<block_start><return>i<block_end><block_end><return>n<block_end>\n", "solution": "\ndef find_Rotations (s):\n    n=len(s)\n    for i in range(1, n+1):\n        rotated=s[i:]+s[:i]\n        if rotated==s:\n            return i\n            \n    \n    return n\n    \n\n"}
{"task_id": "Mbpp/11", "origin_solution": "<def_stmt>remove_Occ str1 char<block_start>str_len=len(str1)<line_sep>index1=str1.find(char)<line_sep>index2=str1.rfind(char)<if_stmt>index1<eq>-1<or>index2<eq>-1<block_start><return>str1<block_end><if_stmt>index1<eq>index2<block_start><return>str1[index1+1:]<block_end><return>str1[:index1]+str1[index2+1:]<block_end>\n", "solution": "\ndef remove_Occ (str1, char):\n    str_len=len(str1)\n    index1=str1.find(char)\n    index2=str1.rfind(char)\n    if index1==-1 or index2==-1:\n        return str1\n        \n    if index1==index2:\n        return str1[index1+1:]\n        \n    return str1[:index1]+str1[index2+1:]\n    \n\n"}
{"task_id": "Mbpp/12", "origin_solution": "<def_stmt>sort_matrix matrix<block_start>row_sums=[sum(row)<for>row matrix]<line_sep>sorted_indices=sorted(range(len(matrix)) key=<lambda>i:row_sums[i])<line_sep>sorted_matrix=[matrix[i]<for>i sorted_indices]<line_sep><return>sorted_matrix<block_end>\n", "solution": "\ndef sort_matrix (matrix):\n    row_sums=[sum(row) for row in matrix]\n    sorted_indices=sorted(range(len(matrix)), key=lambda i:row_sums[i])\n    sorted_matrix=[matrix[i] for i in sorted_indices]\n    return sorted_matrix\n    \n\n"}
{"task_id": "Mbpp/14", "origin_solution": "<def_stmt>find_Volume base height side<block_start><return>base<times>height<times>side<block_end>\n", "solution": "\ndef find_Volume (base, height, side):\n    return base*height*side\n    \n\n"}
{"task_id": "Mbpp/16", "origin_solution": "<import_stmt>re<def_stmt>text_lowercase_underscore text<block_start><return>bool(re.search(r'[a-z]+_' text))<block_end>\n", "solution": "\nimport re\ndef text_lowercase_underscore (text):\n    return bool(re.search(r'[a-z]+_', text))\n    \n\n"}
{"task_id": "Mbpp/17", "origin_solution": "<def_stmt>square_perimeter side_length<block_start><return>4<times>side_length<block_end>\n", "solution": "\ndef square_perimeter (side_length):\n    return 4*side_length\n    \n\n"}
{"task_id": "Mbpp/18", "origin_solution": "<def_stmt>remove_dirty_chars str1 str2<block_start><return>''.join([char<for>char str1<if>char<not><in>str2])<block_end>\n", "solution": "\ndef remove_dirty_chars (str1, str2):\n    return ''.join([char for char in str1 if char not  in str2])\n    \n\n"}
{"task_id": "Mbpp/19", "origin_solution": "<def_stmt>test_duplicate arr<block_start><return>len(arr)<ne>len(set(arr))<block_end>\n", "solution": "\ndef test_duplicate (arr):\n    return len(arr)!=len(set(arr))\n    \n\n"}
{"task_id": "Mbpp/20", "origin_solution": "<def_stmt>is_woodall number<block_start><if_stmt>number%12<eq>0<block_start><return><true><block_end><else_stmt><block_start><return><false><block_end><block_end>\n", "solution": "\ndef is_woodall (number):\n    if number%12==0:\n        return  True \n        \n    \n    else :\n        return  False \n        \n\n\n"}
{"task_id": "Mbpp/56", "origin_solution": "<def_stmt>check num<block_start>rev=int(str(num)[::-1])<line_sep><return>num<eq>2<times>rev<block_end>\n", "solution": "\ndef check (num):\n    rev=int(str(num)[::-1])\n    return num==2*rev\n    \n\n"}
{"task_id": "Mbpp/57", "origin_solution": "<def_stmt>find_Max_Num nums<block_start>\"\"\"\n    Find the largest number that can be formed with the given list of digits.\n    \"\"\"<line_sep>nums=[str(i)<for>i nums]<line_sep>nums.sort(key=<lambda>x:x<times>10 reverse=<true>)<line_sep><return>int(''.join(nums))<block_end>\n", "solution": "\ndef find_Max_Num (nums):\n    \"\"\"\n    Find the largest number that can be formed with the given list of digits.\n    \"\"\"\n    nums=[str(i) for i in nums]\n    nums.sort(key=lambda x:x*10, reverse= True )\n    return int(''.join(nums))\n    \n\n"}
{"task_id": "Mbpp/58", "origin_solution": "<def_stmt>opposite_Signs a b<block_start><return>(a<l>0)<ne>(b<l>0)<block_end>\n", "solution": "\ndef opposite_Signs (a, b):\n    return (a<0)!=(b<0)\n    \n\n"}
{"task_id": "Mbpp/59", "origin_solution": "<def_stmt>is_octagonal n<block_start><return>n<times>(7<times>n-5)<floordiv>2<block_end>\n", "solution": "\ndef is_octagonal (n):\n    return n*(7*n-5)//2\n    \n\n"}
{"task_id": "Mbpp/61", "origin_solution": "<def_stmt>count_Substrings s<block_start>count=0<for_stmt>i range(len(s))<block_start>sum=0<for_stmt>j range(i len(s))<block_start>sum<augadd>int(s[j])<if_stmt>sum<eq>len(s[i:j+1])<block_start>count<augadd>1<block_end><block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_Substrings (s):\n    count=0\n    for i in range(len(s)):\n        sum=0\n        for j in range(i, len(s)):\n            sum+=int(s[j])\n            if sum==len(s[i:j+1]):\n                count+=1\n                \n        \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/62", "origin_solution": "<def_stmt>smallest_num lst<block_start><return>min(lst)<block_end>\n", "solution": "\ndef smallest_num (lst):\n    return min(lst)\n    \n\n"}
{"task_id": "Mbpp/63", "origin_solution": "<def_stmt>max_difference lst<block_start>lst.sort()<line_sep>max_diff=0<for_stmt>i range(len(lst)-1)<block_start>diff=lst[i+1]-lst[i]<if_stmt>diff<g>max_diff<block_start>max_diff=diff<block_end><block_end><return>max_diff<block_end>\n", "solution": "\ndef max_difference (lst):\n    lst.sort()\n    max_diff=0\n    for i in range(len(lst)-1):\n        diff=lst[i+1]-lst[i]\n        if diff>max_diff:\n            max_diff=diff\n            \n    \n    return max_diff\n    \n\n"}
{"task_id": "Mbpp/64", "origin_solution": "<def_stmt>subject_marks marks<block_start><return>sorted(marks key=<lambda>x:x[1])<block_end>\n", "solution": "\ndef subject_marks (marks):\n    return sorted(marks, key=lambda x:x[1])\n    \n\n"}
{"task_id": "Mbpp/65", "origin_solution": "<def_stmt>recursive_list_sum lst<block_start>total=0<for_stmt>element lst<block_start><if_stmt>isinstance(element list)<block_start>total<augadd>recursive_list_sum(element)<block_end><else_stmt><block_start>total<augadd>element<block_end><block_end><return>total<block_end>\n", "solution": "\ndef recursive_list_sum (lst):\n    total=0\n    for element in lst:\n        if isinstance(element, list):\n            total+=recursive_list_sum(element)\n            \n        \n        else :\n            total+=element\n            \n    \n    return total\n    \n\n"}
{"task_id": "Mbpp/66", "origin_solution": "<def_stmt>pos_count lst<block_start><return>sum(1<for>num lst<if>num<g>0)<block_end>\n", "solution": "\ndef pos_count (lst):\n    return sum(1 for num in lst if num>0)\n    \n\n"}
{"task_id": "Mbpp/67", "origin_solution": "<def_stmt>bell_number n<block_start>bell=[[0<for>i range(n+1)]<for>j range(n+1)]<line_sep>bell[0][0]=1<for_stmt>i range(1 n+1)<block_start>bell[i][0]=bell[i-1][i-1]<for_stmt>j range(1 i+1)<block_start>bell[i][j]=bell[i-1][j-1]+bell[i][j-1]<block_end><block_end><return>bell[n][0]<block_end>\n", "solution": "\ndef bell_number (n):\n    bell=[[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0]=1\n    for i in range(1, n+1):\n        bell[i][0]=bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j]=bell[i-1][j-1]+bell[i][j-1]\n            \n    \n    return bell[n][0]\n    \n\n"}
{"task_id": "Mbpp/68", "origin_solution": "<def_stmt>is_Monotonic arr<block_start>increasing=decreasing=<true><for_stmt>i range(len(arr)-1)<block_start><if_stmt>arr[i]<l>arr[i+1]<block_start>decreasing=<false><block_end><elif_stmt>arr[i]<g>arr[i+1]<block_start>increasing=<false><block_end><block_end><return>increasing<or>decreasing<block_end>\n", "solution": "\ndef is_Monotonic (arr):\n    increasing=decreasing= True \n    for i in range(len(arr)-1):\n        if arr[i]<arr[i+1]:\n            decreasing= False \n            \n        \n        elif arr[i]>arr[i+1]:\n            increasing= False \n            \n    \n    return increasing or decreasing\n    \n\n"}
{"task_id": "Mbpp/69", "origin_solution": "<def_stmt>is_sublist lst sublist<block_start><for_stmt>i range(len(lst)-len(sublist)+1)<block_start><if_stmt>lst[i:i+len(sublist)]<eq>sublist<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef is_sublist (lst, sublist):\n    for i in range(len(lst)-len(sublist)+1):\n        if lst[i:i+len(sublist)]==sublist:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/70", "origin_solution": "<def_stmt>get_equal test_list<block_start><if_stmt>len(test_list)<eq>0<block_start><return><true><block_end><elif_stmt>len(test_list)<eq>1<block_start><return><true><block_end><else_stmt><block_start><for_stmt>i range(len(test_list))<block_start><for_stmt>j range(i+1 len(test_list))<block_start><if_stmt>len(test_list[i])<ne>len(test_list[j])<block_start><return><false><block_end><block_end><block_end><return><true><block_end><block_end>\n", "solution": "\ndef get_equal (test_list):\n    if len(test_list)==0:\n        return  True \n        \n    \n    elif len(test_list)==1:\n        return  True \n        \n    \n    else :\n        for i in range(len(test_list)):\n            for j in range(i+1, len(test_list)):\n                if len(test_list[i])!=len(test_list[j]):\n                    return  False \n                    \n            \n        \n        return  True \n        \n\n\n"}
{"task_id": "Mbpp/71", "origin_solution": "<def_stmt>comb_sort lst<block_start><for_stmt>i range(len(lst))<block_start>min_idx=i<for_stmt>j range(i+1 len(lst))<block_start><if_stmt>lst[j]<l>lst[min_idx]<block_start>min_idx=j<block_end><block_end>lst[i],lst[min_idx]=lst[min_idx] lst[i]<block_end><return>lst<block_end>\n", "solution": "\ndef comb_sort (lst):\n    for i in range(len(lst)):\n        min_idx=i\n        for j in range(i+1, len(lst)):\n            if lst[j]<lst[min_idx]:\n                min_idx=j\n                \n        \n        lst[i],lst[min_idx]=lst[min_idx], lst[i]\n        \n    return lst\n    \n\n"}
{"task_id": "Mbpp/72", "origin_solution": "<def_stmt>dif_Square n<block_start><for_stmt>i range(0 int(n<power>0.5)+1)<block_start>j=n-i<times>i<if_stmt>(j<power>0.5).is_integer()<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef dif_Square (n):\n    for i in range(0, int(n**0.5)+1):\n        j=n-i*i\n        if (j**0.5).is_integer():\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/74", "origin_solution": "<def_stmt>is_samepatterns patterns<block_start><for_stmt>i range(len(patterns)-1)<block_start><if_stmt>patterns[i]<ne>patterns[i+1]<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef is_samepatterns (patterns):\n    for i in range(len(patterns)-1):\n        if patterns[i]!=patterns[i+1]:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/75", "origin_solution": "<def_stmt>find_tuples tuples k<block_start>result=[]<for_stmt>t tuples<block_start><if_stmt>all(i%k<eq>0<for>i t)<block_start>result.append(t)<block_end><block_end><return>result<block_end>\n", "solution": "\ndef find_tuples (tuples, k):\n    result=[]\n    for t in tuples:\n        if all(i%k==0 for i in t):\n            result.append(t)\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/77", "origin_solution": "<def_stmt>is_Diff n<block_start><return>n%11<eq>0<block_end>\n", "solution": "\ndef is_Diff (n):\n    return n%11==0\n    \n\n"}
{"task_id": "Mbpp/79", "origin_solution": "<def_stmt>word_len word<block_start><return>len(word)%2<ne>0<block_end>\n", "solution": "\ndef word_len (word):\n    return len(word)%2!=0\n    \n\n"}
{"task_id": "Mbpp/80", "origin_solution": "<def_stmt>tetrahedral_number n<block_start><return>n<times>(n+1)<times>(n+2)<floordiv>6<block_end>\n", "solution": "\ndef tetrahedral_number (n):\n    return n*(n+1)*(n+2)//6\n    \n\n"}
{"task_id": "Mbpp/82", "origin_solution": "<import_stmt>math<def_stmt>volume_sphere r<block_start><return>(4/3)<times>math.pi<times>r<power>3<block_end>\n", "solution": "\nimport math\ndef volume_sphere (r):\n    return (4/3)*math.pi*r**3\n    \n\n"}
{"task_id": "Mbpp/84", "origin_solution": "<def_stmt>sequence n<block_start><if_stmt>n<eq>1<block_start><return>1<block_end><elif_stmt>n<eq>2<block_start><return>2<block_end><else_stmt><block_start><return>sequence(n-1)+sequence(n-2)<block_end><block_end>\n", "solution": "\ndef sequence (n):\n    if n==1:\n        return 1\n        \n    \n    elif n==2:\n        return 2\n        \n    \n    else :\n        return sequence(n-1)+sequence(n-2)\n        \n\n\n"}
{"task_id": "Mbpp/85", "origin_solution": "<import_stmt>math<def_stmt>surfacearea_sphere radius<block_start>surface_area=4<times>math.pi<times>radius<power>2<line_sep><return>surface_area<block_end>\n", "solution": "\nimport math\ndef surfacearea_sphere (radius):\n    surface_area=4*math.pi*radius**2\n    return surface_area\n    \n\n"}
{"task_id": "Mbpp/86", "origin_solution": "<def_stmt>centered_hexagonal_number n<block_start><return>3<times>n<times>(2<times>n-1)<floordiv>2<block_end>\n", "solution": "\ndef centered_hexagonal_number (n):\n    return 3*n*(2*n-1)//2\n    \n\n"}
{"task_id": "Mbpp/87", "origin_solution": "<def_stmt>merge_dictionaries_three dict1 dict2 dict3<block_start>merged_dict=dict1.copy()<line_sep>merged_dict.update(dict2)<line_sep>merged_dict.update(dict3)<line_sep><return>merged_dict<block_end>\n", "solution": "\ndef merge_dictionaries_three (dict1, dict2, dict3):\n    merged_dict=dict1.copy()\n    merged_dict.update(dict2)\n    merged_dict.update(dict3)\n    return merged_dict\n    \n\n"}
{"task_id": "Mbpp/88", "origin_solution": "<def_stmt>freq_count lst<block_start>freq={}<for_stmt>item lst<block_start><if_stmt>item<in>freq<block_start>freq[item]<augadd>1<block_end><else_stmt><block_start>freq[item]=1<block_end><block_end><return>freq<block_end>\n", "solution": "\ndef freq_count (lst):\n    freq={}\n    for item in lst:\n        if item in freq:\n            freq[item]+=1\n            \n        \n        else :\n            freq[item]=1\n            \n    \n    return freq\n    \n\n"}
{"task_id": "Mbpp/89", "origin_solution": "<def_stmt>closest_num n<block_start><return>n-1<if>n<g>1<else>n<block_end>\n", "solution": "\ndef closest_num (n):\n    return n-1 if n>1 else n\n    \n\n"}
{"task_id": "Mbpp/90", "origin_solution": "<def_stmt>len_log words<block_start>max_len=0<for_stmt>word words<block_start><if_stmt>len(word)<g>max_len<block_start>max_len=len(word)<block_end><block_end><return>max_len<block_end>\n", "solution": "\ndef len_log (words):\n    max_len=0\n    for word in words:\n        if len(word)>max_len:\n            max_len=len(word)\n            \n    \n    return max_len\n    \n\n"}
{"task_id": "Mbpp/91", "origin_solution": "<def_stmt>find_substring list1 substring<block_start><for_stmt>i list1<block_start><if_stmt>substring<in>i<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef find_substring (list1, substring):\n    for i in list1:\n        if substring in i:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/92", "origin_solution": "<def_stmt>is_undulating num<block_start>num_str=str(num)<for_stmt>i range(1 len(num_str))<block_start><if_stmt>int(num_str[i:])<l>int(num_str[:i])<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef is_undulating (num):\n    num_str=str(num)\n    for i in range(1, len(num_str)):\n        if int(num_str[i:])<int(num_str[:i]):\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/93", "origin_solution": "<def_stmt>power a b<block_start><if_stmt>b<eq>0<block_start><return>1<block_end><elif_stmt>b<eq>1<block_start><return>a<block_end><elif_stmt>b%2<eq>0<block_start><return>power(a<times>a b<floordiv>2)<block_end><else_stmt><block_start><return>a<times>power(a<times>a (b-1)<floordiv>2)<block_end><block_end>\n", "solution": "\ndef power (a, b):\n    if b==0:\n        return 1\n        \n    \n    elif b==1:\n        return a\n        \n    \n    elif b%2==0:\n        return power(a*a, b//2)\n        \n    \n    else :\n        return a*power(a*a, (b-1)//2)\n        \n\n\n"}
{"task_id": "Mbpp/94", "origin_solution": "<def_stmt>index_minimum lst<block_start><return>min(lst key=<lambda>x:x[1])[0]<block_end>\n", "solution": "\ndef index_minimum (lst):\n    return min(lst, key=lambda x:x[1])[0]\n    \n\n"}
{"task_id": "Mbpp/95", "origin_solution": "<def_stmt>Find_Min_Length list_of_lists<block_start>min_length=float('inf')<for_stmt>sublist list_of_lists<block_start><if_stmt>len(sublist)<l>min_length<block_start>min_length=len(sublist)<block_end><block_end><return>min_length<block_end>\n", "solution": "\ndef Find_Min_Length (list_of_lists):\n    min_length=float('inf')\n    for sublist in list_of_lists:\n        if len(sublist)<min_length:\n            min_length=len(sublist)\n            \n    \n    return min_length\n    \n\n"}
{"task_id": "Mbpp/96", "origin_solution": "<def_stmt>divisor n<block_start>count=0<for_stmt>i range(1 n+1)<block_start><if_stmt>n%i<eq>0<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef divisor (n):\n    count=0\n    for i in range(1, n+1):\n        if n%i==0:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/97", "origin_solution": "<def_stmt>frequency_lists list_of_lists<block_start>frequency={}<for_stmt>sublist list_of_lists<block_start><for_stmt>item sublist<block_start><if_stmt>item<in>frequency<block_start>frequency[item]<augadd>1<block_end><else_stmt><block_start>frequency[item]=1<block_end><block_end><block_end><return>frequency<block_end>\n", "solution": "\ndef frequency_lists (list_of_lists):\n    frequency={}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item]+=1\n                \n            \n            else :\n                frequency[item]=1\n                \n        \n    \n    return frequency\n    \n\n"}
{"task_id": "Mbpp/98", "origin_solution": "<def_stmt>multiply_num nums<block_start>product=1<for_stmt>num nums<block_start>product<augmul>num<block_end><return>product/len(nums)<block_end>\n", "solution": "\ndef multiply_num (nums):\n    product=1\n    for num in nums:\n        product*=num\n        \n    return product/len(nums)\n    \n\n"}
{"task_id": "Mbpp/99", "origin_solution": "<def_stmt>decimal_to_binary n<block_start><if_stmt>n<eq>0<block_start><return>'0'<block_end>binary=''<while_stmt>n<g>0<block_start>binary=str(n%2)+binary<line_sep>n=n<floordiv>2<block_end><return>binary<block_end>\n", "solution": "\ndef decimal_to_binary (n):\n    if n==0:\n        return '0'\n        \n    binary=''\n    while n>0:\n        binary=str(n%2)+binary\n        n=n//2\n        \n    return binary\n    \n\n"}
{"task_id": "Mbpp/100", "origin_solution": "<def_stmt>next_smallest_palindrome n<block_start>n<augadd>1<while_stmt><not>is_palindrome(n)<block_start>n<augadd>1<block_end><return>n<block_end><def_stmt>is_palindrome n<block_start><return>str(n)<eq>str(n)[::-1]<block_end>\n", "solution": "\ndef next_smallest_palindrome (n):\n    n+=1\n    while  not is_palindrome(n):\n        n+=1\n        \n    return n\n    \ndef is_palindrome (n):\n    return str(n)==str(n)[::-1]\n    \n\n"}
{"task_id": "Mbpp/101", "origin_solution": "<def_stmt>kth_element arr k<block_start><return>arr[k-1]<block_end>\n", "solution": "\ndef kth_element (arr, k):\n    return arr[k-1]\n    \n\n"}
{"task_id": "Mbpp/102", "origin_solution": "<def_stmt>snake_to_camel snake_str<block_start>components=snake_str.split('_')<line_sep><return>''.join(x.title()<for>x components)<block_end>\n", "solution": "\ndef snake_to_camel (snake_str):\n    components=snake_str.split('_')\n    return ''.join(x.title() for x in components)\n    \n\n"}
{"task_id": "Mbpp/103", "origin_solution": "<def_stmt>eulerian_num n m<block_start><return>n<times>m<block_end>\n", "solution": "\ndef eulerian_num (n, m):\n    return n*m\n    \n\n"}
{"task_id": "Mbpp/104", "origin_solution": "<def_stmt>sort_sublists list_of_lists<block_start><return>[sorted(sublist)<for>sublist list_of_lists]<block_end>\n", "solution": "\ndef sort_sublists (list_of_lists):\n    return [sorted(sublist) for sublist in list_of_lists]\n    \n\n"}
{"task_id": "Mbpp/105", "origin_solution": "<def_stmt>count bool_list<block_start><return>sum(bool_list)<block_end>\n", "solution": "\ndef count (bool_list):\n    return sum(bool_list)\n    \n\n"}
{"task_id": "Mbpp/106", "origin_solution": "<def_stmt>add_lists list1 tuple1<block_start><return>tuple1+list1<block_end>\n", "solution": "\ndef add_lists (list1, tuple1):\n    return tuple1+list1\n    \n\n"}
{"task_id": "Mbpp/108", "origin_solution": "<def_stmt>merge_sorted_list list1 list2 list3<block_start>merged_list=list1+list2+list3<line_sep>merged_list.sort()<line_sep><return>merged_list<block_end>\n", "solution": "\ndef merge_sorted_list (list1, list2, list3):\n    merged_list=list1+list2+list3\n    merged_list.sort()\n    return merged_list\n    \n\n"}
{"task_id": "Mbpp/109", "origin_solution": "<def_stmt>odd_Equivalent binary_string:str n:int<arrow>int<block_start>odd_count=0<for_stmt>_ range(n)<block_start>binary_string=binary_string[1:]+binary_string[0]<if_stmt>binary_string[0]<eq>'1'<block_start>odd_count<augadd>1<block_end><block_end><return>odd_count<block_end>\n", "solution": "\ndef odd_Equivalent (binary_string:str, n:int)->int:\n    odd_count=0\n    for _ in range(n):\n        binary_string=binary_string[1:]+binary_string[0]\n        if binary_string[0]=='1':\n            odd_count+=1\n            \n    \n    return odd_count\n    \n\n"}
{"task_id": "Mbpp/111", "origin_solution": "<def_stmt>common_in_nested_lists nested_lists<block_start>common_elements=set()<for_stmt>sublist nested_lists<block_start><for_stmt>element sublist<block_start><if_stmt>element<in>common_elements<block_start>common_elements.remove(element)<block_end><else_stmt><block_start>common_elements.add(element)<block_end><block_end><block_end><return>common_elements<block_end>\n", "solution": "\ndef common_in_nested_lists (nested_lists):\n    common_elements=set()\n    for sublist in nested_lists:\n        for element in sublist:\n            if element in common_elements:\n                common_elements.remove(element)\n                \n            \n            else :\n                common_elements.add(element)\n                \n        \n    \n    return common_elements\n    \n\n"}
{"task_id": "Mbpp/113", "origin_solution": "<def_stmt>check_integer s<block_start><try_stmt><block_start>int(s)<line_sep><return><true><block_end><except_stmt>ValueError<block_start><return><false><block_end><block_end>\n", "solution": "\ndef check_integer (s):\n    try:\n        int(s)\n        return  True \n        \n    \n    except ValueError:\n        return  False \n        \n\n\n"}
{"task_id": "Mbpp/116", "origin_solution": "<def_stmt>tuple_to_int t<block_start><return>int(''.join(map(str t)))<block_end>\n", "solution": "\ndef tuple_to_int (t):\n    return int(''.join(map(str, t)))\n    \n\n"}
{"task_id": "Mbpp/118", "origin_solution": "<def_stmt>string_to_list s<block_start><return>s.split()<block_end>\n", "solution": "\ndef string_to_list (s):\n    return s.split()\n    \n\n"}
{"task_id": "Mbpp/119", "origin_solution": "<def_stmt>search nums<block_start>left,right=0 len(nums)-1<while_stmt>left<l>right<block_start>mid=(left+right)<floordiv>2<if_stmt>nums[mid]<eq>nums[mid+1]<block_start>left=mid+2<block_end><else_stmt><block_start>right=mid<block_end><block_end><return>nums[left]<block_end>\n", "solution": "\ndef search (nums):\n    left,right=0, len(nums)-1\n    while left<right:\n        mid=(left+right)//2\n        if nums[mid]==nums[mid+1]:\n            left=mid+2\n            \n        \n        else :\n            right=mid\n            \n    \n    return nums[left]\n    \n\n"}
{"task_id": "Mbpp/120", "origin_solution": "<import_stmt>math<def_stmt>max_product_tuple lst<block_start>max_product=float('-inf')<for_stmt>i range(len(lst))<block_start><for_stmt>j range(i+1 len(lst))<block_start>product=lst[i][0]<times>lst[j][0]<times>lst[i][1]<times>lst[j][1]<if_stmt>product<g>max_product<block_start>max_product=product<block_end><block_end><block_end><return>max_product<block_end>\n", "solution": "\nimport math\ndef max_product_tuple (lst):\n    max_product=float('-inf')\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            product=lst[i][0]*lst[j][0]*lst[i][1]*lst[j][1]\n            if product>max_product:\n                max_product=product\n                \n        \n    \n    return max_product\n    \n\n"}
{"task_id": "Mbpp/123", "origin_solution": "<def_stmt>sum_of_divisors n<block_start>\"\"\"\n    Returns the sum of all divisors of n.\n    \"\"\"<line_sep>result=1<for_stmt>i range(2 int(n<power>0.5)+1)<block_start><if_stmt>n%i<eq>0<block_start>result<augadd>i<if_stmt>i<ne>n<floordiv>i<block_start>result<augadd>n<floordiv>i<block_end><block_end><block_end><return>result<block_end><def_stmt>amicable_numbers_sum n<block_start>\"\"\"\n    Returns the sum of all amicable numbers from 1 to n.\n    \"\"\"<line_sep>amicable_sum=0<for_stmt>i range(2 n)<block_start><if_stmt>i<not><in>[1 2]<block_start><if_stmt>sum_of_divisors(i)<eq>sum_of_divisors(n-i)<block_start>amicable_sum<augadd>i<block_end><block_end><block_end><return>amicable_sum<block_end>\n", "solution": "\ndef sum_of_divisors (n):\n    \"\"\"\n    Returns the sum of all divisors of n.\n    \"\"\"\n    result=1\n    for i in range(2, int(n**0.5)+1):\n        if n%i==0:\n            result+=i\n            if i!=n//i:\n                result+=n//i\n                \n        \n    \n    return result\n    \ndef amicable_numbers_sum (n):\n    \"\"\"\n    Returns the sum of all amicable numbers from 1 to n.\n    \"\"\"\n    amicable_sum=0\n    for i in range(2, n):\n        if i not  in [1, 2]:\n            if sum_of_divisors(i)==sum_of_divisors(n-i):\n                amicable_sum+=i\n                \n        \n    \n    return amicable_sum\n    \n\n"}
{"task_id": "Mbpp/124", "origin_solution": "<import_stmt>math<def_stmt>angle_complex a b<block_start><return>math.atan2(b.imag a.imag)<block_end>\n", "solution": "\nimport math\ndef angle_complex (a, b):\n    return math.atan2(b.imag, a.imag)\n    \n\n"}
{"task_id": "Mbpp/125", "origin_solution": "<def_stmt>find_length s<block_start>max_length=0<line_sep>count=0<line_sep>count_dict={0:-1}<for_stmt>i,char enumerate(s)<block_start><if_stmt>char<eq>'0'<block_start>count<augsub>1<block_end><else_stmt><block_start>count<augadd>1<block_end><if_stmt>count<in>count_dict<block_start>max_length=max(max_length i-count_dict[count])<block_end><else_stmt><block_start>count_dict[count]=i<block_end><block_end><return>max_length<block_end>\n", "solution": "\ndef find_length (s):\n    max_length=0\n    count=0\n    count_dict={0:-1}\n    for i,char in enumerate(s):\n        if char=='0':\n            count-=1\n            \n        \n        else :\n            count+=1\n            \n        if count in count_dict:\n            max_length=max(max_length, i-count_dict[count])\n            \n        \n        else :\n            count_dict[count]=i\n            \n    \n    return max_length\n    \n\n"}
{"task_id": "Mbpp/126", "origin_solution": "<def_stmt>sum_common_divisors num1 num2<block_start><def_stmt>gcd a b<block_start><while_stmt>b<block_start>a,b=b a%b<block_end><return>a<block_end>gcd_value=gcd(num1 num2)<line_sep>divisors=[i<for>i range(1 gcd_value+1)<if>gcd_value%i<eq>0]<line_sep><return>sum(divisors)<block_end>\n", "solution": "\ndef sum_common_divisors (num1, num2):\n    def gcd (a, b):\n        while b:\n            a,b=b, a%b\n            \n        return a\n        \n    gcd_value=gcd(num1, num2)\n    divisors=[i for i in range(1, gcd_value+1) if gcd_value%i==0]\n    return sum(divisors)\n    \n\n"}
{"task_id": "Mbpp/127", "origin_solution": "<def_stmt>multiply_int a b<block_start><return>a<times>b<block_end>\n", "solution": "\ndef multiply_int (a, b):\n    return a*b\n    \n\n"}
{"task_id": "Mbpp/128", "origin_solution": "<def_stmt>long_words n words<block_start><return>[word<for>word words<if>len(word)<g>n]<block_end>\n", "solution": "\ndef long_words (n, words):\n    return [word for word in words if len(word)>n]\n    \n\n"}
{"task_id": "Mbpp/129", "origin_solution": "<def_stmt>is_magic_square matrix<block_start>n=len(matrix)<if_stmt>n<eq>0<block_start><return><false><block_end>m=len(matrix[0])<if_stmt>n<ne>m<block_start><return><false><block_end>magic_sum=sum(matrix[0])<for_stmt>i range(n)<block_start><if_stmt>sum(matrix[i])<ne>magic_sum<or>sum(matrix[j][i]<for>j range(n))<ne>magic_sum<block_start><return><false><block_end><block_end><if_stmt>sum(matrix[i][i]<for>i range(n))<ne>magic_sum<or>sum(matrix[i][n-1-i]<for>i range(n))<ne>magic_sum<block_start><return><false><block_end><return><true><block_end>\n", "solution": "\ndef is_magic_square (matrix):\n    n=len(matrix)\n    if n==0:\n        return  False \n        \n    m=len(matrix[0])\n    if n!=m:\n        return  False \n        \n    magic_sum=sum(matrix[0])\n    for i in range(n):\n        if sum(matrix[i])!=magic_sum or sum(matrix[j][i] for j in range(n))!=magic_sum:\n            return  False \n            \n    \n    if sum(matrix[i][i] for i in range(n))!=magic_sum or sum(matrix[i][n-1-i] for i in range(n))!=magic_sum:\n        return  False \n        \n    return  True \n    \n\n"}
{"task_id": "Mbpp/130", "origin_solution": "<def_stmt>max_occurrences lst<block_start>freq_dict={}<for_stmt>item lst<block_start><if_stmt>item<in>freq_dict<block_start>freq_dict[item]<augadd>1<block_end><else_stmt><block_start>freq_dict[item]=1<block_end><block_end>max_freq=max(freq_dict.values())<for_stmt>key,value freq_dict.items()<block_start><if_stmt>value<eq>max_freq<block_start><return>key<block_end><block_end><block_end>\n", "solution": "\ndef max_occurrences (lst):\n    freq_dict={}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item]+=1\n            \n        \n        else :\n            freq_dict[item]=1\n            \n    \n    max_freq=max(freq_dict.values())\n    for key,value in freq_dict.items():\n        if value==max_freq:\n            return key\n            \n    \n\n\n"}
{"task_id": "Mbpp/131", "origin_solution": "<def_stmt>reverse_vowels s:str<arrow>str<block_start>vowels=set('aeiouAEIOU')<line_sep>s_list=list(s)<line_sep>left,right=0 len(s)-1<while_stmt>left<l>right<block_start><if_stmt>s_list[left]<not><in>vowels<block_start>left<augadd>1<block_end><elif_stmt>s_list[right]<not><in>vowels<block_start>right<augsub>1<block_end><else_stmt><block_start>s_list[left],s_list[right]=s_list[right] s_list[left]<line_sep>left<augadd>1<line_sep>right<augsub>1<block_end><block_end><return>''.join(s_list)<block_end>\n", "solution": "\ndef reverse_vowels (s:str)->str:\n    vowels=set('aeiouAEIOU')\n    s_list=list(s)\n    left,right=0, len(s)-1\n    while left<right:\n        if s_list[left] not  in vowels:\n            left+=1\n            \n        \n        elif s_list[right] not  in vowels:\n            right-=1\n            \n        \n        else :\n            s_list[left],s_list[right]=s_list[right], s_list[left]\n            left+=1\n            right-=1\n            \n    \n    return ''.join(s_list)\n    \n\n"}
{"task_id": "Mbpp/132", "origin_solution": "<def_stmt>tup_string tup<block_start><return>''.join(tup)<block_end>\n", "solution": "\ndef tup_string (tup):\n    return ''.join(tup)\n    \n\n"}
{"task_id": "Mbpp/133", "origin_solution": "<def_stmt>sum_negativenum nums<block_start><return>sum(num<for>num nums<if>num<l>0)<block_end>\n", "solution": "\ndef sum_negativenum (nums):\n    return sum(num for num in nums if num<0)\n    \n\n"}
{"task_id": "Mbpp/135", "origin_solution": "<def_stmt>hexagonal_num n<block_start><return>n<times>(2<times>n-1)<block_end>\n", "solution": "\ndef hexagonal_num (n):\n    return n*(2*n-1)\n    \n\n"}
{"task_id": "Mbpp/137", "origin_solution": "<import_stmt>math<def_stmt>zero_count arr<block_start>zero_count=0<for_stmt>num arr<block_start><if_stmt>num<eq>0<block_start>zero_count<augadd>1<block_end><block_end><return>zero_count/len(arr)<block_end>\n", "solution": "\nimport math\ndef zero_count (arr):\n    zero_count=0\n    for num in arr:\n        if num==0:\n            zero_count+=1\n            \n    \n    return zero_count/len(arr)\n    \n\n"}
{"task_id": "Mbpp/138", "origin_solution": "<def_stmt>is_Sum_Of_Powers_Of_Two n<block_start><if_stmt>n<le>0<block_start><return><false><block_end><while_stmt>n<g>1<block_start><if_stmt>n%2<ne>0<block_start><return><false><block_end>n=n<floordiv>2<block_end><return><true><block_end>\n", "solution": "\ndef is_Sum_Of_Powers_Of_Two (n):\n    if n<=0:\n        return  False \n        \n    while n>1:\n        if n%2!=0:\n            return  False \n            \n        n=n//2\n        \n    return  True \n    \n\n"}
{"task_id": "Mbpp/139", "origin_solution": "<import_stmt>math<def_stmt>circle_circumference radius<block_start>circumference=2<times>math.pi<times>radius<line_sep><return>circumference<block_end>\n", "solution": "\nimport math\ndef circle_circumference (radius):\n    circumference=2*math.pi*radius\n    return circumference\n    \n\n"}
{"task_id": "Mbpp/140", "origin_solution": "<def_stmt>extract_singly list_of_lists<block_start>flattened_list=[item<for>sublist list_of_lists<for>item sublist]<line_sep><return>set(flattened_list)<block_end>\n", "solution": "\ndef extract_singly (list_of_lists):\n    flattened_list=[item for sublist in list_of_lists for item in sublist]\n    return set(flattened_list)\n    \n\n"}
{"task_id": "Mbpp/141", "origin_solution": "<def_stmt>pancake_sort lst<block_start><for_stmt>i range(len(lst))<block_start>max_index=i<for_stmt>j range(i+1 len(lst))<block_start><if_stmt>lst[j]<g>lst[max_index]<block_start>max_index=j<block_end><block_end>lst[i],lst[max_index]=lst[max_index] lst[i]<block_end><return>lst<block_end>\n", "solution": "\ndef pancake_sort (lst):\n    for i in range(len(lst)):\n        max_index=i\n        for j in range(i+1, len(lst)):\n            if lst[j]>lst[max_index]:\n                max_index=j\n                \n        \n        lst[i],lst[max_index]=lst[max_index], lst[i]\n        \n    return lst\n    \n\n"}
{"task_id": "Mbpp/142", "origin_solution": "<def_stmt>count_samepair list1 list2 list3<block_start>count=0<for_stmt>i range(len(list1))<block_start><if_stmt>list1[i]<eq>list2[i]<eq>list3[i]<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_samepair (list1, list2, list3):\n    count=0\n    for i in range(len(list1)):\n        if list1[i]==list2[i]==list3[i]:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/145", "origin_solution": "<def_stmt>max_Abs_Diff arr<block_start>max_diff=0<for_stmt>i range(len(arr))<block_start><for_stmt>j range(i+1 len(arr))<block_start>diff=abs(arr[i]-arr[j])<if_stmt>diff<g>max_diff<block_start>max_diff=diff<block_end><block_end><block_end><return>max_diff<block_end>\n", "solution": "\ndef max_Abs_Diff (arr):\n    max_diff=0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            diff=abs(arr[i]-arr[j])\n            if diff>max_diff:\n                max_diff=diff\n                \n        \n    \n    return max_diff\n    \n\n"}
{"task_id": "Mbpp/160", "origin_solution": "<def_stmt>find_solution a b n<block_start><for_stmt>x range(-n<floordiv>a+1 n<floordiv>a)<block_start><for_stmt>y range(-n<floordiv>b+1 n<floordiv>b)<block_start><if_stmt>a<times>x+b<times>y<eq>n<block_start><return>(x y)<block_end><block_end><block_end><return><none><block_end>\n", "solution": "\ndef find_solution (a, b, n):\n    for x in range(-n//a+1, n//a):\n        for y in range(-n//b+1, n//b):\n            if a*x+b*y==n:\n                return (x, y)\n                \n        \n    \n    return  None \n    \n\n"}
{"task_id": "Mbpp/161", "origin_solution": "<def_stmt>remove_elements list1 list2<block_start><return>[i<for>i list1<if>i<not><in>list2]<block_end>\n", "solution": "\ndef remove_elements (list1, list2):\n    return [i for i in list1 if i not  in list2]\n    \n\n"}
{"task_id": "Mbpp/162", "origin_solution": "<def_stmt>sum_series n<block_start>total=0<for_stmt>i range(n<floordiv>2+1)<block_start>total<augadd>n-2<times>i<block_end><return>total<block_end>\n", "solution": "\ndef sum_series (n):\n    total=0\n    for i in range(n//2+1):\n        total+=n-2*i\n        \n    return total\n    \n\n"}
{"task_id": "Mbpp/165", "origin_solution": "<def_stmt>count_char_position s<block_start>s=s.lower()<line_sep>count=0<for_stmt>i range(len(s))<block_start><if_stmt>s[i].isalpha()<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_char_position (s):\n    s=s.lower()\n    count=0\n    for i in range(len(s)):\n        if s[i].isalpha():\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/166", "origin_solution": "<def_stmt>find_even_pair lst<block_start>even_count=0<line_sep>odd_count=0<for_stmt>num lst<block_start><if_stmt>num%2<eq>0<block_start>even_count<augadd>1<block_end><else_stmt><block_start>odd_count<augadd>1<block_end><block_end><return>even_count<times>odd_count<block_end>\n", "solution": "\ndef find_even_pair (lst):\n    even_count=0\n    odd_count=0\n    for num in lst:\n        if num%2==0:\n            even_count+=1\n            \n        \n        else :\n            odd_count+=1\n            \n    \n    return even_count*odd_count\n    \n\n"}
{"task_id": "Mbpp/167", "origin_solution": "<def_stmt>next_power_of_2 n<block_start><if_stmt>n<eq>0<block_start><return>1<block_end><elif_stmt>n&(n-1)<eq>0<block_start><return>n<block_end><else_stmt><block_start><return>1<lshift>(n-1).bit_length()<block_end><block_end>\n", "solution": "\ndef next_power_of_2 (n):\n    if n==0:\n        return 1\n        \n    \n    elif n&(n-1)==0:\n        return n\n        \n    \n    else :\n        return 1<<(n-1).bit_length()\n        \n\n\n"}
{"task_id": "Mbpp/168", "origin_solution": "<def_stmt>frequency lst num<block_start><return>lst.count(num)<block_end>\n", "solution": "\ndef frequency (lst, num):\n    return lst.count(num)\n    \n\n"}
{"task_id": "Mbpp/170", "origin_solution": "<def_stmt>sum_range_list lst start end<block_start><return>sum(lst[start:end+1])<block_end>\n", "solution": "\ndef sum_range_list (lst, start, end):\n    return sum(lst[start:end+1])\n    \n\n"}
{"task_id": "Mbpp/171", "origin_solution": "<def_stmt>perimeter_pentagon side_length<block_start><return>side_length<times>5<block_end>\n", "solution": "\ndef perimeter_pentagon (side_length):\n    return side_length*5\n    \n\n"}
{"task_id": "Mbpp/172", "origin_solution": "<def_stmt>count_occurance string<block_start><return>string.count('std')<block_end>\n", "solution": "\ndef count_occurance (string):\n    return string.count('std')\n    \n\n"}
{"task_id": "Mbpp/222", "origin_solution": "<def_stmt>check_type t<block_start><if_stmt><not>t<block_start><return><true><block_end>first_type=type(t[0])<for_stmt>item t<block_start><if_stmt>type(item)<ne>first_type<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef check_type (t):\n    if  not t:\n        return  True \n        \n    first_type=type(t[0])\n    for item in t:\n        if type(item)!=first_type:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/223", "origin_solution": "<def_stmt>is_majority arr n x<block_start>count=0<for_stmt>i range(n)<block_start><if_stmt>arr[i]<eq>x<block_start>count<augadd>1<block_end><block_end><return>count<g>n<floordiv>2<block_end>\n", "solution": "\ndef is_majority (arr, n, x):\n    count=0\n    for i in range(n):\n        if arr[i]==x:\n            count+=1\n            \n    \n    return count>n//2\n    \n\n"}
{"task_id": "Mbpp/224", "origin_solution": "<def_stmt>count_Set_Bits n<block_start>count=0<while_stmt>n<block_start>count<augadd>n&1<line_sep>n<augrshift>1<block_end><return>count<block_end>\n", "solution": "\ndef count_Set_Bits (n):\n    count=0\n    while n:\n        count+=n&1\n        n>>=1\n        \n    return count\n    \n\n"}
{"task_id": "Mbpp/226", "origin_solution": "<def_stmt>odd_values_string s<block_start><return>''.join([s[i]<for>i range(len(s))<if>i%2<eq>0])<block_end>\n", "solution": "\ndef odd_values_string (s):\n    return ''.join([s[i] for i in range(len(s)) if i%2==0])\n    \n\n"}
{"task_id": "Mbpp/227", "origin_solution": "<def_stmt>min_of_three a b c<block_start><return>min(a b c)<block_end>\n", "solution": "\ndef min_of_three (a, b, c):\n    return min(a, b, c)\n    \n\n"}
{"task_id": "Mbpp/230", "origin_solution": "<def_stmt>replace_blank string char<block_start><return>string.replace(\" \" char)<block_end>\n", "solution": "\ndef replace_blank (string, char):\n    return string.replace(\" \", char)\n    \n\n"}
{"task_id": "Mbpp/232", "origin_solution": "<def_stmt>larg_nnum l n<block_start><return>sorted(l reverse=<true>)[:n]<block_end>\n", "solution": "\ndef larg_nnum (l, n):\n    return sorted(l, reverse= True )[:n]\n    \n\n"}
{"task_id": "Mbpp/233", "origin_solution": "<import_stmt>math<def_stmt>lateralsuface_cylinder radius height<block_start>lateral_surface_area=2<times>math.pi<times>radius<times>height<line_sep><return>lateral_surface_area<block_end>\n", "solution": "\nimport math\ndef lateralsuface_cylinder (radius, height):\n    lateral_surface_area=2*math.pi*radius*height\n    return lateral_surface_area\n    \n\n"}
{"task_id": "Mbpp/234", "origin_solution": "<def_stmt>volume_cube side_length<block_start><return>side_length<power>3<block_end>\n", "solution": "\ndef volume_cube (side_length):\n    return side_length**3\n    \n\n"}
{"task_id": "Mbpp/235", "origin_solution": "<def_stmt>even_bit_set_number n<block_start><return>n&~(n-1)<block_end>\n", "solution": "\ndef even_bit_set_number (n):\n    return n&~(n-1)\n    \n\n"}
{"task_id": "Mbpp/237", "origin_solution": "<def_stmt>check_occurences lst<block_start>result={}<for_stmt>item lst<block_start><if_stmt>item<in>result<block_start>result[item]<augadd>1<block_end><else_stmt><block_start>result[item]=1<block_end><block_end><return>result<block_end>\n", "solution": "\ndef check_occurences (lst):\n    result={}\n    for item in lst:\n        if item in result:\n            result[item]+=1\n            \n        \n        else :\n            result[item]=1\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/238", "origin_solution": "<def_stmt>number_of_substrings s<block_start>n=len(s)<line_sep><return>n<times>(n+1)<floordiv>2<block_end>\n", "solution": "\ndef number_of_substrings (s):\n    n=len(s)\n    return n*(n+1)//2\n    \n\n"}
{"task_id": "Mbpp/239", "origin_solution": "<def_stmt>get_total_number_of_sequences m n<block_start>dp=[[0<for>_ range(m+1)]<for>_ range(n+1)]<for_stmt>i range(1 m+1)<block_start>dp[1][i]=1<block_end><for_stmt>i range(2 n+1)<block_start><for_stmt>j range(1 m+1)<block_start><for_stmt>k range(1 j)<block_start>dp[i][j]<augadd>dp[i-1][k]<block_end><block_end><block_end><return>dp[n][m]<block_end>\n", "solution": "\ndef get_total_number_of_sequences (m, n):\n    dp=[[0 for _ in range(m+1)] for _ in range(n+1)]\n    for i in range(1, m+1):\n        dp[1][i]=1\n        \n    for i in range(2, n+1):\n        for j in range(1, m+1):\n            for k in range(1, j):\n                dp[i][j]+=dp[i-1][k]\n                \n        \n    \n    return dp[n][m]\n    \n\n"}
{"task_id": "Mbpp/240", "origin_solution": "<def_stmt>replace_list list1 list2<block_start>list1[-1:]=list2<line_sep><return>list1<block_end>\n", "solution": "\ndef replace_list (list1, list2):\n    list1[-1:]=list2\n    return list1\n    \n\n"}
{"task_id": "Mbpp/242", "origin_solution": "<def_stmt>count_charac string<block_start><return>len(string)<block_end>\n", "solution": "\ndef count_charac (string):\n    return len(string)\n    \n\n"}
{"task_id": "Mbpp/244", "origin_solution": "<def_stmt>next_Perfect_Square n<block_start><if_stmt>n<l>0<block_start><return><none><block_end>x=n<line_sep>y=(x+1)<floordiv>2<while_stmt>y<l>x<block_start>x=y<line_sep>y=(x+n<floordiv>x)<floordiv>2<block_end><return>x<times>x<block_end>\n", "solution": "\ndef next_Perfect_Square (n):\n    if n<0:\n        return  None \n        \n    x=n\n    y=(x+1)//2\n    while y<x:\n        x=y\n        y=(x+n//x)//2\n        \n    return x*x\n    \n\n"}
{"task_id": "Mbpp/245", "origin_solution": "<def_stmt>max_sum arr<block_start>n=len(arr)<line_sep>max_sum=0<for_stmt>i range(n)<block_start>left_sum=0<line_sep>right_sum=0<for_stmt>j range(i-1 -1 -1)<block_start>left_sum<augadd>arr[j]<if_stmt>arr[j]<g>arr[j+1]<block_start><break><block_end><block_end><for_stmt>k range(i+1 n)<block_start>right_sum<augadd>arr[k]<if_stmt>arr[k]<g>arr[k-1]<block_start><break><block_end><block_end>max_sum=max(max_sum left_sum+right_sum)<block_end><return>max_sum<block_end>\n", "solution": "\ndef max_sum (arr):\n    n=len(arr)\n    max_sum=0\n    for i in range(n):\n        left_sum=0\n        right_sum=0\n        for j in range(i-1, -1, -1):\n            left_sum+=arr[j]\n            if arr[j]>arr[j+1]:\n                break \n                \n        \n        for k in range(i+1, n):\n            right_sum+=arr[k]\n            if arr[k]>arr[k-1]:\n                break \n                \n        \n        max_sum=max(max_sum, left_sum+right_sum)\n        \n    return max_sum\n    \n\n"}
{"task_id": "Mbpp/247", "origin_solution": "<def_stmt>lps s<block_start>n=len(s)<line_sep>L=[[0<for>x range(n)]<for>x range(n)]<for_stmt>i range(n)<block_start>L[i][i]=1<block_end><for_stmt>cl range(2 n+1)<block_start><for_stmt>i range(n-cl+1)<block_start>j=i+cl-1<if_stmt>s[i]<eq>s[j]<and>cl<eq>2<block_start>L[i][j]=2<block_end><elif_stmt>s[i]<eq>s[j]<block_start>L[i][j]=L[i+1][j-1]+2<block_end><else_stmt><block_start>L[i][j]=max(L[i][j-1] L[i+1][j])<block_end><block_end><block_end><return>L[0][n-1]<block_end>\n", "solution": "\ndef lps (s):\n    n=len(s)\n    L=[[0 for x in range(n)] for x in range(n)]\n    for i in range(n):\n        L[i][i]=1\n        \n    for cl in range(2, n+1):\n        for i in range(n-cl+1):\n            j=i+cl-1\n            if s[i]==s[j] and cl==2:\n                L[i][j]=2\n                \n            \n            elif s[i]==s[j]:\n                L[i][j]=L[i+1][j-1]+2\n                \n            \n            else :\n                L[i][j]=max(L[i][j-1], L[i+1][j])\n                \n        \n    \n    return L[0][n-1]\n    \n\n"}
{"task_id": "Mbpp/250", "origin_solution": "<def_stmt>count_X tuple_X element<block_start><return>tuple_X.count(element)<block_end>\n", "solution": "\ndef count_X (tuple_X, element):\n    return tuple_X.count(element)\n    \n\n"}
{"task_id": "Mbpp/251", "origin_solution": "<def_stmt>insert_element lst element<block_start><return>[element]+lst<block_end>\n", "solution": "\ndef insert_element (lst, element):\n    return [element]+lst\n    \n\n"}
{"task_id": "Mbpp/252", "origin_solution": "<import_stmt>math<def_stmt>convert z<block_start>\"\"\"\n    Convert complex number to polar coordinates.\n    \"\"\"<line_sep><return>(math.sqrt(z.real) math.atan2(z.imag z.real))<block_end>\n", "solution": "\nimport math\ndef convert (z):\n    \"\"\"\n    Convert complex number to polar coordinates.\n    \"\"\"\n    return (math.sqrt(z.real), math.atan2(z.imag, z.real))\n    \n\n"}
{"task_id": "Mbpp/253", "origin_solution": "<def_stmt>count_integer lst<block_start><return>sum(1<for>i lst<if>isinstance(i int))<block_end>\n", "solution": "\ndef count_integer (lst):\n    return sum(1 for i in lst if isinstance(i, int))\n    \n\n"}
{"task_id": "Mbpp/255", "origin_solution": "<import_from_stmt>itertools combinations<def_stmt>combinations_colors lst n<block_start><return>[tuple(comb)<for>comb combinations(lst n)]<block_end>\n", "solution": "\nfrom itertools import combinations\ndef combinations_colors (lst, n):\n    return [tuple(comb) for comb in combinations(lst, n)]\n    \n\n"}
{"task_id": "Mbpp/256", "origin_solution": "<def_stmt>count_Primes_nums n<block_start><if_stmt>n<le>2<block_start><return>0<block_end>primes=[<true>]<times>n<line_sep>primes[0]=primes[1]=<false><for_stmt>i range(2 int(n<power>0.5)+1)<block_start><if_stmt>primes[i]<block_start><for_stmt>j range(i<times>i n i)<block_start>primes[j]=<false><block_end><block_end><block_end><return>sum(primes)<block_end>\n", "solution": "\ndef count_Primes_nums (n):\n    if n<=2:\n        return 0\n        \n    primes=[ True ]*n\n    primes[0]=primes[1]= False \n    for i in range(2, int(n**0.5)+1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j]= False \n                \n        \n    \n    return sum(primes)\n    \n\n"}
{"task_id": "Mbpp/257", "origin_solution": "<def_stmt>swap_numbers a b<block_start><return>b a<block_end>\n", "solution": "\ndef swap_numbers (a, b):\n    return b, a\n    \n\n"}
{"task_id": "Mbpp/259", "origin_solution": "<def_stmt>maximize_elements tuple1 tuple2<block_start>max_tuple1=max(tuple1 key=<lambda>x:x[0])<line_sep>max_tuple2=max(tuple2 key=<lambda>x:x[0])<line_sep><return>(max_tuple1 max_tuple2)<block_end>\n", "solution": "\ndef maximize_elements (tuple1, tuple2):\n    max_tuple1=max(tuple1, key=lambda x:x[0])\n    max_tuple2=max(tuple2, key=lambda x:x[0])\n    return (max_tuple1, max_tuple2)\n    \n\n"}
{"task_id": "Mbpp/260", "origin_solution": "<def_stmt>newman_prime n<block_start><if_stmt>n<eq>1<block_start><return>1<block_end><else_stmt><block_start><return>2<times>n<power>2-1<block_end><block_end>\n", "solution": "\ndef newman_prime (n):\n    if n==1:\n        return 1\n        \n    \n    else :\n        return 2*n**2-1\n        \n\n\n"}
{"task_id": "Mbpp/261", "origin_solution": "<def_stmt>division_elements tuple1 tuple2<block_start>result=tuple(x/y<for>x,y zip(tuple1 tuple2))<line_sep><return>result<block_end>\n", "solution": "\ndef division_elements (tuple1, tuple2):\n    result=tuple(x/y for x,y in zip(tuple1, tuple2))\n    return result\n    \n\n"}
{"task_id": "Mbpp/262", "origin_solution": "<def_stmt>split_two_parts lst L<block_start>part1=lst[:L]<line_sep>part2=lst[L:]<line_sep><return>(part1 part2)<block_end>\n", "solution": "\ndef split_two_parts (lst, L):\n    part1=lst[:L]\n    part2=lst[L:]\n    return (part1, part2)\n    \n\n"}
{"task_id": "Mbpp/264", "origin_solution": "<def_stmt>dog_age breed<block_start><return>breed<times>3+10<block_end>\n", "solution": "\ndef dog_age (breed):\n    return breed*3+10\n    \n\n"}
{"task_id": "Mbpp/265", "origin_solution": "<def_stmt>list_split lst n<block_start>result=[]<for_stmt>i range(0 len(lst) n)<block_start>result.append(lst[i:i+n])<block_end><return>result<block_end>\n", "solution": "\ndef list_split (lst, n):\n    result=[]\n    for i in range(0, len(lst), n):\n        result.append(lst[i:i+n])\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/266", "origin_solution": "<def_stmt>lateralsurface_cube side_length<block_start><return>6<times>side_length<power>2<block_end>\n", "solution": "\ndef lateralsurface_cube (side_length):\n    return 6*side_length**2\n    \n\n"}
{"task_id": "Mbpp/267", "origin_solution": "<def_stmt>square_Sum n<block_start>sum=0<for_stmt>i range(1 2<times>n 2)<block_start>sum<augadd>i<power>2<block_end><return>sum<block_end>\n", "solution": "\ndef square_Sum (n):\n    sum=0\n    for i in range(1, 2*n, 2):\n        sum+=i**2\n        \n    return sum\n    \n\n"}
{"task_id": "Mbpp/268", "origin_solution": "<def_stmt>find_star_num n<block_start><return>n<times>(n+1)<floordiv>2<block_end>\n", "solution": "\ndef find_star_num (n):\n    return n*(n+1)//2\n    \n\n"}
{"task_id": "Mbpp/269", "origin_solution": "<def_stmt>ascii_value char<block_start><return>ord(char)<block_end>\n", "solution": "\ndef ascii_value (char):\n    return ord(char)\n    \n\n"}
{"task_id": "Mbpp/270", "origin_solution": "<def_stmt>sum_even_and_even_index lst<block_start><return>sum(lst[i]<for>i range(0 len(lst) 2)<if>lst[i]%2<eq>0)<block_end>\n", "solution": "\ndef sum_even_and_even_index (lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i]%2==0)\n    \n\n"}
{"task_id": "Mbpp/271", "origin_solution": "<def_stmt>even_Power_Sum n<block_start>sum=0<for_stmt>i range(1 n+1)<block_start>sum<augadd>i<power>5<block_end><return>sum<block_end>\n", "solution": "\ndef even_Power_Sum (n):\n    sum=0\n    for i in range(1, n+1):\n        sum+=i**5\n        \n    return sum\n    \n\n"}
{"task_id": "Mbpp/272", "origin_solution": "<def_stmt>rear_extract lst<block_start><return>[t[-1]<for>t lst]<block_end>\n", "solution": "\ndef rear_extract (lst):\n    return [t[-1] for t in lst]\n    \n\n"}
{"task_id": "Mbpp/273", "origin_solution": "<def_stmt>substract_elements tuple1 tuple2<block_start><return>tuple(a-b<for>a,b zip(tuple1 tuple2))<block_end>\n", "solution": "\ndef substract_elements (tuple1, tuple2):\n    return tuple(a-b for a,b in zip(tuple1, tuple2))\n    \n\n"}
{"task_id": "Mbpp/274", "origin_solution": "<def_stmt>even_binomial_Coeff_Sum n<block_start>result=0<for_stmt>i range(0 n 2)<block_start>result<augadd>2<power>i<block_end><return>result<block_end>\n", "solution": "\ndef even_binomial_Coeff_Sum (n):\n    result=0\n    for i in range(0, n, 2):\n        result+=2**i\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/276", "origin_solution": "<import_stmt>math<def_stmt>volume_cylinder radius height<block_start><return>math.pi<times>radius<power>2<times>height<block_end>\n", "solution": "\nimport math\ndef volume_cylinder (radius, height):\n    return math.pi*radius**2*height\n    \n\n"}
{"task_id": "Mbpp/277", "origin_solution": "<def_stmt>dict_filter d n<block_start><return>{k:v<for>k,v d.items()<if>v<ge>n}<block_end>\n", "solution": "\ndef dict_filter (d, n):\n    return {k:v for k,v in d.items() if v>=n}\n    \n\n"}
{"task_id": "Mbpp/278", "origin_solution": "<def_stmt>count_first_elements t<block_start>count=0<for_stmt>i range(1 len(t))<block_start><if_stmt>t[i]<eq>t[0]<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_first_elements (t):\n    count=0\n    for i in range(1, len(t)):\n        if t[i]==t[0]:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/279", "origin_solution": "<def_stmt>is_num_decagonal n<block_start><return>n<times>(7<times>n-5)<floordiv>2<block_end>\n", "solution": "\ndef is_num_decagonal (n):\n    return n*(7*n-5)//2\n    \n\n"}
{"task_id": "Mbpp/280", "origin_solution": "<def_stmt>sequential_search arr element<block_start><for_stmt>i range(len(arr))<block_start><if_stmt>arr[i]<eq>element<block_start><return><true> i<block_end><block_end><return><false> -1<block_end>\n", "solution": "\ndef sequential_search (arr, element):\n    for i in range(len(arr)):\n        if arr[i]==element:\n            return  True , i\n            \n    \n    return  False , -1\n    \n\n"}
{"task_id": "Mbpp/281", "origin_solution": "<def_stmt>all_unique lst<block_start><return>len(lst)<eq>len(set(lst))<block_end>\n", "solution": "\ndef all_unique (lst):\n    return len(lst)==len(set(lst))\n    \n\n"}
{"task_id": "Mbpp/282", "origin_solution": "<def_stmt>sub_list list1 list2<block_start><return>[a-b<for>a,b zip(list1 list2)]<block_end>\n", "solution": "\ndef sub_list (list1, list2):\n    return [a-b for a,b in zip(list1, list2)]\n    \n\n"}
{"task_id": "Mbpp/283", "origin_solution": "<def_stmt>validate num<block_start>num_str=str(num)<for_stmt>digit num_str<block_start><if_stmt>num_str.count(digit)<g>digit<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef validate (num):\n    num_str=str(num)\n    for digit in num_str:\n        if num_str.count(digit)>digit:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/284", "origin_solution": "<def_stmt>check_element lst element<block_start><return>all(x<eq>element<for>x lst)<block_end>\n", "solution": "\ndef check_element (lst, element):\n    return all(x==element for x in lst)\n    \n\n"}
{"task_id": "Mbpp/285", "origin_solution": "<def_stmt>text_match_two_three text<block_start>count=0<for_stmt>i range(len(text)-1)<block_start><if_stmt>text[i]<eq>'a'<and>text[i+1]<eq>'b'<block_start>count<augadd>1<block_end><block_end><return>count<ge>2<block_end>\n", "solution": "\ndef text_match_two_three (text):\n    count=0\n    for i in range(len(text)-1):\n        if text[i]=='a' and text[i+1]=='b':\n            count+=1\n            \n    \n    return count>=2\n    \n\n"}
{"task_id": "Mbpp/286", "origin_solution": "<def_stmt>max_sub_array_sum_repeated arr k n<block_start><def_stmt>kadane arr<block_start>max_ending_here=max_so_far=arr[0]<for_stmt>x arr[1:]<block_start>max_ending_here=max(x max_ending_here+x)<line_sep>max_so_far=max(max_so_far max_ending_here)<block_end><return>max_so_far<block_end><def_stmt>max_prefix_sum arr<block_start>max_sum=0<line_sep>prefix_sum=0<for_stmt>x arr<block_start>prefix_sum<augadd>x<line_sep>max_sum=max(max_sum prefix_sum)<block_end><return>max_sum<block_end><def_stmt>max_suffix_sum arr<block_start>max_sum=0<line_sep>suffix_sum=0<for_stmt>x reversed(arr)<block_start>suffix_sum<augadd>x<line_sep>max_sum=max(max_sum suffix_sum)<block_end><return>max_sum<block_end><def_stmt>max_subarray_sum arr<block_start>max_sum=0<line_sep>current_sum=0<for_stmt>x arr<block_start>current_sum<augadd>x<line_sep>max_sum=max(max_sum current_sum)<block_end><return>max_sum<block_end><def_stmt>max_subarray_sum_repeated arr k<block_start><if_stmt>k<eq>1<block_start><return>kadane(arr)<block_end><if_stmt>k<eq>2<block_start><return>max(kadane(arr) max_prefix_sum(arr) max_suffix_sum(arr))<block_end><if_stmt>k<eq>3<block_start><return>max(max_subarray_sum(arr) max_subarray_sum_repeated(arr[:-1] k-1) max_subarray_sum_repeated(arr[1:] k-1))<block_end>max_sum=float('-inf')<for_stmt>i range(len(arr))<block_start><if_stmt>i<eq>0<block_start>max_sum=max(max_sum max_subarray_sum_repeated(arr[i:] k-1))<block_end><elif_stmt>i<eq>len(arr)-1<block_start>max_sum=max(max_sum max_subarray_sum_repeated(arr[:i+1] k-1))<block_end><else_stmt><block_start>max_sum=max(max_sum max_subarray_sum_repeated(arr[:i+1] k-1) max_subarray_sum_repeated(arr[i+1:] k-1) max_subarray_sum_repeated(arr[:i] k-1))<block_end><block_end><return>max_sum", "solution": "\ndef max_sub_array_sum_repeated arr k n\n    def kadane (arr):\n        max_ending_here=max_so_far=arr[0]\n        for x in arr[1:]:\n            max_ending_here=max(x, max_ending_here+x)\n            max_so_far=max(max_so_far, max_ending_here)\n            \n        return max_so_far\n        \n    def max_prefix_sum (arr):\n        max_sum=0\n        prefix_sum=0\n        for x in arr:\n            prefix_sum+=x\n            max_sum=max(max_sum, prefix_sum)\n            \n        return max_sum\n        \n    def max_suffix_sum (arr):\n        max_sum=0\n        suffix_sum=0\n        for x in reversed(arr):\n            suffix_sum+=x\n            max_sum=max(max_sum, suffix_sum)\n            \n        return max_sum\n        \n    def max_subarray_sum (arr):\n        max_sum=0\n        current_sum=0\n        for x in arr:\n            current_sum+=x\n            max_sum=max(max_sum, current_sum)\n            \n        return max_sum\n        \n    def max_subarray_sum_repeated arr k\n        if k==1:\n            return kadane(arr)\n            \n        if k==2:\n            return max(kadane(arr), max_prefix_sum(arr), max_suffix_sum(arr))\n            \n        if k==3:\n            return max(max_subarray_sum(arr), max_subarray_sum_repeated(arr[:-1], k-1), max_subarray_sum_repeated(arr[1:], k-1))\n            \n        max_sum=float('-inf')\n        for i in range(len(arr)):\n            if i==0:\n                max_sum=max(max_sum, max_subarray_sum_repeated(arr[i:], k-1))\n                \n            \n            elif i==len(arr)-1:\n                max_sum=max(max_sum, max_subarray_sum_repeated(arr[:i+1], k-1))\n                \n            \n            else :\n                max_sum=max(max_sum, max_subarray_sum_repeated(arr[:i+1], k-1), max_subarray_sum_repeated(arr[i+1:], k-1), max_subarray_sum_repeated(arr[:i], k-1))\n                \n        \n        return max_sum"}
{"task_id": "Mbpp/287", "origin_solution": "<def_stmt>square_Sum n<block_start>sum=0<for_stmt>i range(1 n+1)<block_start>even_num=2<times>i<line_sep>sum<augadd>even_num<power>2<block_end><return>sum<block_end>\n", "solution": "\ndef square_Sum (n):\n    sum=0\n    for i in range(1, n+1):\n        even_num=2*i\n        sum+=even_num**2\n        \n    return sum\n    \n\n"}
{"task_id": "Mbpp/290", "origin_solution": "<def_stmt>max_length list_of_lists<block_start>max_length=0<line_sep>max_list=[]<for_stmt>sublist list_of_lists<block_start><if_stmt>len(sublist)<g>max_length<block_start>max_length=len(sublist)<line_sep>max_list=sublist<block_end><block_end><return>max_length max_list<block_end>\n", "solution": "\ndef max_length (list_of_lists):\n    max_length=0\n    max_list=[]\n    for sublist in list_of_lists:\n        if len(sublist)>max_length:\n            max_length=len(sublist)\n            max_list=sublist\n            \n    \n    return max_length, max_list\n    \n\n"}
{"task_id": "Mbpp/292", "origin_solution": "<def_stmt>find a b<block_start><return>a<floordiv>b<block_end>\n", "solution": "\ndef find (a, b):\n    return a//b\n    \n\n"}
{"task_id": "Mbpp/293", "origin_solution": "<import_stmt>math<def_stmt>otherside_rightangle a b<block_start><return>math.sqrt(a<power>2+b<power>2)<block_end>\n", "solution": "\nimport math\ndef otherside_rightangle (a, b):\n    return math.sqrt(a**2+b**2)\n    \n\n"}
{"task_id": "Mbpp/294", "origin_solution": "<def_stmt>max_val lst<block_start>max_val=lst[0]<for_stmt>i lst<block_start><if_stmt>i<g>max_val<block_start>max_val=i<block_end><block_end><return>max_val<block_end>\n", "solution": "\ndef max_val (lst):\n    max_val=lst[0]\n    for i in lst:\n        if i>max_val:\n            max_val=i\n            \n    \n    return max_val\n    \n\n"}
{"task_id": "Mbpp/296", "origin_solution": "<def_stmt>get_Inv_Count arr<block_start>inv_count=0<for_stmt>i range(len(arr))<block_start><for_stmt>j range(i+1 len(arr))<block_start><if_stmt>arr[i]<g>arr[j]<block_start>inv_count<augadd>1<block_end><block_end><block_end><return>inv_count<block_end>\n", "solution": "\ndef get_Inv_Count (arr):\n    inv_count=0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]>arr[j]:\n                inv_count+=1\n                \n        \n    \n    return inv_count\n    \n\n"}
{"task_id": "Mbpp/297", "origin_solution": "<def_stmt>flatten_list nested_list<block_start>flattened=[]<for_stmt>item nested_list<block_start><if_stmt>isinstance(item list)<block_start>flattened.extend(flatten_list(item))<block_end><else_stmt><block_start>flattened.append(item)<block_end><block_end><return>flattened<block_end>\n", "solution": "\ndef flatten_list (nested_list):\n    flattened=[]\n    for item in nested_list:\n        if isinstance(item, list):\n            flattened.extend(flatten_list(item))\n            \n        \n        else :\n            flattened.append(item)\n            \n    \n    return flattened\n    \n\n"}
{"task_id": "Mbpp/299", "origin_solution": "<def_stmt>max_aggregate lst<block_start>max_key=lst[0][0]<line_sep>max_value=lst[0][1]<for_stmt>item lst<block_start><if_stmt>item[1]<g>max_value<block_start>max_key=item[0]<line_sep>max_value=item[1]<block_end><block_end><return>(max_key max_value)<block_end>\n", "solution": "\ndef max_aggregate (lst):\n    max_key=lst[0][0]\n    max_value=lst[0][1]\n    for item in lst:\n        if item[1]>max_value:\n            max_key=item[0]\n            max_value=item[1]\n            \n    \n    return (max_key, max_value)\n    \n\n"}
{"task_id": "Mbpp/300", "origin_solution": "<import_stmt>math<def_stmt>count_binary_seq n<block_start><return>2<power>n<block_end>\n", "solution": "\nimport math\ndef count_binary_seq (n):\n    return 2**n\n    \n\n"}
{"task_id": "Mbpp/301", "origin_solution": "<def_stmt>dict_depth d<block_start><if_stmt><not>isinstance(d dict)<or><not>d<block_start><return>0<block_end><return>1+max(dict_depth(v)<for>v d.values())<block_end>\n", "solution": "\ndef dict_depth (d):\n    if  not isinstance(d, dict) or  not d:\n        return 0\n        \n    return 1+max(dict_depth(v) for v in d.values())\n    \n\n"}
{"task_id": "Mbpp/305", "origin_solution": "<def_stmt>start_withp words<block_start>p_words=[word.split()[0]<for>word words<if>word.split()[0].startswith('p')]<line_sep><return>p_words[0] p_words[1]<block_end>\n", "solution": "\ndef start_withp (words):\n    p_words=[word.split()[0] for word in words if word.split()[0].startswith('p')]\n    return p_words[0], p_words[1]\n    \n\n"}
{"task_id": "Mbpp/306", "origin_solution": "<def_stmt>max_sum_increasing_subseq nums k i<block_start>n=len(nums)<line_sep>dp=[0]<times>n<line_sep>dp[0]=nums[0]<for_stmt>j range(1 n)<block_start>dp[j]=nums[j]<for_stmt>m range(j)<block_start><if_stmt>nums[j]<g>nums[m]<and>dp[j]<l>dp[m]+nums[j]<block_start>dp[j]=dp[m]+nums[j]<block_end><block_end><block_end>max_sum=0<for_stmt>l range(i+1 n)<block_start>max_sum=max(max_sum dp[l])<block_end><return>max_sum<block_end>\n", "solution": "\ndef max_sum_increasing_subseq (nums, k, i):\n    n=len(nums)\n    dp=[0]*n\n    dp[0]=nums[0]\n    for j in range(1, n):\n        dp[j]=nums[j]\n        for m in range(j):\n            if nums[j]>nums[m] and dp[j]<dp[m]+nums[j]:\n                dp[j]=dp[m]+nums[j]\n                \n        \n    \n    max_sum=0\n    for l in range(i+1, n):\n        max_sum=max(max_sum, dp[l])\n        \n    return max_sum\n    \n\n"}
{"task_id": "Mbpp/308", "origin_solution": "<def_stmt>large_product nums1 nums2 k<block_start>nums1.sort(reverse=<true>)<line_sep>nums2.sort(reverse=<true>)<line_sep>result=[]<for_stmt>i range(len(nums1))<block_start><for_stmt>j range(len(nums2))<block_start>product=nums1[i]<times>nums2[j]<if_stmt>len(result)<l>k<block_start>result.append(product)<block_end><else_stmt><block_start><break><block_end><block_end><block_end><return>result<block_end>\n", "solution": "\ndef large_product (nums1, nums2, k):\n    nums1.sort(reverse= True )\n    nums2.sort(reverse= True )\n    result=[]\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            product=nums1[i]*nums2[j]\n            if len(result)<k:\n                result.append(product)\n                \n            \n            else :\n                break \n                \n        \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/309", "origin_solution": "<def_stmt>maximum a b<block_start><if_stmt>a<g>b<block_start><return>a<block_end><else_stmt><block_start><return>b<block_end><block_end>\n", "solution": "\ndef maximum (a, b):\n    if a>b:\n        return a\n        \n    \n    else :\n        return b\n        \n\n\n"}
{"task_id": "Mbpp/310", "origin_solution": "<def_stmt>string_to_tuple string<block_start><return>tuple(string)<block_end>\n", "solution": "\ndef string_to_tuple (string):\n    return tuple(string)\n    \n\n"}
{"task_id": "Mbpp/311", "origin_solution": "<def_stmt>set_left_most_unset_bit n<block_start><return>n|(n+1)<block_end>\n", "solution": "\ndef set_left_most_unset_bit (n):\n    return n|(n+1)\n    \n\n"}
{"task_id": "Mbpp/312", "origin_solution": "<import_stmt>math<def_stmt>volume_cone radius height<block_start><return>(1/3)<times>math.pi<times>radius<power>2<times>height<block_end>\n", "solution": "\nimport math\ndef volume_cone (radius, height):\n    return (1/3)*math.pi*radius**2*height\n    \n\n"}
{"task_id": "Mbpp/388", "origin_solution": "<def_stmt>highest_Power_of_2 n<block_start>power=1<while_stmt>power<times>2<le>n<block_start>power<augmul>2<block_end><return>power<block_end>\n", "solution": "\ndef highest_Power_of_2 (n):\n    power=1\n    while power*2<=n:\n        power*=2\n        \n    return power\n    \n\n"}
{"task_id": "Mbpp/389", "origin_solution": "<def_stmt>find_lucas n<block_start><if_stmt>n<eq>0<block_start><return>2<block_end><elif_stmt>n<eq>1<block_start><return>1<block_end><else_stmt><block_start>a,b=2 1<for_stmt>_ range(2 n+1)<block_start>a,b=b a+b<block_end><return>b<block_end><block_end>\n", "solution": "\ndef find_lucas (n):\n    if n==0:\n        return 2\n        \n    \n    elif n==1:\n        return 1\n        \n    \n    else :\n        a,b=2, 1\n        for _ in range(2, n+1):\n            a,b=b, a+b\n            \n        return b\n        \n\n\n"}
{"task_id": "Mbpp/390", "origin_solution": "<def_stmt>add_string lst fmt<block_start><return>[fmt.format(i)<for>i lst]<block_end>\n", "solution": "\ndef add_string (lst, fmt):\n    return [fmt.format(i) for i in lst]\n    \n\n"}
{"task_id": "Mbpp/391", "origin_solution": "<def_stmt>convert_list_dictionary list1 list2 list3<block_start><return>[{i:dict(zip(list1 list3))}<for>i range(len(list1))]<block_end>\n", "solution": "\ndef convert_list_dictionary (list1, list2, list3):\n    return [{i:dict(zip(list1, list3))} for i in range(len(list1))]\n    \n\n"}
{"task_id": "Mbpp/392", "origin_solution": "<def_stmt>get_max_sum n<block_start><if_stmt>n<le>2<block_start><return>n<block_end>f=[0]<times>(n+1)<line_sep>f[1]=1<line_sep>f[2]=2<line_sep>f[3]=4<line_sep>f[4]=7<for_stmt>i range(5 n+1)<block_start>f[i]=max(f[i<floordiv>2]+f[i<floordiv>3]+f[i<floordiv>4]+f[i<floordiv>5] i)<block_end><return>f[n]<block_end>\n", "solution": "\ndef get_max_sum (n):\n    if n<=2:\n        return n\n        \n    f=[0]*(n+1)\n    f[1]=1\n    f[2]=2\n    f[3]=4\n    f[4]=7\n    for i in range(5, n+1):\n        f[i]=max(f[i//2]+f[i//3]+f[i//4]+f[i//5], i)\n        \n    return f[n]\n    \n\n"}
{"task_id": "Mbpp/394", "origin_solution": "<def_stmt>check_distinct t<block_start><return>len(t)<eq>len(set(t))<block_end>\n", "solution": "\ndef check_distinct (t):\n    return len(t)==len(set(t))\n    \n\n"}
{"task_id": "Mbpp/395", "origin_solution": "<def_stmt>first_non_repeating_character s<block_start>char_count={}<for_stmt>char s<block_start><if_stmt>char<in>char_count<block_start>char_count[char]<augadd>1<block_end><else_stmt><block_start>char_count[char]=1<block_end><block_end><for_stmt>char s<block_start><if_stmt>char_count[char]<eq>1<block_start><return>char<block_end><block_end><return><none><block_end>\n", "solution": "\ndef first_non_repeating_character (s):\n    char_count={}\n    for char in s:\n        if char in char_count:\n            char_count[char]+=1\n            \n        \n        else :\n            char_count[char]=1\n            \n    \n    for char in s:\n        if char_count[char]==1:\n            return char\n            \n    \n    return  None \n    \n\n"}
{"task_id": "Mbpp/397", "origin_solution": "<def_stmt>median_numbers a b c<block_start>numbers=[a b c]<line_sep>numbers.sort()<line_sep><return>numbers[1]<block_end>\n", "solution": "\ndef median_numbers (a, b, c):\n    numbers=[a, b, c]\n    numbers.sort()\n    return numbers[1]\n    \n\n"}
{"task_id": "Mbpp/398", "origin_solution": "<def_stmt>sum_of_digits lst<block_start><return>sum(sum(int(digit)<for>digit str(num))<for>num lst)<block_end>\n", "solution": "\ndef sum_of_digits (lst):\n    return sum(sum(int(digit) for digit in str(num)) for num in lst)\n    \n\n"}
{"task_id": "Mbpp/404", "origin_solution": "<def_stmt>minimum a b<block_start><if_stmt>a<l>b<block_start><return>a<block_end><else_stmt><block_start><return>b<block_end><block_end>\n", "solution": "\ndef minimum (a, b):\n    if a<b:\n        return a\n        \n    \n    else :\n        return b\n        \n\n\n"}
{"task_id": "Mbpp/405", "origin_solution": "<def_stmt>check_tuplex tuplex element<block_start><return>element<in>tuplex<block_end>\n", "solution": "\ndef check_tuplex (tuplex, element):\n    return element in tuplex\n    \n\n"}
{"task_id": "Mbpp/406", "origin_solution": "<def_stmt>find_Parity num<block_start><return>num%2<ne>0<block_end>\n", "solution": "\ndef find_Parity (num):\n    return num%2!=0\n    \n\n"}
{"task_id": "Mbpp/409", "origin_solution": "<def_stmt>min_product_tuple lst<block_start>min_product=float('inf')<for_stmt>pair lst<block_start>product=pair[0]<times>pair[1]<if_stmt>product<l>min_product<block_start>min_product=product<block_end><block_end><return>min_product<block_end>\n", "solution": "\ndef min_product_tuple (lst):\n    min_product=float('inf')\n    for pair in lst:\n        product=pair[0]*pair[1]\n        if product<min_product:\n            min_product=product\n            \n    \n    return min_product\n    \n\n"}
{"task_id": "Mbpp/410", "origin_solution": "<def_stmt>min_val lst<block_start>min_val=lst[0]<for_stmt>i lst<block_start><if_stmt>i<l>min_val<block_start>min_val=i<block_end><block_end><return>min_val<block_end>\n", "solution": "\ndef min_val (lst):\n    min_val=lst[0]\n    for i in lst:\n        if i<min_val:\n            min_val=i\n            \n    \n    return min_val\n    \n\n"}
{"task_id": "Mbpp/412", "origin_solution": "<def_stmt>remove_odd lst<block_start><return>[num<for>num lst<if>num%2<eq>0]<block_end>\n", "solution": "\ndef remove_odd (lst):\n    return [num for num in lst if num%2==0]\n    \n\n"}
{"task_id": "Mbpp/413", "origin_solution": "<def_stmt>extract_nth_element test_list n<block_start><return>[sub[n]<for>sub test_list]<block_end>\n", "solution": "\ndef extract_nth_element (test_list, n):\n    return [sub[n] for sub in test_list]\n    \n\n"}
{"task_id": "Mbpp/414", "origin_solution": "<def_stmt>overlapping seq1 seq2<block_start><for_stmt>i seq1<block_start><if_stmt>i<in>seq2<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef overlapping (seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/415", "origin_solution": "<def_stmt>max_Product arr<block_start><if_stmt>len(arr)<l>2<block_start><return><none><block_end>max_product=arr[0]<times>arr[1]<for_stmt>i range(len(arr))<block_start><for_stmt>j range(i+1 len(arr))<block_start><if_stmt>arr[i]<times>arr[j]<g>max_product<block_start>max_product=arr[i]<times>arr[j]<block_end><block_end><block_end><return>(max_product )<block_end>\n", "solution": "\ndef max_Product (arr):\n    if len(arr)<2:\n        return  None \n        \n    max_product=arr[0]*arr[1]\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]*arr[j]>max_product:\n                max_product=arr[i]*arr[j]\n                \n        \n    \n    return (max_product, )\n    \n\n"}
{"task_id": "Mbpp/418", "origin_solution": "<def_stmt>Find_Max lst<block_start>max_length=0<line_sep>max_element=<none><for_stmt>sublist lst<block_start><if_stmt>len(sublist)<g>max_length<block_start>max_length=len(sublist)<line_sep>max_element=sublist<block_end><block_end><return>max_element<block_end>\n", "solution": "\ndef Find_Max (lst):\n    max_length=0\n    max_element= None \n    for sublist in lst:\n        if len(sublist)>max_length:\n            max_length=len(sublist)\n            max_element=sublist\n            \n    \n    return max_element\n    \n\n"}
{"task_id": "Mbpp/419", "origin_solution": "<def_stmt>round_and_sum numbers<block_start>total=sum(round(num)<for>num numbers)<line_sep>print(total<times>len(numbers))<block_end>\n", "solution": "\ndef round_and_sum (numbers):\n    total=sum(round(num) for num in numbers)\n    print(total*len(numbers))\n    \n\n"}
{"task_id": "Mbpp/420", "origin_solution": "<def_stmt>cube_Sum n<block_start>sum=0<for_stmt>i range(1 n+1)<block_start>sum<augadd>i<power>3<block_end><return>sum<block_end>\n", "solution": "\ndef cube_Sum (n):\n    sum=0\n    for i in range(1, n+1):\n        sum+=i**3\n        \n    return sum\n    \n\n"}
{"task_id": "Mbpp/421", "origin_solution": "<def_stmt>concatenate_tuple t<block_start><return>\"-\".join(map(str t))<block_end>\n", "solution": "\ndef concatenate_tuple (t):\n    return \"-\".join(map(str, t))\n    \n\n"}
{"task_id": "Mbpp/422", "origin_solution": "<def_stmt>find_Average_Of_Cube n<block_start>sum_of_cubes=0<for_stmt>i range(1 n+1)<block_start>sum_of_cubes<augadd>i<power>3<block_end><return>sum_of_cubes/n<block_end>\n", "solution": "\ndef find_Average_Of_Cube (n):\n    sum_of_cubes=0\n    for i in range(1, n+1):\n        sum_of_cubes+=i**3\n        \n    return sum_of_cubes/n\n    \n\n"}
{"task_id": "Mbpp/424", "origin_solution": "<def_stmt>extract_rear strings<block_start><return>[s[-1]<for>s strings]<block_end>\n", "solution": "\ndef extract_rear (strings):\n    return [s[-1] for s in strings]\n    \n\n"}
{"task_id": "Mbpp/425", "origin_solution": "<def_stmt>count_element_in_list list1 element<block_start>count=0<for_stmt>sublist list1<block_start><if_stmt>element<in>sublist<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_element_in_list (list1, element):\n    count=0\n    for sublist in list1:\n        if element in sublist:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/426", "origin_solution": "<def_stmt>filter_oddnumbers numbers<block_start><return>[num<for>num numbers<if>num%2<ne>0]<block_end>\n", "solution": "\ndef filter_oddnumbers (numbers):\n    return [num for num in numbers if num%2!=0]\n    \n\n"}
{"task_id": "Mbpp/427", "origin_solution": "<def_stmt>change_date_format date<block_start>year,month,day=map(int date.split('-'))<line_sep><return>'{}-{}-{}'.format(day month year)<block_end>\n", "solution": "\ndef change_date_format (date):\n    year,month,day=map(int, date.split('-'))\n    return '{}-{}-{}'.format(day, month, year)\n    \n\n"}
{"task_id": "Mbpp/428", "origin_solution": "<def_stmt>shell_sort arr<block_start>gap=len(arr)<floordiv>2<while_stmt>gap<g>0<block_start><for_stmt>i range(gap len(arr))<block_start>temp=arr[i]<line_sep>j=i<while_stmt>j<ge>gap<and>arr[j-gap]<g>temp<block_start>arr[j]=arr[j-gap]<line_sep>j<augsub>gap<block_end>arr[j]=temp<block_end>gap<augfloordiv>2<block_end><return>arr<block_end>\n", "solution": "\ndef shell_sort (arr):\n    gap=len(arr)//2\n    while gap>0:\n        for i in range(gap, len(arr)):\n            temp=arr[i]\n            j=i\n            while j>=gap and arr[j-gap]>temp:\n                arr[j]=arr[j-gap]\n                j-=gap\n                \n            arr[j]=temp\n            \n        gap//=2\n        \n    return arr\n    \n\n"}
{"task_id": "Mbpp/429", "origin_solution": "<def_stmt>and_tuples t1 t2<block_start><return>tuple(x+y<for>x,y zip(t1 t2))<block_end>\n", "solution": "\ndef and_tuples (t1, t2):\n    return tuple(x+y for x,y in zip(t1, t2))\n    \n\n"}
{"task_id": "Mbpp/430", "origin_solution": "<def_stmt>parabola_directrix a b c<block_start><return>(b<power>2-4<times>a<times>c)/(2<times>a)<block_end>\n", "solution": "\ndef parabola_directrix (a, b, c):\n    return (b**2-4*a*c)/(2*a)\n    \n\n"}
{"task_id": "Mbpp/432", "origin_solution": "<def_stmt>median_trapezium a b c<block_start><return>(a+b+c)/2<block_end>\n", "solution": "\ndef median_trapezium (a, b, c):\n    return (a+b+c)/2\n    \n\n"}
{"task_id": "Mbpp/433", "origin_solution": "<def_stmt>check_greater arr num<block_start><return>all(x<g>num<for>x arr)<block_end>\n", "solution": "\ndef check_greater (arr, num):\n    return all(x>num for x in arr)\n    \n\n"}
{"task_id": "Mbpp/435", "origin_solution": "<def_stmt>last_Digit num<block_start><return>num%10<block_end>\n", "solution": "\ndef last_Digit (num):\n    return num%10\n    \n\n"}
{"task_id": "Mbpp/436", "origin_solution": "<def_stmt>neg_nos nums<block_start><return>[num<for>num nums<if>num<l>0]<block_end>\n", "solution": "\ndef neg_nos (nums):\n    return [num for num in nums if num<0]\n    \n\n"}
{"task_id": "Mbpp/437", "origin_solution": "<def_stmt>remove_odd string<block_start><return>''.join(c<for>c string<if>c.isalpha())<block_end>\n", "solution": "\ndef remove_odd (string):\n    return ''.join(c for c in string if c.isalpha())\n    \n\n"}
{"task_id": "Mbpp/439", "origin_solution": "<def_stmt>multiple_to_single numbers<block_start>\"\"\"\n    Join a list of multiple integers into a single integer.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        int: A single integer formed by joining the list of integers.\n\n    Examples:\n        >>> multiple_to_single([11, 33, 50])\n        113350\n        >>> multiple_to_single([-1,2,3,4,5,6])\n        -123456\n        >>> multiple_to_single([10,15,20,25])\n        10152025\n    \"\"\"<line_sep><return>int(''.join(map(str numbers)))<block_end>\n", "solution": "\ndef multiple_to_single (numbers):\n    \"\"\"\n    Join a list of multiple integers into a single integer.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        int: A single integer formed by joining the list of integers.\n\n    Examples:\n        >>> multiple_to_single([11, 33, 50])\n        113350\n        >>> multiple_to_single([-1,2,3,4,5,6])\n        -123456\n        >>> multiple_to_single([10,15,20,25])\n        10152025\n    \"\"\"\n    return int(''.join(map(str, numbers)))\n    \n\n"}
{"task_id": "Mbpp/440", "origin_solution": "<def_stmt>find_adverb_position sentence<block_start>adverbs=['clearly' 'seriously' 'unfortunately' 'seriously!!' 'unfortunately!!' 'seriously!!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!' 'seriously!!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' '", "solution": "\ndef find_adverb_position sentence\n    adverbs=['clearly' 'seriously' 'unfortunately' 'seriously!!' 'unfortunately!!' 'seriously!!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!' 'seriously!!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' 'unfortunately!!!' 'seriously!!' '"}
{"task_id": "Mbpp/441", "origin_solution": "<def_stmt>surfacearea_cube side_length<block_start><return>6<times>(side_length<power>2)<block_end>\n", "solution": "\ndef surfacearea_cube (side_length):\n    return 6*(side_length**2)\n    \n\n"}
{"task_id": "Mbpp/445", "origin_solution": "<def_stmt>index_multiplication test_tup1 test_tup2<block_start>res=tuple(tuple(a<times>b<for>a,b zip(tup1 tup2))<for>tup1,tup2 zip(test_tup1 test_tup2))<line_sep><return>res<block_end>\n", "solution": "\ndef index_multiplication (test_tup1, test_tup2):\n    res=tuple(tuple(a*b for a,b in zip(tup1, tup2)) for tup1,tup2 in zip(test_tup1, test_tup2))\n    return res\n    \n\n"}
{"task_id": "Mbpp/446", "origin_solution": "<def_stmt>count_Occurrence t lst<block_start><return>sum(t.count(i)<for>i lst)<block_end>\n", "solution": "\ndef count_Occurrence (t, lst):\n    return sum(t.count(i) for i in lst)\n    \n\n"}
{"task_id": "Mbpp/447", "origin_solution": "<def_stmt>cube_nums nums<block_start><return>[num<power>3<for>num nums]<block_end>\n", "solution": "\ndef cube_nums (nums):\n    return [num**3 for num in nums]\n    \n\n"}
{"task_id": "Mbpp/448", "origin_solution": "<def_stmt>cal_sum n<block_start>\"\"\"\n    Calculate the sum of the first n perrin numbers.\n    \"\"\"<line_sep>sum=0<for_stmt>i range(1 n+1)<block_start>sum<augadd>i<times>(i+1)<floordiv>2<block_end><return>sum<block_end>\n", "solution": "\ndef cal_sum (n):\n    \"\"\"\n    Calculate the sum of the first n perrin numbers.\n    \"\"\"\n    sum=0\n    for i in range(1, n+1):\n        sum+=i*(i+1)//2\n        \n    return sum\n    \n\n"}
{"task_id": "Mbpp/450", "origin_solution": "<def_stmt>extract_string values size<block_start><return>values[:size]<block_end>\n", "solution": "\ndef extract_string (values, size):\n    return values[:size]\n    \n\n"}
{"task_id": "Mbpp/451", "origin_solution": "<def_stmt>remove_whitespaces s<block_start><return>s.replace(' ' '')<block_end>\n", "solution": "\ndef remove_whitespaces (s):\n    return s.replace(' ', '')\n    \n\n"}
{"task_id": "Mbpp/453", "origin_solution": "<def_stmt>sumofFactors n<block_start>sum=0<for_stmt>i range(1 n+1)<block_start><if_stmt>n%i<eq>0<and>i%2<eq>0<block_start>sum<augadd>i<block_end><block_end><return>sum<block_end>\n", "solution": "\ndef sumofFactors (n):\n    sum=0\n    for i in range(1, n+1):\n        if n%i==0 and i%2==0:\n            sum+=i\n            \n    \n    return sum\n    \n\n"}
{"task_id": "Mbpp/454", "origin_solution": "<import_stmt>re<def_stmt>text_match_wordz text<block_start><return>bool(re.search(r'\\Bz\\b' text))<block_end>\n", "solution": "\nimport re\ndef text_match_wordz (text):\n    return bool(re.search(r'\\Bz\\b', text))\n    \n\n"}
{"task_id": "Mbpp/455", "origin_solution": "<def_stmt>check_monthnumb_number num<block_start><if_stmt>num<in>[1 3 5 7 8 10 12]<block_start><return><true><block_end><else_stmt><block_start><return><false><block_end><block_end>\n", "solution": "\ndef check_monthnumb_number (num):\n    if num in [1, 3, 5, 7, 8, 10, 12]:\n        return  True \n        \n    \n    else :\n        return  False \n        \n\n\n"}
{"task_id": "Mbpp/456", "origin_solution": "<def_stmt>reverse_string_list string_list<block_start><return>[s[::-1]<for>s string_list]<block_end>\n", "solution": "\ndef reverse_string_list (string_list):\n    return [s[::-1] for s in string_list]\n    \n\n"}
{"task_id": "Mbpp/457", "origin_solution": "<def_stmt>Find_Min lst<block_start>min_length=min(len(x)<for>x lst)<line_sep>min_list=min(lst key=<lambda>x:len(x))<line_sep><return>min_list<block_end>\n", "solution": "\ndef Find_Min (lst):\n    min_length=min(len(x) for x in lst)\n    min_list=min(lst, key=lambda x:len(x))\n    return min_list\n    \n\n"}
{"task_id": "Mbpp/458", "origin_solution": "<def_stmt>rectangle_area length width<block_start><return>length<times>width<block_end>\n", "solution": "\ndef rectangle_area (length, width):\n    return length*width\n    \n\n"}
{"task_id": "Mbpp/459", "origin_solution": "<def_stmt>remove_uppercase s<block_start>result=''<for_stmt>char s<block_start><if_stmt>char.islower()<block_start>result<augadd>char<block_end><block_end><return>result<block_end>\n", "solution": "\ndef remove_uppercase (s):\n    result=''\n    for char in s:\n        if char.islower():\n            result+=char\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/460", "origin_solution": "<def_stmt>Extract lst<block_start><return>[sub[0]<for>sub lst]<block_end>\n", "solution": "\ndef Extract (lst):\n    return [sub[0] for sub in lst]\n    \n\n"}
{"task_id": "Mbpp/462", "origin_solution": "<def_stmt>combinations_list lst<block_start>result=[]<for_stmt>i range(len(lst))<block_start><for_stmt>combination combinations_list_helper(lst i)<block_start>result.append([lst[i]]+combination)<block_end><block_end><return>result<block_end><def_stmt>combinations_list_helper lst i<block_start><if_stmt>i<eq>0<block_start><return>[[]]<block_end><if_stmt>i<eq>len(lst)<block_start><return>[[]]<block_end><if_stmt>lst[i-1]<not><in>lst[i:]<block_start><return>[]<block_end>with_first=[[lst[i-1]]+combination<for>combination combinations_list_helper(lst i-1)]<line_sep>without_first=combinations_list_helper(lst i-1)<line_sep><return>with_first+without_first<block_end>\n", "solution": "\ndef combinations_list (lst):\n    result=[]\n    for i in range(len(lst)):\n        for combination in combinations_list_helper(lst, i):\n            result.append([lst[i]]+combination)\n            \n    \n    return result\n    \ndef combinations_list_helper (lst, i):\n    if i==0:\n        return [[]]\n        \n    if i==len(lst):\n        return [[]]\n        \n    if lst[i-1] not  in lst[i:]:\n        return []\n        \n    with_first=[[lst[i-1]]+combination for combination in combinations_list_helper(lst, i-1)]\n    without_first=combinations_list_helper(lst, i-1)\n    return with_first+without_first\n    \n\n"}
{"task_id": "Mbpp/463", "origin_solution": "<def_stmt>max_subarray_product nums<block_start><if_stmt><not>nums<block_start><return>0<block_end>max_product=min_product=result=nums[0]<for_stmt>i range(1 len(nums))<block_start><if_stmt>nums[i]<l>0<block_start>max_product,min_product=min_product max_product<block_end>max_product=max(nums[i] max_product<times>nums[i])<line_sep>min_product=min(nums[i] min_product<times>nums[i])<line_sep>result=max(result max_product)<block_end><return>result<block_end>\n", "solution": "\ndef max_subarray_product (nums):\n    if  not nums:\n        return 0\n        \n    max_product=min_product=result=nums[0]\n    for i in range(1, len(nums)):\n        if nums[i]<0:\n            max_product,min_product=min_product, max_product\n            \n        max_product=max(nums[i], max_product*nums[i])\n        min_product=min(nums[i], min_product*nums[i])\n        result=max(result, max_product)\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/465", "origin_solution": "<def_stmt>drop_empty d<block_start><return>{k:v<for>k,v d.items()<if>v<is><not><none>}<block_end>\n", "solution": "\ndef drop_empty (d):\n    return {k:v for k,v in d.items() if v is  not  None }\n    \n\n"}
{"task_id": "Mbpp/468", "origin_solution": "<def_stmt>max_product nums<block_start><if_stmt><not>nums<block_start><return>0<block_end>n=len(nums)<line_sep>max_dp=[0]<times>n<line_sep>min_dp=[0]<times>n<line_sep>max_dp[0]=min_dp[0]=nums[0]<for_stmt>i range(1 n)<block_start>max_dp[i]=max(nums[i] max_dp[i-1]<times>nums[i] min_dp[i-1]<times>nums[i])<line_sep>min_dp[i]=min(nums[i] max_dp[i-1]<times>nums[i] min_dp[i-1]<times>nums[i])<block_end><return>max(max_dp)<block_end>\n", "solution": "\ndef max_product (nums):\n    if  not nums:\n        return 0\n        \n    n=len(nums)\n    max_dp=[0]*n\n    min_dp=[0]*n\n    max_dp[0]=min_dp[0]=nums[0]\n    for i in range(1, n):\n        max_dp[i]=max(nums[i], max_dp[i-1]*nums[i], min_dp[i-1]*nums[i])\n        min_dp[i]=min(nums[i], max_dp[i-1]*nums[i], min_dp[i-1]*nums[i])\n        \n    return max(max_dp)\n    \n\n"}
{"task_id": "Mbpp/470", "origin_solution": "<def_stmt>add_pairwise t<block_start><return>tuple(i+j<for>i,j zip(t[:-1] t[1:]))<block_end>\n", "solution": "\ndef add_pairwise (t):\n    return tuple(i+j for i,j in zip(t[:-1], t[1:]))\n    \n\n"}
{"task_id": "Mbpp/471", "origin_solution": "<def_stmt>find_remainder arr n<block_start>product=1<for_stmt>num arr<block_start>product=(product<times>num)%n<block_end><return>product<block_end>\n", "solution": "\ndef find_remainder (arr, n):\n    product=1\n    for num in arr:\n        product=(product*num)%n\n        \n    return product\n    \n\n"}
{"task_id": "Mbpp/472", "origin_solution": "<def_stmt>check_Consecutive lst<block_start><if_stmt>len(lst)<le>1<block_start><return><true><block_end>lst.sort()<for_stmt>i range(len(lst)-1)<block_start><if_stmt>lst[i+1]-lst[i]<ne>1<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef check_Consecutive (lst):\n    if len(lst)<=1:\n        return  True \n        \n    lst.sort()\n    for i in range(len(lst)-1):\n        if lst[i+1]-lst[i]!=1:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/473", "origin_solution": "<def_stmt>tuple_intersection list1 list2<block_start>set1=set(map(tuple list1))<line_sep>set2=set(map(tuple list2))<line_sep><return>set1&set2<block_end>\n", "solution": "\ndef tuple_intersection (list1, list2):\n    set1=set(map(tuple, list1))\n    set2=set(map(tuple, list2))\n    return set1&set2\n    \n\n"}
{"task_id": "Mbpp/474", "origin_solution": "<def_stmt>replace_char string old_char new_char<block_start><return>string.replace(old_char new_char)<block_end>\n", "solution": "\ndef replace_char (string, old_char, new_char):\n    return string.replace(old_char, new_char)\n    \n\n"}
{"task_id": "Mbpp/475", "origin_solution": "<def_stmt>sort_counter counter<block_start><return>sorted(counter.items() key=<lambda>x:x[1])<block_end>\n", "solution": "\ndef sort_counter (counter):\n    return sorted(counter.items(), key=lambda x:x[1])\n    \n\n"}
{"task_id": "Mbpp/476", "origin_solution": "<def_stmt>big_sum arr<block_start><return>max(arr)+min(arr)<block_end>\n", "solution": "\ndef big_sum (arr):\n    return max(arr)+min(arr)\n    \n\n"}
{"task_id": "Mbpp/477", "origin_solution": "<def_stmt>is_lower s<block_start><return>s.lower()<block_end>\n", "solution": "\ndef is_lower (s):\n    return s.lower()\n    \n\n"}
{"task_id": "Mbpp/478", "origin_solution": "<def_stmt>remove_lowercase s<block_start>result=\"\"<for_stmt>char s<block_start><if_stmt><not>char.islower()<block_start>result<augadd>char<block_end><block_end><return>result<block_end>\n", "solution": "\ndef remove_lowercase (s):\n    result=\"\"\n    for char in s:\n        if  not char.islower():\n            result+=char\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/479", "origin_solution": "<def_stmt>first_Digit num<block_start><while_stmt>num<ge>10<block_start>num=num<floordiv>10<block_end><return>num<block_end>\n", "solution": "\ndef first_Digit (num):\n    while num>=10:\n        num=num//10\n        \n    return num\n    \n\n"}
{"task_id": "Mbpp/554", "origin_solution": "<def_stmt>Split lst<block_start><return>[i<for>i lst<if>i%2<ne>0]<block_end>\n", "solution": "\ndef Split (lst):\n    return [i for i in lst if i%2!=0]\n    \n\n"}
{"task_id": "Mbpp/555", "origin_solution": "<def_stmt>difference n<block_start>sum_of_cubes=sum([i<power>3<for>i range(1 n+1)])<line_sep>sum_of_numbers=sum([i<for>i range(1 n+1)])<line_sep><return>sum_of_cubes-sum_of_numbers<block_end>\n", "solution": "\ndef difference (n):\n    sum_of_cubes=sum([i**3 for i in range(1, n+1)])\n    sum_of_numbers=sum([i for i in range(1, n+1)])\n    return sum_of_cubes-sum_of_numbers\n    \n\n"}
{"task_id": "Mbpp/556", "origin_solution": "<def_stmt>find_Odd_Pair arr n<block_start>odd_count=0<for_stmt>i range(n)<block_start><for_stmt>j range(i+1 n)<block_start><if_stmt>(arr[i]^arr[j])%2<ne>0<block_start>odd_count<augadd>1<block_end><block_end><block_end><return>odd_count<block_end>\n", "solution": "\ndef find_Odd_Pair (arr, n):\n    odd_count=0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (arr[i]^arr[j])%2!=0:\n                odd_count+=1\n                \n        \n    \n    return odd_count\n    \n\n"}
{"task_id": "Mbpp/557", "origin_solution": "<def_stmt>toggle_string s<block_start><return>''.join([i.lower()<if>i.isupper()<else>i.upper()<for>i s])<block_end>\n", "solution": "\ndef toggle_string (s):\n    return ''.join([i.lower() if i.isupper() else i.upper() for i in s])\n    \n\n"}
{"task_id": "Mbpp/558", "origin_solution": "<def_stmt>digit_distance_nums a b<block_start>a_str=str(a)<line_sep>b_str=str(b)<line_sep>a_list=list(a_str)<line_sep>b_list=list(b_str)<line_sep>a_list.sort()<line_sep>b_list.sort()<line_sep>a_list=[int(i)<for>i a_list]<line_sep>b_list=[int(i)<for>i b_list]<line_sep>a_list.reverse()<line_sep>b_list.reverse()<line_sep>a_sum=sum(abs(a-b)<for>a,b zip(a_list b_list))<line_sep>b_sum=sum(abs(b-a)<for>a,b zip(a_list b_list))<line_sep><return>a_sum+b_sum<block_end>\n", "solution": "\ndef digit_distance_nums (a, b):\n    a_str=str(a)\n    b_str=str(b)\n    a_list=list(a_str)\n    b_list=list(b_str)\n    a_list.sort()\n    b_list.sort()\n    a_list=[int(i) for i in a_list]\n    b_list=[int(i) for i in b_list]\n    a_list.reverse()\n    b_list.reverse()\n    a_sum=sum(abs(a-b) for a,b in zip(a_list, b_list))\n    b_sum=sum(abs(b-a) for a,b in zip(a_list, b_list))\n    return a_sum+b_sum\n    \n\n"}
{"task_id": "Mbpp/559", "origin_solution": "<def_stmt>max_sub_array_sum nums k<block_start>max_sum=float('-inf')<line_sep>current_sum=0<for_stmt>i range(len(nums))<block_start>current_sum<augadd>nums[i]<if_stmt>i<ge>k-1<block_start>max_sum=max(max_sum current_sum)<line_sep>current_sum<augsub>nums[i-k+1]<block_end><block_end><return>max_sum<block_end>\n", "solution": "\ndef max_sub_array_sum (nums, k):\n    max_sum=float('-inf')\n    current_sum=0\n    for i in range(len(nums)):\n        current_sum+=nums[i]\n        if i>=k-1:\n            max_sum=max(max_sum, current_sum)\n            current_sum-=nums[i-k+1]\n            \n    \n    return max_sum\n    \n\n"}
{"task_id": "Mbpp/560", "origin_solution": "<def_stmt>union_elements tuple1 tuple2<block_start><return>tuple(sorted(set(tuple1+tuple2)))<block_end>\n", "solution": "\ndef union_elements (tuple1, tuple2):\n    return tuple(sorted(set(tuple1+tuple2)))\n    \n\n"}
{"task_id": "Mbpp/562", "origin_solution": "<def_stmt>Find_Max_Length lst<block_start>max_length=0<for_stmt>sublist lst<block_start><if_stmt>len(sublist)<g>max_length<block_start>max_length=len(sublist)<block_end><block_end><return>max_length<block_end>\n", "solution": "\ndef Find_Max_Length (lst):\n    max_length=0\n    for sublist in lst:\n        if len(sublist)>max_length:\n            max_length=len(sublist)\n            \n    \n    return max_length\n    \n\n"}
{"task_id": "Mbpp/563", "origin_solution": "<def_stmt>extract_values s<block_start>result=[]<line_sep>start=0<line_sep>i=0<while_stmt>i<l>len(s)<block_start><if_stmt>s[i]<eq>'\"'<block_start>result.append(s[start:i])<line_sep>start=i+1<block_end>i<augadd>1<block_end>result.append(s[start:])<line_sep><return>result<block_end>\n", "solution": "\ndef extract_values (s):\n    result=[]\n    start=0\n    i=0\n    while i<len(s):\n        if s[i]=='\"':\n            result.append(s[start:i])\n            start=i+1\n            \n        i+=1\n        \n    result.append(s[start:])\n    return result\n    \n\n"}
{"task_id": "Mbpp/564", "origin_solution": "<def_stmt>count_Pairs arr n<block_start>count=0<for_stmt>i range(n)<block_start><for_stmt>j range(i+1 n)<block_start><if_stmt>arr[i]<ne>arr[j]<block_start>count<augadd>1<block_end><block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_Pairs (arr, n):\n    count=0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i]!=arr[j]:\n                count+=1\n                \n        \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/565", "origin_solution": "<def_stmt>split string<block_start><return>list(string)<block_end>\n", "solution": "\ndef split (string):\n    return list(string)\n    \n\n"}
{"task_id": "Mbpp/566", "origin_solution": "<def_stmt>sum_digits n<block_start><return>sum(int(digit)<for>digit str(n))<block_end>\n", "solution": "\ndef sum_digits (n):\n    return sum(int(digit) for digit in str(n))\n    \n\n"}
{"task_id": "Mbpp/567", "origin_solution": "<def_stmt>issort_list lst<block_start><return>lst<eq>sorted(lst)<block_end>\n", "solution": "\ndef issort_list (lst):\n    return lst==sorted(lst)\n    \n\n"}
{"task_id": "Mbpp/568", "origin_solution": "<def_stmt>empty_list N<block_start><return>[{}<for>_ range(N)]<block_end>\n", "solution": "\ndef empty_list (N):\n    return [{} for _ in range(N)]\n    \n\n"}
{"task_id": "Mbpp/569", "origin_solution": "<def_stmt>sort_sublists lst<block_start><return>[sorted(sublist)<for>sublist lst]<block_end>\n", "solution": "\ndef sort_sublists (lst):\n    return [sorted(sublist) for sublist in lst]\n    \n\n"}
{"task_id": "Mbpp/572", "origin_solution": "<def_stmt>two_unique_nums lists<block_start>result=[]<for_stmt>lst lists<block_start>result.extend(set(lst))<block_end><return>list(set(result))<block_end>\n", "solution": "\ndef two_unique_nums (lists):\n    result=[]\n    for lst in lists:\n        result.extend(set(lst))\n        \n    return list(set(result))\n    \n\n"}
{"task_id": "Mbpp/573", "origin_solution": "<def_stmt>unique_product nums<block_start>unique_nums=set(nums)<line_sep>product=1<for_stmt>num unique_nums<block_start>product<augmul>num<block_end><return>product<block_end>\n", "solution": "\ndef unique_product (nums):\n    unique_nums=set(nums)\n    product=1\n    for num in unique_nums:\n        product*=num\n        \n    return product\n    \n\n"}
{"task_id": "Mbpp/576", "origin_solution": "<def_stmt>is_Sub_Array arr1 arr2<block_start><for_stmt>i range(len(arr2))<block_start><if_stmt>arr2[i]<not><in>arr1<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef is_Sub_Array (arr1, arr2):\n    for i in range(len(arr2)):\n        if arr2[i] not  in arr1:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/577", "origin_solution": "<def_stmt>last_Digit_Factorial n<block_start><if_stmt>n<l>0<block_start><return><none><block_end><elif_stmt>n<eq>0<block_start><return>1<block_end><else_stmt><block_start>fact=1<for_stmt>i range(1 n+1)<block_start>fact<augmul>i<block_end><return>fact%10<block_end><block_end>\n", "solution": "\ndef last_Digit_Factorial (n):\n    if n<0:\n        return  None \n        \n    \n    elif n==0:\n        return 1\n        \n    \n    else :\n        fact=1\n        for i in range(1, n+1):\n            fact*=i\n            \n        return fact%10\n        \n\n\n"}
{"task_id": "Mbpp/578", "origin_solution": "<def_stmt>interleave_lists list1 list2 list3<block_start>result=[]<for_stmt>i range(len(list1))<block_start>result.append(list1[i])<line_sep>result.append(list2[i])<line_sep>result.append(list3[i])<block_end><return>result<block_end>\n", "solution": "\ndef interleave_lists (list1, list2, list3):\n    result=[]\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/579", "origin_solution": "<def_stmt>find_dissimilar tuple1 tuple2<block_start><return>tuple(set(tuple1)-set(tuple2))<block_end>\n", "solution": "\ndef find_dissimilar (tuple1, tuple2):\n    return tuple(set(tuple1)-set(tuple2))\n    \n\n"}
{"task_id": "Mbpp/580", "origin_solution": "<def_stmt>extract_even t<block_start><if_stmt>isinstance(t tuple)<block_start><return>tuple(extract_even(x)<for>x t<if>x%2<eq>0)<block_end><else_stmt><block_start><return>t<block_end><block_end>\n", "solution": "\ndef extract_even (t):\n    if isinstance(t, tuple):\n        return tuple(extract_even(x) for x in t if x%2==0)\n        \n    \n    else :\n        return t\n        \n\n\n"}
{"task_id": "Mbpp/581", "origin_solution": "<def_stmt>surface_Area base height<block_start><return>2<times>(base<times>height)<block_end>\n", "solution": "\ndef surface_Area (base, height):\n    return 2*(base*height)\n    \n\n"}
{"task_id": "Mbpp/583", "origin_solution": "<def_stmt>catalan_number n<block_start><if_stmt>n<le>1<block_start><return>1<block_end>result=0<for_stmt>i range(n)<block_start>result<augadd>catalan_number(i)<times>catalan_number(n-i-1)<block_end><return>result<block_end>\n", "solution": "\ndef catalan_number (n):\n    if n<=1:\n        return 1\n        \n    result=0\n    for i in range(n):\n        result+=catalan_number(i)*catalan_number(n-i-1)\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/585", "origin_solution": "<def_stmt>expensive_items dataset n<block_start>sorted_dataset=sorted(dataset key=<lambda>x:x['price'] reverse=<true>)<line_sep><return>sorted_dataset[:n]<block_end>\n", "solution": "\ndef expensive_items (dataset, n):\n    sorted_dataset=sorted(dataset, key=lambda x:x['price'], reverse= True )\n    return sorted_dataset[:n]\n    \n\n"}
{"task_id": "Mbpp/586", "origin_solution": "<def_stmt>split_Arr arr n<block_start><return>arr[n:]+arr[:n]<block_end>\n", "solution": "\ndef split_Arr (arr, n):\n    return arr[n:]+arr[:n]\n    \n\n"}
{"task_id": "Mbpp/587", "origin_solution": "<def_stmt>list_tuple lst<block_start><return>tuple(lst)<block_end>\n", "solution": "\ndef list_tuple (lst):\n    return tuple(lst)\n    \n\n"}
{"task_id": "Mbpp/588", "origin_solution": "<def_stmt>big_diff lst<block_start><return>max(lst)-min(lst)<block_end>\n", "solution": "\ndef big_diff (lst):\n    return max(lst)-min(lst)\n    \n\n"}
{"task_id": "Mbpp/589", "origin_solution": "<def_stmt>perfect_squares start end<block_start>squares=[]<for_stmt>i range(int(start<power>0.5) int(end<power>0.5)+1)<block_start>square=i<times>i<if_stmt>start<le>square<le>end<block_start>squares.append(square)<block_end><block_end><return>squares<block_end>\n", "solution": "\ndef perfect_squares (start, end):\n    squares=[]\n    for i in range(int(start**0.5), int(end**0.5)+1):\n        square=i*i\n        if start<=square<=end:\n            squares.append(square)\n            \n    \n    return squares\n    \n\n"}
{"task_id": "Mbpp/590", "origin_solution": "<import_stmt>cmath<def_stmt>polar_rect r theta<block_start>x=r<times>cmath.cos(theta)<line_sep>y=r<times>cmath.sin(theta)<line_sep><return>(x y)<block_end>\n", "solution": "\nimport cmath\ndef polar_rect (r, theta):\n    x=r*cmath.cos(theta)\n    y=r*cmath.sin(theta)\n    return (x, y)\n    \n\n"}
{"task_id": "Mbpp/591", "origin_solution": "<def_stmt>swap_List lst<block_start><if_stmt>len(lst)<g>1<block_start>lst[0],lst[-1]=lst[-1] lst[0]<block_end><return>lst<block_end>\n", "solution": "\ndef swap_List (lst):\n    if len(lst)>1:\n        lst[0],lst[-1]=lst[-1], lst[0]\n        \n    return lst\n    \n\n"}
{"task_id": "Mbpp/592", "origin_solution": "<def_stmt>sum_Of_product n<block_start>sum=0<for_stmt>i range(1 n+1)<block_start><for_stmt>j range(i n+1)<block_start>sum<augadd>i<times>j<block_end><block_end><return>sum<block_end>\n", "solution": "\ndef sum_Of_product (n):\n    sum=0\n    for i in range(1, n+1):\n        for j in range(i, n+1):\n            sum+=i*j\n            \n    \n    return sum\n    \n\n"}
{"task_id": "Mbpp/593", "origin_solution": "<def_stmt>removezero_ip ip<block_start>ip_parts=ip.split('.')<line_sep>ip_parts=[str(int(part))<for>part ip_parts]<line_sep>ip_parts=[part.zfill(3)<for>part ip_parts]<line_sep><return>'.'.join(ip_parts)<block_end>\n", "solution": "\ndef removezero_ip (ip):\n    ip_parts=ip.split('.')\n    ip_parts=[str(int(part)) for part in ip_parts]\n    ip_parts=[part.zfill(3) for part in ip_parts]\n    return '.'.join(ip_parts)\n    \n\n"}
{"task_id": "Mbpp/594", "origin_solution": "<def_stmt>diff_even_odd nums<block_start>even_nums=[num<for>num nums<if>num%2<eq>0]<line_sep>odd_nums=[num<for>num nums<if>num%2<ne>0]<if_stmt>even_nums<and>odd_nums<block_start><return>even_nums[0]-odd_nums[0]<block_end><elif_stmt>even_nums<block_start><return>even_nums[0]<block_end><elif_stmt>odd_nums<block_start><return>odd_nums[0]<block_end><else_stmt><block_start><return>0<block_end><block_end>\n", "solution": "\ndef diff_even_odd (nums):\n    even_nums=[num for num in nums if num%2==0]\n    odd_nums=[num for num in nums if num%2!=0]\n    if even_nums and odd_nums:\n        return even_nums[0]-odd_nums[0]\n        \n    \n    elif even_nums:\n        return even_nums[0]\n        \n    \n    elif odd_nums:\n        return odd_nums[0]\n        \n    \n    else :\n        return 0\n        \n\n\n"}
{"task_id": "Mbpp/596", "origin_solution": "<import_stmt>sys<def_stmt>tuple_size t<block_start><return>sys.getsizeof(t)<block_end>\n", "solution": "\nimport sys\ndef tuple_size (t):\n    return sys.getsizeof(t)\n    \n\n"}
{"task_id": "Mbpp/597", "origin_solution": "<def_stmt>find_kth arr1 arr2 k<block_start>len1,len2=len(arr1) len(arr2)<if_stmt>len1<g>len2<block_start><return>find_kth(arr2 arr1 k)<block_end><if_stmt>len1<eq>0<block_start><return>arr2[k-1]<block_end><if_stmt>k<eq>1<block_start><return>min(arr1[0] arr2[0])<block_end>i=min(len1 k<floordiv>2)<line_sep>j=min(len2 k<floordiv>2)<if_stmt>arr1[i-1]<g>arr2[j-1]<block_start><return>find_kth(arr1 arr2[j:] k-j)<block_end><else_stmt><block_start><return>find_kth(arr1[i:] arr2 k-i)<block_end><block_end>\n", "solution": "\ndef find_kth (arr1, arr2, k):\n    len1,len2=len(arr1), len(arr2)\n    if len1>len2:\n        return find_kth(arr2, arr1, k)\n        \n    if len1==0:\n        return arr2[k-1]\n        \n    if k==1:\n        return min(arr1[0], arr2[0])\n        \n    i=min(len1, k//2)\n    j=min(len2, k//2)\n    if arr1[i-1]>arr2[j-1]:\n        return find_kth(arr1, arr2[j:], k-j)\n        \n    \n    else :\n        return find_kth(arr1[i:], arr2, k-i)\n        \n\n\n"}
{"task_id": "Mbpp/598", "origin_solution": "<def_stmt>armstrong_number num<block_start>num_str=str(num)<line_sep>num_len=len(num_str)<line_sep>sum=0<for_stmt>digit num_str<block_start>sum<augadd>int(digit)<power>num_len<block_end><return>sum<eq>num<block_end>\n", "solution": "\ndef armstrong_number (num):\n    num_str=str(num)\n    num_len=len(num_str)\n    sum=0\n    for digit in num_str:\n        sum+=int(digit)**num_len\n        \n    return sum==num\n    \n\n"}
{"task_id": "Mbpp/599", "origin_solution": "<def_stmt>sum_average n<block_start>sum=0<for_stmt>i range(1 n+1)<block_start>sum<augadd>i<block_end>average=sum/n<line_sep><return>(sum average)<block_end>\n", "solution": "\ndef sum_average (n):\n    sum=0\n    for i in range(1, n+1):\n        sum+=i\n        \n    average=sum/n\n    return (sum, average)\n    \n\n"}
{"task_id": "Mbpp/600", "origin_solution": "<def_stmt>is_Even num<block_start><return>num%2<eq>0<block_end>\n", "solution": "\ndef is_Even (num):\n    return num%2==0\n    \n\n"}
{"task_id": "Mbpp/602", "origin_solution": "<def_stmt>first_repeated_char s<block_start>seen=set()<for_stmt>char s<block_start><if_stmt>char<in>seen<block_start><return>char<block_end>seen.add(char)<block_end><return><none><block_end>\n", "solution": "\ndef first_repeated_char (s):\n    seen=set()\n    for char in s:\n        if char in seen:\n            return char\n            \n        seen.add(char)\n        \n    return  None \n    \n\n"}
{"task_id": "Mbpp/603", "origin_solution": "<def_stmt>get_ludic n<block_start>ludic=[]<for_stmt>i range(1 n+1)<block_start><if_stmt>is_lucid(i)<block_start>ludic.append(i)<block_end><block_end><return>ludic<block_end><def_stmt>is_lucid n<block_start>digits=[int(d)<for>d str(n)]<line_sep><return>(digits[0]<ne>0<and>(digits[0]<eq>1<or>digits[0]<eq>4<or>digits[0]<eq>7)<and>all(d%2<eq>0<for>d digits[1:])<and>all(d%3<eq>0<for>d digits[2:])<and>all(d%5<eq>0<for>d digits[3:])<and>all(d%7<eq>0<for>d digits[4:])<and>all(d%11<eq>0<for>d digits[5:])<and>all(d%13<eq>0<for>d digits[6:])<and>all(d%17<eq>0<for>d digits[7:])<and>all(d%19<eq>0<for>d digits[8:])<and>all(d%23<eq>0<for>d digits[9:])<and>all(d%29<eq>0<for>d digits[10:])<and>all(d%31<eq>0<for>d digits[11:]))<block_end>\n", "solution": "\ndef get_ludic (n):\n    ludic=[]\n    for i in range(1, n+1):\n        if is_lucid(i):\n            ludic.append(i)\n            \n    \n    return ludic\n    \ndef is_lucid (n):\n    digits=[int(d) for d in str(n)]\n    return (digits[0]!=0 and (digits[0]==1 or digits[0]==4 or digits[0]==7) and all(d%2==0 for d in digits[1:]) and all(d%3==0 for d in digits[2:]) and all(d%5==0 for d in digits[3:]) and all(d%7==0 for d in digits[4:]) and all(d%11==0 for d in digits[5:]) and all(d%13==0 for d in digits[6:]) and all(d%17==0 for d in digits[7:]) and all(d%19==0 for d in digits[8:]) and all(d%23==0 for d in digits[9:]) and all(d%29==0 for d in digits[10:]) and all(d%31==0 for d in digits[11:]))\n    \n\n"}
{"task_id": "Mbpp/604", "origin_solution": "<def_stmt>reverse_words s<block_start><return>' '.join(s.split()[::-1])<block_end>\n", "solution": "\ndef reverse_words (s):\n    return ' '.join(s.split()[::-1])\n    \n\n"}
{"task_id": "Mbpp/605", "origin_solution": "<def_stmt>prime_num n<block_start><if_stmt>n<le>1<block_start><return><false><block_end><for_stmt>i range(2 int(n<power>0.5)+1)<block_start><if_stmt>n%i<eq>0<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef prime_num (n):\n    if n<=1:\n        return  False \n        \n    for i in range(2, int(n**0.5)+1):\n        if n%i==0:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/606", "origin_solution": "<import_stmt>math<def_stmt>radian_degree degree<block_start><return>degree<times>(math.pi/180)<block_end>\n", "solution": "\nimport math\ndef radian_degree (degree):\n    return degree*(math.pi/180)\n    \n\n"}
{"task_id": "Mbpp/607", "origin_solution": "<import_stmt>re<def_stmt>find_literals string pattern<block_start>match=re.search(pattern string)<if_stmt>match<block_start><return>match.group() match.start() match.end()<block_end><else_stmt><block_start><return><none><block_end><block_end>\n", "solution": "\nimport re\ndef find_literals (string, pattern):\n    match=re.search(pattern, string)\n    if match:\n        return match.group(), match.start(), match.end()\n        \n    \n    else :\n        return  None \n        \n\n\n"}
{"task_id": "Mbpp/608", "origin_solution": "<def_stmt>bell_Number n<block_start>bell=[[0<for>i range(n+1)]<for>j range(n+1)]<line_sep>bell[0][0]=1<for_stmt>i range(1 n+1)<block_start>bell[i][0]=bell[i-1][i-1]<for_stmt>j range(1 i+1)<block_start>bell[i][j]=bell[i-1][j-1]+bell[i][j-1]<block_end><block_end><return>bell[n][0]<block_end>\n", "solution": "\ndef bell_Number (n):\n    bell=[[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0]=1\n    for i in range(1, n+1):\n        bell[i][0]=bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j]=bell[i-1][j-1]+bell[i][j-1]\n            \n    \n    return bell[n][0]\n    \n\n"}
{"task_id": "Mbpp/610", "origin_solution": "<def_stmt>remove_kth_element lst k<block_start><return>[x<for>i,x enumerate(lst)<if>i<ne>k]<block_end>\n", "solution": "\ndef remove_kth_element (lst, k):\n    return [x for i,x in enumerate(lst) if i!=k]\n    \n\n"}
{"task_id": "Mbpp/611", "origin_solution": "<def_stmt>max_of_nth matrix n<block_start><return>max(row[n]<for>row matrix)<block_end>\n", "solution": "\ndef max_of_nth (matrix, n):\n    return max(row[n] for row in matrix)\n    \n\n"}
{"task_id": "Mbpp/612", "origin_solution": "<def_stmt>merge list_of_lists<block_start>first_elements=[sublist[0]<for>sublist list_of_lists]<line_sep>second_elements=[sublist[1]<for>sublist list_of_lists]<line_sep><return>[first_elements second_elements]<block_end>\n", "solution": "\ndef merge (list_of_lists):\n    first_elements=[sublist[0] for sublist in list_of_lists]\n    second_elements=[sublist[1] for sublist in list_of_lists]\n    return [first_elements, second_elements]\n    \n\n"}
{"task_id": "Mbpp/614", "origin_solution": "<def_stmt>cummulative_sum test_list<block_start>result=0<for_stmt>sublist test_list<block_start>result<augadd>sum(sublist)<block_end><return>result<block_end>\n", "solution": "\ndef cummulative_sum (test_list):\n    result=0\n    for sublist in test_list:\n        result+=sum(sublist)\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/615", "origin_solution": "<def_stmt>average_tuple tuples<block_start>averages=[]<for_stmt>t tuples<block_start>average=sum(t)/len(t)<line_sep>averages.append(average)<block_end><return>averages<block_end>\n", "solution": "\ndef average_tuple (tuples):\n    averages=[]\n    for t in tuples:\n        average=sum(t)/len(t)\n        averages.append(average)\n        \n    return averages\n    \n\n"}
{"task_id": "Mbpp/616", "origin_solution": "<def_stmt>tuple_modulo tuple1 tuple2<block_start><return>tuple(x%y<for>x,y zip(tuple1 tuple2))<block_end>\n", "solution": "\ndef tuple_modulo (tuple1, tuple2):\n    return tuple(x%y for x,y in zip(tuple1, tuple2))\n    \n\n"}
{"task_id": "Mbpp/618", "origin_solution": "<def_stmt>div_list list1 list2<block_start><return>[a/b<for>a,b zip(list1 list2)]<block_end>\n", "solution": "\ndef div_list (list1, list2):\n    return [a/b for a,b in zip(list1, list2)]\n    \n\n"}
{"task_id": "Mbpp/619", "origin_solution": "<def_stmt>move_num s<block_start>num_list=[]<line_sep>temp_str=''<for_stmt>char s<block_start><if_stmt>char.isdigit()<block_start>temp_str<augadd>char<block_end><else_stmt><block_start>num_list.append(temp_str)<line_sep>temp_str=''<block_end><block_end>num_list.append(temp_str)<line_sep><return>''.join(num_list)<block_end>\n", "solution": "\ndef move_num (s):\n    num_list=[]\n    temp_str=''\n    for char in s:\n        if char.isdigit():\n            temp_str+=char\n            \n        \n        else :\n            num_list.append(temp_str)\n            temp_str=''\n            \n    \n    num_list.append(temp_str)\n    return ''.join(num_list)\n    \n\n"}
{"task_id": "Mbpp/620", "origin_solution": "<def_stmt>largest_subset nums<block_start>nums.sort()<line_sep>dp=[1]<times>len(nums)<for_stmt>i range(1 len(nums))<block_start><for_stmt>j range(i)<block_start><if_stmt>nums[i]%nums[j]<eq>0<block_start>dp[i]=max(dp[i] dp[j]+1)<block_end><block_end><block_end><return>max(dp)<block_end>\n", "solution": "\ndef largest_subset (nums):\n    nums.sort()\n    dp=[1]*len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i]%nums[j]==0:\n                dp[i]=max(dp[i], dp[j]+1)\n                \n        \n    \n    return max(dp)\n    \n\n"}
{"task_id": "Mbpp/622", "origin_solution": "<def_stmt>get_median list1 list2 n<block_start>merged_list=list1+list2<line_sep>merged_list.sort()<line_sep>mid=n<floordiv>2<if_stmt>n%2<eq>0<block_start><return>(merged_list[mid-1]+merged_list[mid])/2<block_end><else_stmt><block_start><return>merged_list[mid]<block_end><block_end>\n", "solution": "\ndef get_median (list1, list2, n):\n    merged_list=list1+list2\n    merged_list.sort()\n    mid=n//2\n    if n%2==0:\n        return (merged_list[mid-1]+merged_list[mid])/2\n        \n    \n    else :\n        return merged_list[mid]\n        \n\n\n"}
{"task_id": "Mbpp/623", "origin_solution": "<def_stmt>nth_nums nums n<block_start><return>[num<power>n<for>num nums]<block_end>\n", "solution": "\ndef nth_nums (nums, n):\n    return [num**n for num in nums]\n    \n\n"}
{"task_id": "Mbpp/624", "origin_solution": "<def_stmt>is_upper s<block_start><return>s.upper()<eq>s<block_end>\n", "solution": "\ndef is_upper (s):\n    return s.upper()==s\n    \n\n"}
{"task_id": "Mbpp/626", "origin_solution": "<import_stmt>math<def_stmt>triangle_area r<block_start><if_stmt>r<l>0<block_start><return><none><block_end><return>r<times>r<block_end>\n", "solution": "\nimport math\ndef triangle_area (r):\n    if r<0:\n        return  None \n        \n    return r*r\n    \n\n"}
{"task_id": "Mbpp/628", "origin_solution": "<def_stmt>replace_spaces string<block_start><return>string.replace(' ' '%20')<block_end>\n", "solution": "\ndef replace_spaces (string):\n    return string.replace(' ', '%20')\n    \n\n"}
{"task_id": "Mbpp/629", "origin_solution": "<def_stmt>Split numbers<block_start><return>[num<for>num numbers<if>num%2<eq>0]<block_end>\n", "solution": "\ndef Split (numbers):\n    return [num for num in numbers if num%2==0]\n    \n\n"}
{"task_id": "Mbpp/630", "origin_solution": "<def_stmt>get_coordinates coord<block_start>x,y=coord<line_sep><return>[[x-1 y] [x y-1] [x y+1] [x+1 y] [x+1 y-1] [x+1 y+1] [x y] [x-1 y] [x-1 y+1] [x+1 y]]<block_end>\n", "solution": "\ndef get_coordinates (coord):\n    x,y=coord\n    return [[x-1, y], [x, y-1], [x, y+1], [x+1, y], [x+1, y-1], [x+1, y+1], [x, y], [x-1, y], [x-1, y+1], [x+1, y]]\n    \n\n"}
{"task_id": "Mbpp/631", "origin_solution": "<def_stmt>replace_spaces text<block_start><return>text.replace(' ' '_').replace('_' ' ')<block_end>\n", "solution": "\ndef replace_spaces (text):\n    return text.replace(' ', '_').replace('_', ' ')\n    \n\n"}
{"task_id": "Mbpp/632", "origin_solution": "<def_stmt>move_zero nums<block_start>j=0<for_stmt>i range(len(nums))<block_start><if_stmt>nums[i]<ne>0<block_start>nums[j]=nums[i]<line_sep>j<augadd>1<block_end><block_end><for_stmt>i range(j len(nums))<block_start>nums[i]=0<block_end><return>nums<block_end>\n", "solution": "\ndef move_zero (nums):\n    j=0\n    for i in range(len(nums)):\n        if nums[i]!=0:\n            nums[j]=nums[i]\n            j+=1\n            \n    \n    for i in range(j, len(nums)):\n        nums[i]=0\n        \n    return nums\n    \n\n"}
{"task_id": "Mbpp/633", "origin_solution": "<def_stmt>pair_xor_Sum nums k<block_start>n=len(nums)<line_sep>res=0<for_stmt>i range(n)<block_start><for_stmt>j range(i+1 n)<block_start>res<augadd>nums[i]^nums[j]<block_end><block_end><return>res<block_end>\n", "solution": "\ndef pair_xor_Sum (nums, k):\n    n=len(nums)\n    res=0\n    for i in range(n):\n        for j in range(i+1, n):\n            res+=nums[i]^nums[j]\n            \n    \n    return res\n    \n\n"}
{"task_id": "Mbpp/635", "origin_solution": "<def_stmt>heapify arr n i<block_start>largest=i<line_sep>l=2<times>i+1<line_sep>r=2<times>i+2<if_stmt>l<l>n<and>arr[i]<l>arr[l]<block_start>largest=l<block_end><if_stmt>r<l>n<and>arr[largest]<l>arr[r]<block_start>largest=r<block_end><if_stmt>largest<ne>i<block_start>arr[i],arr[largest]=arr[largest] arr[i]<line_sep>heapify(arr n largest)<block_end><block_end><def_stmt>heap_sort arr<block_start>n=len(arr)<for_stmt>i range(n -1 -1)<block_start>heapify(arr n i)<block_end><for_stmt>i range(n-1 0 -1)<block_start>arr[i],arr[0]=arr[0] arr[i]<line_sep>heapify(arr i 0)<block_end><return>arr<block_end>\n", "solution": "\ndef heapify (arr, n, i):\n    largest=i\n    l=2*i+1\n    r=2*i+2\n    if l<n and arr[i]<arr[l]:\n        largest=l\n        \n    if r<n and arr[largest]<arr[r]:\n        largest=r\n        \n    if largest!=i:\n        arr[i],arr[largest]=arr[largest], arr[i]\n        heapify(arr, n, largest)\n        \n\ndef heap_sort (arr):\n    n=len(arr)\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n        \n    for i in range(n-1, 0, -1):\n        arr[i],arr[0]=arr[0], arr[i]\n        heapify(arr, i, 0)\n        \n    return arr\n    \n\n"}
{"task_id": "Mbpp/637", "origin_solution": "<def_stmt>noprofit_noloss amount profit<block_start><return>profit<eq>0<and>amount<eq>profit<block_end>\n", "solution": "\ndef noprofit_noloss (amount, profit):\n    return profit==0 and amount==profit\n    \n\n"}
{"task_id": "Mbpp/638", "origin_solution": "<def_stmt>wind_chill velocity temperature<block_start>\"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \n    Parameters:\n    velocity (float): Wind velocity in km/h.\n    temperature (float): Temperature in celsius.\n    \n    Returns:\n    int: Wind chill index rounded to the next integer.\n    \"\"\"<line_sep>wci=13.12+0.6215<times>temperature-11.37<times>(velocity<power>0.16)+0.3965<times>temperature<times>(velocity<power>0.16)<line_sep><return>round(wci)<block_end>\n", "solution": "\ndef wind_chill (velocity, temperature):\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \n    Parameters:\n    velocity (float): Wind velocity in km/h.\n    temperature (float): Temperature in celsius.\n    \n    Returns:\n    int: Wind chill index rounded to the next integer.\n    \"\"\"\n    wci=13.12+0.6215*temperature-11.37*(velocity**0.16)+0.3965*temperature*(velocity**0.16)\n    return round(wci)\n    \n\n"}
{"task_id": "Mbpp/639", "origin_solution": "<def_stmt>sample_nam names<block_start><return>sum(len(name)<for>name names<if><not>name[0].islower())<block_end>\n", "solution": "\ndef sample_nam (names):\n    return sum(len(name) for name in names if  not name[0].islower())\n    \n\n"}
{"task_id": "Mbpp/641", "origin_solution": "<def_stmt>is_nonagonal n<block_start><return>n<times>(7<times>n-5)<floordiv>2<block_end>\n", "solution": "\ndef is_nonagonal (n):\n    return n*(7*n-5)//2\n    \n\n"}
{"task_id": "Mbpp/643", "origin_solution": "<def_stmt>text_match_wordz_middle text<block_start><if_stmt>text.startswith('z')<or>text.endswith('z')<block_start><return><false><block_end><for_stmt>i range(1 len(text)-1)<block_start><if_stmt>text[i]<eq>'z'<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef text_match_wordz_middle (text):\n    if text.startswith('z') or text.endswith('z'):\n        return  False \n        \n    for i in range(1, len(text)-1):\n        if text[i]=='z':\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/644", "origin_solution": "<def_stmt>reverse_Array_Upto_K arr k<block_start><return>arr[:k][::-1]+arr[k:]<block_end>\n", "solution": "\ndef reverse_Array_Upto_K (arr, k):\n    return arr[:k][::-1]+arr[k:]\n    \n\n"}
{"task_id": "Mbpp/720", "origin_solution": "<def_stmt>add_dict_to_tuple t d<block_start><return>t+(d )<block_end>\n", "solution": "\ndef add_dict_to_tuple (t, d):\n    return t+(d, )\n    \n\n"}
{"task_id": "Mbpp/721", "origin_solution": "<def_stmt>maxAverageOfPath grid<block_start>n=len(grid)<line_sep>dp=[[0]<times>n<for>_ range(n)]<line_sep>dp[0][0]=grid[0][0]<for_stmt>j range(1 n)<block_start>dp[0][j]=dp[0][j-1]+grid[0][j]<block_end><for_stmt>i range(1 n)<block_start>dp[i][0]=dp[i-1][0]+grid[i][0]<block_end><for_stmt>i range(1 n)<block_start><for_stmt>j range(1 n)<block_start>dp[i][j]=max(dp[i-1][j] dp[i][j-1])+grid[i][j]<block_end><block_end><return>dp[n-1][n-1]/(n<times>n)<block_end>\n", "solution": "\ndef maxAverageOfPath (grid):\n    n=len(grid)\n    dp=[[0]*n for _ in range(n)]\n    dp[0][0]=grid[0][0]\n    for j in range(1, n):\n        dp[0][j]=dp[0][j-1]+grid[0][j]\n        \n    for i in range(1, n):\n        dp[i][0]=dp[i-1][0]+grid[i][0]\n        \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j]=max(dp[i-1][j], dp[i][j-1])+grid[i][j]\n            \n    \n    return dp[n-1][n-1]/(n*n)\n    \n\n"}
{"task_id": "Mbpp/722", "origin_solution": "<def_stmt>filter_data data min_height min_weight<block_start><return>{name:info<for>name,info data.items()<if>info[0]<g>min_height<and>info[1]<g>min_weight}<block_end>\n", "solution": "\ndef filter_data (data, min_height, min_weight):\n    return {name:info for name,info in data.items() if info[0]>min_height and info[1]>min_weight}\n    \n\n"}
{"task_id": "Mbpp/723", "origin_solution": "<def_stmt>count_same_pair list1 list2<block_start>count=0<for_stmt>i range(len(list1))<block_start><if_stmt>list1[i]<eq>list2[i]<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_same_pair (list1, list2):\n    count=0\n    for i in range(len(list1)):\n        if list1[i]==list2[i]:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/724", "origin_solution": "<def_stmt>power_base_sum base power<block_start>result=1<while_stmt>power<g>0<block_start>result<augmul>base<line_sep>power<augsub>1<block_end><return>sum(int(digit)<for>digit str(result))<block_end>\n", "solution": "\ndef power_base_sum (base, power):\n    result=1\n    while power>0:\n        result*=base\n        power-=1\n        \n    return sum(int(digit) for digit in str(result))\n    \n\n"}
{"task_id": "Mbpp/725", "origin_solution": "<import_stmt>re<def_stmt>extract_quotation text<block_start><return>re.findall(r'\"(.*?)\"' text)<block_end>\n", "solution": "\nimport re\ndef extract_quotation (text):\n    return re.findall(r'\"(.*?)\"', text)\n    \n\n"}
{"task_id": "Mbpp/726", "origin_solution": "<def_stmt>multiply_elements t<block_start><if_stmt>len(t)<eq>0<block_start><return>()<block_end><elif_stmt>len(t)<eq>1<block_start><return>(t[0] )<block_end><else_stmt><block_start><return>(t[0]<times>t[1] *multiply_elements(t[1:]) )<block_end><block_end>\n", "solution": "\ndef multiply_elements (t):\n    if len(t)==0:\n        return ()\n        \n    \n    elif len(t)==1:\n        return (t[0], )\n        \n    \n    else :\n        return (t[0]*t[1], *multiply_elements(t[1:]), )\n        \n\n\n"}
{"task_id": "Mbpp/728", "origin_solution": "<def_stmt>sum_list list1 list2<block_start><return>[a+b<for>a,b zip(list1 list2)]<block_end>\n", "solution": "\ndef sum_list (list1, list2):\n    return [a+b for a,b in zip(list1, list2)]\n    \n\n"}
{"task_id": "Mbpp/730", "origin_solution": "<def_stmt>consecutive_duplicates lst<block_start>result=[]<for_stmt>i range(len(lst))<block_start><if_stmt>i<eq>0<or>lst[i]<ne>lst[i-1]<block_start>result.append(lst[i])<block_end><block_end><return>result<block_end>\n", "solution": "\ndef consecutive_duplicates (lst):\n    result=[]\n    for i in range(len(lst)):\n        if i==0 or lst[i]!=lst[i-1]:\n            result.append(lst[i])\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/731", "origin_solution": "<import_stmt>math<def_stmt>lateral_surface_cone r h<block_start>lateral_surface=math.pi<times>r<power>2<times>h<line_sep><return>lateral_surface<block_end>\n", "solution": "\nimport math\ndef lateral_surface_cone (r, h):\n    lateral_surface=math.pi*r**2*h\n    return lateral_surface\n    \n\n"}
{"task_id": "Mbpp/732", "origin_solution": "<def_stmt>replace_specialchar text<block_start><return>text.replace(' ' ':').replace(',' ':').replace('.' ':')<block_end>\n", "solution": "\ndef replace_specialchar (text):\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')\n    \n\n"}
{"task_id": "Mbpp/733", "origin_solution": "<def_stmt>find_first_occurrence arr target<block_start>left,right=0 len(arr)-1<line_sep>result=-1<while_stmt>left<le>right<block_start>mid=(left+right)<floordiv>2<if_stmt>arr[mid]<eq>target<block_start>result=mid<line_sep>right=mid-1<block_end><elif_stmt>arr[mid]<l>target<block_start>left=mid+1<block_end><else_stmt><block_start>right=mid-1<block_end><block_end><return>result<block_end>\n", "solution": "\ndef find_first_occurrence (arr, target):\n    left,right=0, len(arr)-1\n    result=-1\n    while left<=right:\n        mid=(left+right)//2\n        if arr[mid]==target:\n            result=mid\n            right=mid-1\n            \n        \n        elif arr[mid]<target:\n            left=mid+1\n            \n        \n        else :\n            right=mid-1\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/734", "origin_solution": "<def_stmt>sum_Of_Subarray_Prod lst<block_start>n=len(lst)<line_sep>total_sum=0<for_stmt>i range(n)<block_start>total_sum<augadd>lst[i]<times>(i+1)<times>(n-i)<block_end><return>total_sum<block_end>\n", "solution": "\ndef sum_Of_Subarray_Prod (lst):\n    n=len(lst)\n    total_sum=0\n    for i in range(n):\n        total_sum+=lst[i]*(i+1)*(n-i)\n        \n    return total_sum\n    \n\n"}
{"task_id": "Mbpp/735", "origin_solution": "<def_stmt>toggle_middle_bits n<block_start>binary=bin(n)[2:]<if_stmt>len(binary)<le>2<block_start><return>n<block_end>middle_bits=binary[1:-1]<line_sep>toggled_middle_bits=''.join('1'<if>bit<eq>'0'<else>'0'<for>bit middle_bits)<line_sep>toggled_binary=binary[:-1]+toggled_middle_bits<line_sep><return>int(toggled_binary 2)<block_end>\n", "solution": "\ndef toggle_middle_bits (n):\n    binary=bin(n)[2:]\n    if len(binary)<=2:\n        return n\n        \n    middle_bits=binary[1:-1]\n    toggled_middle_bits=''.join('1' if bit=='0' else '0' for bit in middle_bits)\n    toggled_binary=binary[:-1]+toggled_middle_bits\n    return int(toggled_binary, 2)\n    \n\n"}
{"task_id": "Mbpp/736", "origin_solution": "<def_stmt>left_insertion arr target<block_start>left,right=0 len(arr)<while_stmt>left<l>right<block_start>mid=(left+right)<floordiv>2<if_stmt>arr[mid]<l>target<block_start>left=mid+1<block_end><else_stmt><block_start>right=mid<block_end><block_end><return>left<block_end>\n", "solution": "\ndef left_insertion (arr, target):\n    left,right=0, len(arr)\n    while left<right:\n        mid=(left+right)//2\n        if arr[mid]<target:\n            left=mid+1\n            \n        \n        else :\n            right=mid\n            \n    \n    return left\n    \n\n"}
{"task_id": "Mbpp/737", "origin_solution": "<import_stmt>re<def_stmt>check_str string<block_start>pattern=r\"^[aeiou]\"<if_stmt>re.search(pattern string)<block_start><return><true><block_end><else_stmt><block_start><return><false><block_end><block_end>\n", "solution": "\nimport re\ndef check_str (string):\n    pattern=r\"^[aeiou]\"\n    if re.search(pattern, string):\n        return  True \n        \n    \n    else :\n        return  False \n        \n\n\n"}
{"task_id": "Mbpp/739", "origin_solution": "<def_stmt>find_Index n<block_start><return>n<times>(n+1)<floordiv>2+1<block_end>\n", "solution": "\ndef find_Index (n):\n    return n*(n+1)//2+1\n    \n\n"}
{"task_id": "Mbpp/740", "origin_solution": "<def_stmt>tuple_to_dict t<block_start><return>{t[i]:t[i+1]<for>i range(0 len(t)-1 2)}<block_end>\n", "solution": "\ndef tuple_to_dict (t):\n    return {t[i]:t[i+1] for i in range(0, len(t)-1, 2)}\n    \n\n"}
{"task_id": "Mbpp/741", "origin_solution": "<def_stmt>all_Characters_Same string<block_start><return>len(set(string))<eq>1<block_end>\n", "solution": "\ndef all_Characters_Same (string):\n    return len(set(string))==1\n    \n\n"}
{"task_id": "Mbpp/742", "origin_solution": "<import_stmt>math<def_stmt>area_tetrahedron side_length<block_start><return>math.sqrt(3)/4<times>side_length<power>2<block_end>\n", "solution": "\nimport math\ndef area_tetrahedron (side_length):\n    return math.sqrt(3)/4*side_length**2\n    \n\n"}
{"task_id": "Mbpp/743", "origin_solution": "<def_stmt>rotate_right lst n<block_start>n=n%len(lst)<line_sep><return>lst[-n:]+lst[:-n]<block_end>\n", "solution": "\ndef rotate_right (lst, n):\n    n=n%len(lst)\n    return lst[-n:]+lst[:-n]\n    \n\n"}
{"task_id": "Mbpp/744", "origin_solution": "<def_stmt>check_none t<block_start><return>all(x<is><none><for>x t)<block_end>\n", "solution": "\ndef check_none (t):\n    return all(x is  None  for x in t)\n    \n\n"}
{"task_id": "Mbpp/745", "origin_solution": "<def_stmt>divisible_by_digits startnum endnum<block_start>result=[]<for_stmt>i range(startnum endnum+1)<block_start><if_stmt>all(i%digit<eq>0<for>digit str(i))<block_start>result.append(i)<block_end><block_end><return>result<block_end>\n", "solution": "\ndef divisible_by_digits (startnum, endnum):\n    result=[]\n    for i in range(startnum, endnum+1):\n        if all(i%digit==0 for digit in str(i)):\n            result.append(i)\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/748", "origin_solution": "<def_stmt>capital_words_spaces string<block_start>words=string.split()<line_sep>capitalized_words=[word.capitalize()<for>word words]<line_sep><return>' '.join(capitalized_words)<block_end>\n", "solution": "\ndef capital_words_spaces (string):\n    words=string.split()\n    capitalized_words=[word.capitalize() for word in words]\n    return ' '.join(capitalized_words)\n    \n\n"}
{"task_id": "Mbpp/749", "origin_solution": "<def_stmt>sort_numeric_strings strings<block_start><return>sorted(strings key=<lambda>x:int(x))<block_end>\n", "solution": "\ndef sort_numeric_strings (strings):\n    return sorted(strings, key=lambda x:int(x))\n    \n\n"}
{"task_id": "Mbpp/750", "origin_solution": "<def_stmt>add_tuple lst tpl<block_start><return>lst+tpl<block_end>\n", "solution": "\ndef add_tuple (lst, tpl):\n    return lst+tpl\n    \n\n"}
{"task_id": "Mbpp/751", "origin_solution": "<def_stmt>check_min_heap arr<block_start>n=len(arr)<for_stmt>i range(n<floordiv>2)<block_start><if_stmt>2<times>i+1<l>n<and>arr[i]<g>arr[2<times>i+1]<block_start><return><false><block_end><if_stmt>2<times>i+2<l>n<and>arr[i]<g>arr[2<times>i+2]<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef check_min_heap (arr):\n    n=len(arr)\n    for i in range(n//2):\n        if 2*i+1<n and arr[i]>arr[2*i+1]:\n            return  False \n            \n        if 2*i+2<n and arr[i]>arr[2*i+2]:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/752", "origin_solution": "<def_stmt>jacobsthal_num n<block_start><if_stmt>n<eq>0<block_start><return>0<block_end><elif_stmt>n<eq>1<block_start><return>1<block_end><else_stmt><block_start><return>2<power>(n-1)-jacobsthal_num(n-1)<block_end><block_end>\n", "solution": "\ndef jacobsthal_num (n):\n    if n==0:\n        return 0\n        \n    \n    elif n==1:\n        return 1\n        \n    \n    else :\n        return 2**(n-1)-jacobsthal_num(n-1)\n        \n\n\n"}
{"task_id": "Mbpp/753", "origin_solution": "<def_stmt>min_k test_list k<block_start>test_list.sort(key=<lambda>x:x[1])<line_sep><return>test_list[:k]<block_end>\n", "solution": "\ndef min_k (test_list, k):\n    test_list.sort(key=lambda x:x[1])\n    return test_list[:k]\n    \n\n"}
{"task_id": "Mbpp/754", "origin_solution": "<def_stmt>extract_index_list l1 l2 l3<block_start>common_elements=[]<for_stmt>i range(len(l1))<block_start><if_stmt>l1[i]<in>l2<and>l1[i]<in>l3<block_start>common_elements.append(l1[i])<block_end><block_end><return>common_elements<block_end>\n", "solution": "\ndef extract_index_list (l1, l2, l3):\n    common_elements=[]\n    for i in range(len(l1)):\n        if l1[i] in l2 and l1[i] in l3:\n            common_elements.append(l1[i])\n            \n    \n    return common_elements\n    \n\n"}
{"task_id": "Mbpp/755", "origin_solution": "<def_stmt>second_smallest lst<block_start><if_stmt>len(lst)<l>2<block_start><return><none><block_end>smallest=second_smallest=float('inf')<for_stmt>num lst<block_start><if_stmt>num<l>smallest<block_start>second_smallest=smallest<line_sep>smallest=num<block_end><elif_stmt>num<l>second_smallest<and>num<ne>smallest<block_start>second_smallest=num<block_end><block_end><return>second_smallest<if>second_smallest<ne>float('inf')<else><none><block_end>\n", "solution": "\ndef second_smallest (lst):\n    if len(lst)<2:\n        return  None \n        \n    smallest=second_smallest=float('inf')\n    for num in lst:\n        if num<smallest:\n            second_smallest=smallest\n            smallest=num\n            \n        \n        elif num<second_smallest and num!=smallest:\n            second_smallest=num\n            \n    \n    return second_smallest if second_smallest!=float('inf') else  None \n    \n\n"}
{"task_id": "Mbpp/757", "origin_solution": "<def_stmt>count_reverse_pairs lst<block_start>count=0<for_stmt>i range(len(lst))<block_start><for_stmt>j range(i+1 len(lst))<block_start><if_stmt>lst[i]<eq>lst[j][::-1]<block_start>count<augadd>1<block_end><block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_reverse_pairs (lst):\n    count=0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i]==lst[j][::-1]:\n                count+=1\n                \n        \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/758", "origin_solution": "<def_stmt>unique_sublists lst<block_start>result={}<for_stmt>sublist lst<block_start>sublist_tuple=tuple(sublist)<if_stmt>sublist_tuple<in>result<block_start>result[sublist_tuple]<augadd>1<block_end><else_stmt><block_start>result[sublist_tuple]=1<block_end><block_end><return>result<block_end>\n", "solution": "\ndef unique_sublists (lst):\n    result={}\n    for sublist in lst:\n        sublist_tuple=tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple]+=1\n            \n        \n        else :\n            result[sublist_tuple]=1\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/759", "origin_solution": "<def_stmt>is_decimal s<block_start><try_stmt><block_start>float(s)<line_sep><return><true><block_end><except_stmt>ValueError<block_start><return><false><block_end><block_end>\n", "solution": "\ndef is_decimal (s):\n    try:\n        float(s)\n        return  True \n        \n    \n    except ValueError:\n        return  False \n        \n\n\n"}
{"task_id": "Mbpp/760", "origin_solution": "<def_stmt>unique_Element nums<block_start><return>len(set(nums))<eq>1<block_end>\n", "solution": "\ndef unique_Element (nums):\n    return len(set(nums))==1\n    \n\n"}
{"task_id": "Mbpp/762", "origin_solution": "<def_stmt>check_monthnumber_number month_number<block_start><if_stmt>month_number<in>[1 3 5 7 8 10 12]<block_start><return><true><block_end><else_stmt><block_start><return><false><block_end><block_end>\n", "solution": "\ndef check_monthnumber_number (month_number):\n    if month_number in [1, 3, 5, 7, 8, 10, 12]:\n        return  True \n        \n    \n    else :\n        return  False \n        \n\n\n"}
{"task_id": "Mbpp/763", "origin_solution": "<def_stmt>find_min_diff arr n<block_start>arr.sort()<line_sep>min_diff=float('inf')<for_stmt>i range(n-1)<block_start>diff=arr[i+1]-arr[i]<if_stmt>diff<l>min_diff<block_start>min_diff=diff<block_end><block_end><return>min_diff<block_end>\n", "solution": "\ndef find_min_diff (arr, n):\n    arr.sort()\n    min_diff=float('inf')\n    for i in range(n-1):\n        diff=arr[i+1]-arr[i]\n        if diff<min_diff:\n            min_diff=diff\n            \n    \n    return min_diff\n    \n\n"}
{"task_id": "Mbpp/764", "origin_solution": "<def_stmt>number_ctr string<block_start>count=0<for_stmt>char string<block_start><if_stmt>char.isdigit()<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef number_ctr (string):\n    count=0\n    for char in string:\n        if char.isdigit():\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/765", "origin_solution": "<def_stmt>is_polite n<block_start>count=0<for_stmt>i range(1 n+1)<block_start><if_stmt>is_prime(i)<block_start>count<augadd>1<block_end><block_end><return>count<block_end><def_stmt>is_prime n<block_start><if_stmt>n<le>1<block_start><return><false><block_end><if_stmt>n<le>3<block_start><return><true><block_end><if_stmt>n%2<eq>0<or>n%3<eq>0<block_start><return><false><block_end>i=5<while_stmt>i<times>i<le>n<block_start><if_stmt>n%i<eq>0<or>n%(i+2)<eq>0<block_start><return><false><block_end>i<augadd>6<block_end><return><true><block_end>\n", "solution": "\ndef is_polite (n):\n    count=0\n    for i in range(1, n+1):\n        if is_prime(i):\n            count+=1\n            \n    \n    return count\n    \ndef is_prime (n):\n    if n<=1:\n        return  False \n        \n    if n<=3:\n        return  True \n        \n    if n%2==0 or n%3==0:\n        return  False \n        \n    i=5\n    while i*i<=n:\n        if n%i==0 or n%(i+2)==0:\n            return  False \n            \n        i+=6\n        \n    return  True \n    \n\n"}
{"task_id": "Mbpp/766", "origin_solution": "<def_stmt>pair_wise lst<block_start><return>[(lst[i] lst[i+1])<for>i range(len(lst)-1)]<block_end>\n", "solution": "\ndef pair_wise (lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]\n    \n\n"}
{"task_id": "Mbpp/767", "origin_solution": "<def_stmt>get_pairs_count numbers target_sum<block_start>count=0<for_stmt>i range(len(numbers))<block_start><for_stmt>j range(i+1 len(numbers))<block_start><if_stmt>numbers[i]+numbers[j]<eq>target_sum<block_start>count<augadd>1<block_end><block_end><block_end><return>count<block_end>\n", "solution": "\ndef get_pairs_count (numbers, target_sum):\n    count=0\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if numbers[i]+numbers[j]==target_sum:\n                count+=1\n                \n        \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/769", "origin_solution": "<def_stmt>Diff list1 list2<block_start><return>[i<for>i list1<if>i<not><in>list2]<block_end>\n", "solution": "\ndef Diff (list1, list2):\n    return [i for i in list1 if i not  in list2]\n    \n\n"}
{"task_id": "Mbpp/770", "origin_solution": "<def_stmt>odd_num_sum n<block_start>sum=0<for_stmt>i range(1 2<times>n 2)<block_start>sum<augadd>i<power>4<block_end><return>sum<block_end>\n", "solution": "\ndef odd_num_sum (n):\n    sum=0\n    for i in range(1, 2*n, 2):\n        sum+=i**4\n        \n    return sum\n    \n\n"}
{"task_id": "Mbpp/771", "origin_solution": "<def_stmt>check_expression expression<block_start>stack=[]<for_stmt>char expression<block_start><if_stmt>char<in>\"({[\"<block_start>stack.append(char)<block_end><elif_stmt>char<in>\")}]\"<block_start><if_stmt><not>stack<block_start><return><false><block_end><if_stmt>(char<eq>\")\"<and>stack[-1]<eq>\"(\")<or>(char<eq>\"}\"<and>stack[-1]<eq>\"{\")<or>(char<eq>\"]\"<and>stack[-1]<eq>\"[\")<block_start>stack.pop()<block_end><else_stmt><block_start><return><false><block_end><block_end><block_end><return>len(stack)<eq>0<block_end>\n", "solution": "\ndef check_expression (expression):\n    stack=[]\n    for char in expression:\n        if char in \"({[\":\n            stack.append(char)\n            \n        \n        elif char in \")}]\":\n            if  not stack:\n                return  False \n                \n            if (char==\")\" and stack[-1]==\"(\") or (char==\"}\" and stack[-1]==\"{\") or (char==\"]\" and stack[-1]==\"[\"):\n                stack.pop()\n                \n            \n            else :\n                return  False \n                \n        \n    \n    return len(stack)==0\n    \n\n"}
{"task_id": "Mbpp/772", "origin_solution": "<def_stmt>remove_length s k<block_start>words=s.split()<line_sep>filtered_words=[word<for>word words<if>len(word)<ne>k]<line_sep><return>' '.join(filtered_words)<block_end>\n", "solution": "\ndef remove_length (s, k):\n    words=s.split()\n    filtered_words=[word for word in words if len(word)!=k]\n    return ' '.join(filtered_words)\n    \n\n"}
{"task_id": "Mbpp/773", "origin_solution": "<def_stmt>occurance_substring string substring<block_start>occurance=string.find(substring)<if_stmt>occurance<eq>-1<block_start><return><none><block_end><else_stmt><block_start><return>(substring occurance occurance+len(substring))<block_end><block_end>\n", "solution": "\ndef occurance_substring (string, substring):\n    occurance=string.find(substring)\n    if occurance==-1:\n        return  None \n        \n    \n    else :\n        return (substring, occurance, occurance+len(substring))\n        \n\n\n"}
{"task_id": "Mbpp/775", "origin_solution": "<def_stmt>odd_position lst<block_start><for_stmt>i range(1 len(lst) 2)<block_start><if_stmt>lst[i]%2<eq>0<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef odd_position (lst):\n    for i in range(1, len(lst), 2):\n        if lst[i]%2==0:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/777", "origin_solution": "<def_stmt>find_sum lst<block_start><return>sum(set(lst))<block_end>\n", "solution": "\ndef find_sum (lst):\n    return sum(set(lst))\n    \n\n"}
{"task_id": "Mbpp/778", "origin_solution": "<def_stmt>pack_consecutive_duplicates lst<block_start><if_stmt><not>lst<block_start><return>[]<block_end>result=[]<line_sep>current_group=[lst[0]]<for_stmt>i range(1 len(lst))<block_start><if_stmt>lst[i]<eq>lst[i-1]<block_start>current_group.append(lst[i])<block_end><else_stmt><block_start>result.append(current_group)<line_sep>current_group=[lst[i]]<block_end><block_end>result.append(current_group)<line_sep><return>result<block_end>\n", "solution": "\ndef pack_consecutive_duplicates (lst):\n    if  not lst:\n        return []\n        \n    result=[]\n    current_group=[lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i]==lst[i-1]:\n            current_group.append(lst[i])\n            \n        \n        else :\n            result.append(current_group)\n            current_group=[lst[i]]\n            \n    \n    result.append(current_group)\n    return result\n    \n\n"}
{"task_id": "Mbpp/780", "origin_solution": "<def_stmt>find_combinations tuples<block_start>result=[]<for_stmt>i range(1 len(tuples)+1)<block_start><for_stmt>subset combinations(tuples i)<block_start>result.append(subset)<block_end><block_end><return>result<block_end><def_stmt>combinations iterable r<block_start>pool=tuple(iterable)<line_sep>n=len(pool)<if_stmt>r<g>n<block_start><return><block_end>indices=list(range(r))<line_sep><yield>tuple(pool[i]<for>i indices)<while_stmt><true><block_start><for_stmt>i reversed(range(r))<block_start><if_stmt>indices[i]<ne>i+n-r<block_start><break><block_end><block_end><else_stmt><block_start><return><block_end>indices[i]<augadd>1<for_stmt>j range(i+1 r)<block_start>indices[j]=indices[j-1]+1<block_end><yield>tuple(pool[i]<for>i indices)<block_end><block_end>\n", "solution": "\ndef find_combinations (tuples):\n    result=[]\n    for i in range(1, len(tuples)+1):\n        for subset in combinations(tuples, i):\n            result.append(subset)\n            \n    \n    return result\n    \ndef combinations (iterable, r):\n    pool=tuple(iterable)\n    n=len(pool)\n    if r>n:\n        return \n        \n    indices=list(range(r))\n    yield tuple(pool[i] for i in indices)\n    while  True :\n        for i in reversed(range(r))\n            if indices[i]!=i+n-r:\n                break \n                \n        :\n        \n        else :\n            return \n            \n        indices[i]+=1\n        for j in range(i+1, r):\n            indices[j]=indices[j-1]+1\n            \n        yield tuple(pool[i] for i in indices)\n        \n\n\n"}
{"task_id": "Mbpp/781", "origin_solution": "<def_stmt>count_divisors n<block_start>count=0<for_stmt>i range(1 n+1)<block_start><if_stmt>n%i<eq>0<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_divisors (n):\n    count=0\n    for i in range(1, n+1):\n        if n%i==0:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/782", "origin_solution": "<def_stmt>odd_length_sum arr<block_start>total_sum=0<line_sep>n=len(arr)<for_stmt>i range(n)<block_start><for_stmt>j range(i n 2)<block_start>total_sum<augadd>sum(arr[i:j+1])<block_end><block_end><return>total_sum<block_end>\n", "solution": "\ndef odd_length_sum (arr):\n    total_sum=0\n    n=len(arr)\n    for i in range(n):\n        for j in range(i, n, 2):\n            total_sum+=sum(arr[i:j+1])\n            \n    \n    return total_sum\n    \n\n"}
{"task_id": "Mbpp/784", "origin_solution": "<def_stmt>mul_even_odd lst<block_start>even_count=0<line_sep>odd_count=0<for_stmt>num lst<block_start><if_stmt>num%2<eq>0<block_start>even_count<augadd>1<block_end><else_stmt><block_start>odd_count<augadd>1<block_end><block_end><return>even_count<times>odd_count<block_end>\n", "solution": "\ndef mul_even_odd (lst):\n    even_count=0\n    odd_count=0\n    for num in lst:\n        if num%2==0:\n            even_count+=1\n            \n        \n        else :\n            odd_count+=1\n            \n    \n    return even_count*odd_count\n    \n\n"}
{"task_id": "Mbpp/785", "origin_solution": "<def_stmt>tuple_str_int tuple_str<block_start>tuple_str=tuple_str[1:-1]<line_sep>tuple_list=tuple_str.split(\", \")<line_sep>tuple_int=tuple(int(i)<for>i tuple_list)<line_sep><return>tuple_int<block_end>\n", "solution": "\ndef tuple_str_int (tuple_str):\n    tuple_str=tuple_str[1:-1]\n    tuple_list=tuple_str.split(\", \")\n    tuple_int=tuple(int(i) for i in tuple_list)\n    return tuple_int\n    \n\n"}
{"task_id": "Mbpp/786", "origin_solution": "<def_stmt>right_insertion arr val<block_start>left,right=0 len(arr)<while_stmt>left<l>right<block_start>mid=(left+right)<floordiv>2<if_stmt>arr[mid]<l>val<block_start>left=mid+1<block_end><else_stmt><block_start>right=mid<block_end><block_end><return>left<block_end>\n", "solution": "\ndef right_insertion (arr, val):\n    left,right=0, len(arr)\n    while left<right:\n        mid=(left+right)//2\n        if arr[mid]<val:\n            left=mid+1\n            \n        \n        else :\n            right=mid\n            \n    \n    return left\n    \n\n"}
{"task_id": "Mbpp/787", "origin_solution": "<def_stmt>text_match_three text<block_start>count=0<for_stmt>i range(len(text)-2)<block_start><if_stmt>text[i]<eq>'a'<and>text[i+1]<eq>'b'<and>text[i+2]<eq>'b'<block_start>count<augadd>1<block_end><block_end><return>count<eq>1<block_end>\n", "solution": "\ndef text_match_three (text):\n    count=0\n    for i in range(len(text)-2):\n        if text[i]=='a' and text[i+1]=='b' and text[i+2]=='b':\n            count+=1\n            \n    \n    return count==1\n    \n\n"}
{"task_id": "Mbpp/788", "origin_solution": "<def_stmt>new_tuple lst string<block_start><return>tuple(lst+[string])<block_end>\n", "solution": "\ndef new_tuple (lst, string):\n    return tuple(lst+[string])\n    \n\n"}
{"task_id": "Mbpp/790", "origin_solution": "<def_stmt>even_position lst<block_start><for_stmt>i range(0 len(lst) 2)<block_start><if_stmt>lst[i]%2<ne>0<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef even_position (lst):\n    for i in range(0, len(lst), 2):\n        if lst[i]%2!=0:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/791", "origin_solution": "<def_stmt>remove_nested t<block_start>result=[]<for_stmt>i t<block_start><if_stmt>isinstance(i tuple)<block_start>result.extend(remove_nested(i))<block_end><else_stmt><block_start>result.append(i)<block_end><block_end><return>tuple(result)<block_end>\n", "solution": "\ndef remove_nested (t):\n    result=[]\n    for i in t:\n        if isinstance(i, tuple):\n            result.extend(remove_nested(i))\n            \n        \n        else :\n            result.append(i)\n            \n    \n    return tuple(result)\n    \n\n"}
{"task_id": "Mbpp/792", "origin_solution": "<def_stmt>count_list num_lists<block_start><return>len(num_lists)<block_end>\n", "solution": "\ndef count_list (num_lists):\n    return len(num_lists)\n    \n\n"}
{"task_id": "Mbpp/793", "origin_solution": "<def_stmt>last arr x<block_start>low=0<line_sep>high=len(arr)-1<line_sep>result=-1<while_stmt>low<le>high<block_start>mid=(low+high)<floordiv>2<if_stmt>arr[mid]<eq>x<block_start>result=mid<line_sep>low=mid+1<block_end><elif_stmt>arr[mid]<l>x<block_start>low=mid+1<block_end><else_stmt><block_start>high=mid-1<block_end><block_end><return>result<block_end>\n", "solution": "\ndef last (arr, x):\n    low=0\n    high=len(arr)-1\n    result=-1\n    while low<=high:\n        mid=(low+high)//2\n        if arr[mid]==x:\n            result=mid\n            low=mid+1\n            \n        \n        elif arr[mid]<x:\n            low=mid+1\n            \n        \n        else :\n            high=mid-1\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/794", "origin_solution": "<import_stmt>re<def_stmt>text_starta_endb text<block_start>pattern=r'^a.*b$'<line_sep><return>bool(re.match(pattern text))<block_end>\n", "solution": "\nimport re\ndef text_starta_endb (text):\n    pattern=r'^a.*b$'\n    return bool(re.match(pattern, text))\n    \n\n"}
{"task_id": "Mbpp/796", "origin_solution": "<def_stmt>return_sum dictionary<block_start><return>sum(dictionary.values())<block_end>\n", "solution": "\ndef return_sum (dictionary):\n    return sum(dictionary.values())\n    \n\n"}
{"task_id": "Mbpp/797", "origin_solution": "<def_stmt>sum_in_range l r<block_start>sum=0<for_stmt>i range(l r+1)<block_start><if_stmt>i%2<ne>0<block_start>sum<augadd>i<block_end><block_end><return>sum<block_end>\n", "solution": "\ndef sum_in_range (l, r):\n    sum=0\n    for i in range(l, r+1):\n        if i%2!=0:\n            sum+=i\n            \n    \n    return sum\n    \n\n"}
{"task_id": "Mbpp/798", "origin_solution": "<def_stmt>_sum arr<block_start><return>sum(arr)<block_end>\n", "solution": "\ndef _sum (arr):\n    return sum(arr)\n    \n\n"}
{"task_id": "Mbpp/799", "origin_solution": "<def_stmt>left_rotate n d<block_start><return>((n<lshift>d)&0xffffffff)|(n<rshift>(32-d))<block_end>\n", "solution": "\ndef left_rotate (n, d):\n    return ((n<<d)&0xffffffff)|(n>>(32-d))\n    \n\n"}
{"task_id": "Mbpp/800", "origin_solution": "<def_stmt>remove_all_spaces string<block_start><return>string.replace(' ' '')<block_end>\n", "solution": "\ndef remove_all_spaces (string):\n    return string.replace(' ', '')\n    \n\n"}
{"task_id": "Mbpp/801", "origin_solution": "<def_stmt>test_three_equal a b c<block_start><return>sum([a<eq>b<eq>c])<block_end>\n", "solution": "\ndef test_three_equal (a, b, c):\n    return sum([a==b==c])\n    \n\n"}
{"task_id": "Mbpp/803", "origin_solution": "<import_stmt>math<def_stmt>is_perfect_square n<block_start>sqrt=math.sqrt(n)<line_sep><return>sqrt.is_integer()<block_end>\n", "solution": "\nimport math\ndef is_perfect_square (n):\n    sqrt=math.sqrt(n)\n    return sqrt.is_integer()\n    \n\n"}
{"task_id": "Mbpp/804", "origin_solution": "<def_stmt>is_product_even nums<block_start>product=1<for_stmt>num nums<block_start>product<augmul>num<block_end><return>product%2<eq>0<block_end>\n", "solution": "\ndef is_product_even (nums):\n    product=1\n    for num in nums:\n        product*=num\n        \n    return product%2==0\n    \n\n"}
{"task_id": "Mbpp/805", "origin_solution": "<def_stmt>max_sum_list list_of_lists<block_start>max_sum=float('-inf')<line_sep>max_list=[]<for_stmt>sublist list_of_lists<block_start>current_sum=sum(sublist)<if_stmt>current_sum<g>max_sum<block_start>max_sum=current_sum<line_sep>max_list=sublist<block_end><block_end><return>max_list<block_end>\n", "solution": "\ndef max_sum_list (list_of_lists):\n    max_sum=float('-inf')\n    max_list=[]\n    for sublist in list_of_lists:\n        current_sum=sum(sublist)\n        if current_sum>max_sum:\n            max_sum=current_sum\n            max_list=sublist\n            \n    \n    return max_list\n    \n\n"}
{"task_id": "Mbpp/806", "origin_solution": "<def_stmt>max_run_uppercase s<block_start>max_run=0<line_sep>current_run=0<for_stmt>char s<block_start><if_stmt>char.isupper()<block_start>current_run<augadd>1<line_sep>max_run=max(max_run current_run)<block_end><else_stmt><block_start>current_run=0<block_end><block_end><return>max_run<block_end>\n", "solution": "\ndef max_run_uppercase (s):\n    max_run=0\n    current_run=0\n    for char in s:\n        if char.isupper():\n            current_run+=1\n            max_run=max(max_run, current_run)\n            \n        \n        else :\n            current_run=0\n            \n    \n    return max_run\n    \n\n"}
{"task_id": "Mbpp/807", "origin_solution": "<def_stmt>first_odd nums<block_start><for_stmt>num nums<block_start><if_stmt>num%2<ne>0<block_start><return>num<block_end><block_end><return><none><block_end>\n", "solution": "\ndef first_odd (nums):\n    for num in nums:\n        if num%2!=0:\n            return num\n            \n    \n    return  None \n    \n\n"}
{"task_id": "Mbpp/808", "origin_solution": "<def_stmt>check_K test_tup K<block_start><return>K<in>test_tup<block_end>\n", "solution": "\ndef check_K (test_tup, K):\n    return K in test_tup\n    \n\n"}
{"task_id": "Mbpp/809", "origin_solution": "<def_stmt>check_smaller tuple1 tuple2<block_start><return>all(x<l>y<for>x,y zip(tuple1 tuple2))<block_end>\n", "solution": "\ndef check_smaller (tuple1, tuple2):\n    return all(x<y for x,y in zip(tuple1, tuple2))\n    \n\n"}
