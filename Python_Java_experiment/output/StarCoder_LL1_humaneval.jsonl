{"task_id": "HumanEval/0", "solution": "from typing import List\ndef has_close_elements(numbers:List[float], threshold:float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) <= threshold:\n            return True\n    return False\n", "origin_solution": "from typing import List\ndef has_close_elements(TYPEP numbers:List[float], TYPEP threshold:float) -> bool: INDENT\n\"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\ncall ATTR numbers.sort()\nfor i in call range(- call len(numbers) 1): INDENT\nif call abs(- SUB numbers[i] SUB numbers[+ i 1]) <= threshold: INDENT\nreturn True\nDEDENT\nDEDENT\nreturn False\nDEDENT\n\n"}
{"task_id": "HumanEval/1", "solution": "from typing import List\ndef separate_paren_groups(paren_string:str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    stack = []\n    result = []\n    current_group = \"\"\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n            current_group += char\n        elif char == ')':\n            current_group += char\n            stack.pop()\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"\n    return result\nprint(separate_paren_groups('( ) (( )) (( )( ))'))\n", "origin_solution": "from typing import List\ndef separate_paren_groups(TYPEP paren_string:str) -> List[str]: INDENT\n= paren_string call ATTR paren_string.replace(\" \", \"\")\n= stack LIST[]\n= result LIST[]\n= current_group \"\"\nfor char in paren_string: INDENT\nif char == '(': INDENT\ncall ATTR stack.append(char)\n+= current_group char\nDEDENT\nelif char == ')': INDENT\n+= current_group char\ncall ATTR stack.pop()\nif NOT stack: INDENT\ncall ATTR result.append(current_group)\n= current_group \"\"\nDEDENT\nDEDENT\nDEDENT\nreturn result\nDEDENT\ncall print(call separate_paren_groups('( ) (( )) (( )( ))'))\n\n"}
{"task_id": "HumanEval/2", "solution": "def truncate_number(number:float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return number - int(number)\n", "origin_solution": "def truncate_number(TYPEP number:float) -> float: INDENT\n\"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nreturn - number call int(number)\nDEDENT\n\n"}
{"task_id": "HumanEval/3", "solution": "from typing import List\ndef below_zero(operations:List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n", "origin_solution": "from typing import List\ndef below_zero(TYPEP operations:List[int]) -> bool: INDENT\n= balance 0\nfor operation in operations: INDENT\n+= balance operation\nif balance < 0: INDENT\nreturn True\nDEDENT\nDEDENT\nreturn False\nDEDENT\n\n"}
{"task_id": "HumanEval/4", "solution": "from typing import List\ndef mean_absolute_deviation(numbers:List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(num - mean) for num in numbers]\n    return sum(absolute_deviations) / len(numbers)\n", "origin_solution": "from typing import List\ndef mean_absolute_deviation(TYPEP numbers:List[float]) -> float: INDENT\n\"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\nif NOT numbers: INDENT\nreturn 0.0\nDEDENT\n= mean / call sum(numbers) call len(numbers)\n= absolute_deviations LIST[call abs(- num mean) for num in numbers]\nreturn / call sum(absolute_deviations) call len(numbers)\nDEDENT\n\n"}
{"task_id": "HumanEval/5", "solution": "from typing import List\ndef intersperse(numbers:List[int], delimeter:int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    if not numbers:\n        return []\n    result = [numbers[0]]\n    for number in numbers[1:]:\n        result.extend([delimeter, number])\n    return result\n", "origin_solution": "from typing import List\ndef intersperse(TYPEP numbers:List[int], TYPEP delimeter:int) -> List[int]: INDENT\n\"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nif NOT numbers: INDENT\nreturn LIST[]\nDEDENT\n= result LIST[SUB numbers[0]]\nfor number in SUB numbers[1:]: INDENT\ncall ATTR result.extend(LIST[delimeter, number])\nDEDENT\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/6", "solution": "from typing import List\ndef parse_nested_parens(paren_string:str) -> List[int]:\n    groups = paren_string.split()\n    result = []\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        result.append(max_depth)\n    return result\n", "origin_solution": "from typing import List\ndef parse_nested_parens(TYPEP paren_string:str) -> List[int]: INDENT\n= groups call ATTR paren_string.split()\n= result LIST[]\nfor group in groups: INDENT\n= max_depth 0\n= current_depth 0\nfor char in group: INDENT\nif char == '(': INDENT\n+= current_depth 1\n= max_depth call max(max_depth, current_depth)\nDEDENT\nelif char == ')': INDENT\n-= current_depth 1\nDEDENT\nDEDENT\ncall ATTR result.append(max_depth)\nDEDENT\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/7", "solution": "from typing import List\ndef filter_by_substring(strings:List[str], substring:str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]\n", "origin_solution": "from typing import List\ndef filter_by_substring(TYPEP strings:List[str], TYPEP substring:str) -> List[str]: INDENT\n\"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\nreturn LIST[s for s in strings if substring in s]\nDEDENT\n\n"}
{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple\ndef sum_product(numbers:List[int]) -> Tuple[int, int]:\n    total_sum = 0\n    total_product = 1\n    for number in numbers:\n        total_sum += number\n        total_product *= number\n    return total_sum, total_product\n", "origin_solution": "from typing import List, Tuple\ndef sum_product(TYPEP numbers:List[int]) -> Tuple[int, int]: INDENT\n= total_sum 0\n= total_product 1\nfor number in numbers: INDENT\n+= total_sum number\n*= total_product number\nDEDENT\nreturn total_sum, total_product\nDEDENT\n\n"}
{"task_id": "HumanEval/9", "solution": "from typing import List\ndef rolling_max(numbers:List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    max_so_far = numbers[0]\n    result = []\n    for num in numbers:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result\n", "origin_solution": "from typing import List\ndef rolling_max(TYPEP numbers:List[int]) -> List[int]: INDENT\n\"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\nif NOT numbers: INDENT\nreturn LIST[]\nDEDENT\n= max_so_far SUB numbers[0]\n= result LIST[]\nfor num in numbers: INDENT\nif num > max_so_far: INDENT\n= max_so_far num\nDEDENT\ncall ATTR result.append(max_so_far)\nDEDENT\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/10", "solution": "def is_palindrome(string:str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\ndef make_palindrome(string:str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string\n", "origin_solution": "def is_palindrome(TYPEP string:str) -> bool: INDENT\n\"\"\" Test if given string is a palindrome \"\"\"\nreturn string == SUB string[::NEG 1]\nDEDENT\ndef make_palindrome(TYPEP string:str) -> str: INDENT\n\"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\nif NOT string: INDENT\nreturn string\nDEDENT\nfor i in call range(call len(string)): INDENT\nif call is_palindrome(SUB string[i:]): INDENT\nreturn + string SUB SUB string[:i][::NEG 1]\nDEDENT\nDEDENT\nreturn string\nDEDENT\n\n"}
{"task_id": "HumanEval/11", "solution": "from typing import List\ndef string_xor(a:str, b:str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += \"0\"\n        else:\n            result += \"1\"\n    return result\n", "origin_solution": "from typing import List\ndef string_xor(TYPEP a:str, TYPEP b:str) -> str: INDENT\n\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n= result \"\"\nfor i in call range(call len(a)): INDENT\nif SUB a[i] == SUB b[i]: INDENT\n+= result \"0\"\nDEDENT\nelse: INDENT\n+= result \"1\"\nDEDENT\nDEDENT\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/12", "solution": "from typing import List, Optional\ndef longest(strings:List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if not strings:\n        return None\n    longest_string = strings[0]\n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n    return longest_string\n", "origin_solution": "from typing import List, Optional\ndef longest(TYPEP strings:List[str]) -> Optional[str]: INDENT\n\"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\nif NOT strings: INDENT\nreturn None\nDEDENT\n= longest_string SUB strings[0]\nfor string in strings: INDENT\nif call len(string) > call len(longest_string): INDENT\n= longest_string string\nDEDENT\nDEDENT\nreturn longest_string\nDEDENT\n\n"}
{"task_id": "HumanEval/13", "solution": "def greatest_common_divisor(a:int, b:int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a\n", "origin_solution": "def greatest_common_divisor(TYPEP a:int, TYPEP b:int) -> int: INDENT\n\"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\nwhile b != 0: INDENT\n= a, b b, % a b\nDEDENT\nreturn a\nDEDENT\n\n"}
{"task_id": "HumanEval/14", "solution": "from typing import List\ndef all_prefixes(string:str) -> List[str]:\n    prefixes = []\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    return prefixes\n", "origin_solution": "from typing import List\ndef all_prefixes(TYPEP string:str) -> List[str]: INDENT\n= prefixes LIST[]\nfor i in call range(1, + call len(string) 1): INDENT\ncall ATTR prefixes.append(SUB string[:i])\nDEDENT\nreturn prefixes\nDEDENT\n\n"}
{"task_id": "HumanEval/15", "solution": "def string_sequence(n:int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    return ' '.join(str(i) for i in range(n + 1))\n", "origin_solution": "def string_sequence(TYPEP n:int) -> str: INDENT\n\"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\nreturn call ATTR ' '.join(call str(i) for i in call range(+ n 1))\nDEDENT\n\n"}
{"task_id": "HumanEval/16", "solution": "def count_distinct_characters(string:str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_characters = set(string.lower())\n    return len(distinct_characters)\n", "origin_solution": "def count_distinct_characters(TYPEP string:str) -> int: INDENT\n\"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n= distinct_characters call set(call ATTR string.lower())\nreturn call len(distinct_characters)\nDEDENT\n\n"}
{"task_id": "HumanEval/17", "solution": "from typing import List\ndef parse_music(music_string:str) -> List[int]:\n    beats = []\n    notes = music_string.split()\n    for note in notes:\n        if note == 'o':\n            beats.append(4)\n        elif note == 'o|':\n            beats.append(2)\n        elif note == '.|':\n            beats.append(1)\n    return beats\n", "origin_solution": "from typing import List\ndef parse_music(TYPEP music_string:str) -> List[int]: INDENT\n= beats LIST[]\n= notes call ATTR music_string.split()\nfor note in notes: INDENT\nif note == 'o': INDENT\ncall ATTR beats.append(4)\nDEDENT\nelif note == 'o|': INDENT\ncall ATTR beats.append(2)\nDEDENT\nelif note == '.|': INDENT\ncall ATTR beats.append(1)\nDEDENT\nDEDENT\nreturn beats\nDEDENT\n\n"}
{"task_id": "HumanEval/18", "solution": "def how_many_times(string:str, substring:str) -> int:\n    count = 0\n    start = 0\n    while True:\n        start = string.find(substring, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            break\n    return count\n", "origin_solution": "def how_many_times(TYPEP string:str, TYPEP substring:str) -> int: INDENT\n= count 0\n= start 0\nwhile True: INDENT\n= start + call ATTR string.find(substring, start) 1\nif start > 0: INDENT\n+= count 1\nDEDENT\nelse: INDENT\nbreak\nDEDENT\nDEDENT\nreturn count\nDEDENT\n\n"}
{"task_id": "HumanEval/19", "solution": "from typing import List\ndef sort_numbers(numbers:str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n    number_list = numbers.split()\n    number_dict = {'zero':0, 'one':1, 'two':2, 'three':3, 'four':4, 'five':5, 'six':6, 'seven':7, 'eight':8, 'nine':9}\n    sorted_numbers = sorted(number_list, key=lambda x: number_dict[x])\n    return ' '.join(sorted_numbers)\n", "origin_solution": "from typing import List\ndef sort_numbers(TYPEP numbers:str) -> str: INDENT\n\"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n= number_list call ATTR numbers.split()\n= number_dict DICT {'zero':0, 'one':1, 'two':2, 'three':3, 'four':4, 'five':5, 'six':6, 'seven':7, 'eight':8, 'nine':9}\n= sorted_numbers call sorted(number_list, key=lambda x: SUB number_dict[x])\nreturn call ATTR ' '.join(sorted_numbers)\nDEDENT\n\n"}
{"task_id": "HumanEval/20", "solution": "from typing import List, Tuple\ndef find_closest_elements(numbers:List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    closest_pair = (None, None)\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n    return closest_pair\n", "origin_solution": "from typing import List, Tuple\ndef find_closest_elements(TYPEP numbers:List[float]) -> Tuple[float, float]: INDENT\n= min_diff call float('inf')\n= closest_pair TUPLE (None, None)\nfor i in call range(call len(numbers)): INDENT\nfor j in call range(+ i 1, call len(numbers)): INDENT\n= diff call abs(- SUB numbers[i] SUB numbers[j])\nif diff < min_diff: INDENT\n= min_diff diff\n= closest_pair TUPLE (call min(SUB numbers[i], SUB numbers[j]), call max(SUB numbers[i], SUB numbers[j]))\nDEDENT\nDEDENT\nDEDENT\nreturn closest_pair\nDEDENT\n\n"}
{"task_id": "HumanEval/21", "solution": "from typing import List\ndef rescale_to_unit(numbers:List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    if range_val == 0:\n        return [0.0] * len(numbers)\n    return [(num - min_val) / range_val for num in numbers]\n", "origin_solution": "from typing import List\ndef rescale_to_unit(TYPEP numbers:List[float]) -> List[float]: INDENT\n\"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n= min_val call min(numbers)\n= max_val call max(numbers)\n= range_val - max_val min_val\nif range_val == 0: INDENT\nreturn * LIST[0.0] call len(numbers)\nDEDENT\nreturn LIST[/ (- num min_val) range_val for num in numbers]\nDEDENT\n\n"}
{"task_id": "HumanEval/22", "solution": "from typing import List, Any\ndef filter_integers(values:List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]\n", "origin_solution": "from typing import List, Any\ndef filter_integers(TYPEP values:List[Any]) -> List[int]: INDENT\n\"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\nreturn LIST[value for value in values if call isinstance(value, int)]\nDEDENT\n\n"}
{"task_id": "HumanEval/23", "solution": "def strlen(string:str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)\n", "origin_solution": "def strlen(TYPEP string:str) -> int: INDENT\n\"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\nreturn call len(string)\nDEDENT\n\n"}
{"task_id": "HumanEval/24", "solution": "def largest_divisor(n:int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n", "origin_solution": "def largest_divisor(TYPEP n:int) -> int: INDENT\n\"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\nfor i in call range(- n 1, 0, NEG 1): INDENT\nif % n i == 0: INDENT\nreturn i\nDEDENT\nDEDENT\nDEDENT\n\n"}
{"task_id": "HumanEval/25", "solution": "from typing import List\ndef factorize(n:int) -> List[int]:\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n", "origin_solution": "from typing import List\ndef factorize(TYPEP n:int) -> List[int]: INDENT\n= factors LIST[]\n= i 2\nwhile * i i <= n: INDENT\nif % n i: INDENT\n+= i 1\nDEDENT\nelse: INDENT\n//= n i\ncall ATTR factors.append(i)\nDEDENT\nDEDENT\nif n > 1: INDENT\ncall ATTR factors.append(n)\nDEDENT\nreturn factors\nDEDENT\n\n"}
{"task_id": "HumanEval/26", "solution": "from typing import List\ndef remove_duplicates(numbers:List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            seen.add(number)\n            result.append(number)\n    return result\n", "origin_solution": "from typing import List\ndef remove_duplicates(TYPEP numbers:List[int]) -> List[int]: INDENT\n\"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n= seen call set()\n= result LIST[]\nfor number in numbers: INDENT\nif number not in seen: INDENT\ncall ATTR seen.add(number)\ncall ATTR result.append(number)\nDEDENT\nDEDENT\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/27", "solution": "def flip_case(string:str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n    flipped_string = \"\"\n    for char in string:\n        if char.islower():\n            flipped_string += char.upper()\n        elif char.isupper():\n            flipped_string += char.lower()\n        else:\n            flipped_string += char\n    return flipped_string\n", "origin_solution": "def flip_case(TYPEP string:str) -> str: INDENT\n\"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n= flipped_string \"\"\nfor char in string: INDENT\nif call ATTR char.islower(): INDENT\n+= flipped_string call ATTR char.upper()\nDEDENT\nelif call ATTR char.isupper(): INDENT\n+= flipped_string call ATTR char.lower()\nDEDENT\nelse: INDENT\n+= flipped_string char\nDEDENT\nDEDENT\nreturn flipped_string\nDEDENT\n\n"}
{"task_id": "HumanEval/28", "solution": "from typing import List\ndef concatenate(strings:List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    return ''.join(strings)\n", "origin_solution": "from typing import List\ndef concatenate(TYPEP strings:List[str]) -> str: INDENT\n\"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\nreturn call ATTR ''.join(strings)\nDEDENT\n\n"}
{"task_id": "HumanEval/29", "solution": "from typing import List\ndef filter_by_prefix(strings:List[str], prefix:str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]\n", "origin_solution": "from typing import List\ndef filter_by_prefix(TYPEP strings:List[str], TYPEP prefix:str) -> List[str]: INDENT\n\"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\nreturn LIST[s for s in strings if call ATTR s.startswith(prefix)]\nDEDENT\n\n"}
{"task_id": "HumanEval/30", "solution": "def get_positive(l:list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [num for num in l if num > 0]\n", "origin_solution": "def get_positive(TYPEP l:list): INDENT\n\"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\nreturn LIST[num for num in l if num > 0]\nDEDENT\n\n"}
{"task_id": "HumanEval/31", "solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n", "origin_solution": "def is_prime(n): INDENT\n\"\"\"Return true if a given number is prime, and false otherwise.\n    \"\"\"\nif n <= 1: INDENT\nreturn False\nDEDENT\nif n <= 3: INDENT\nreturn True\nDEDENT\nif or % n 2 == 0 % n 3 == 0: INDENT\nreturn False\nDEDENT\n= i 5\nwhile * i i <= n: INDENT\nif or % n i == 0 % n (+ i 2) == 0: INDENT\nreturn False\nDEDENT\n+= i 6\nDEDENT\nreturn True\nDEDENT\n\n"}
{"task_id": "HumanEval/32", "solution": "import math\ndef poly(xs:list, x:float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\ndef find_zero(xs:list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    for i in range(len(xs)):\n        if xs[i] != 0:\n            return poly(xs[:i], 0)\n    return None\nprint(find_zero([1, 2]))\nprint(find_zero([-6, 11, -6, 1]))\n", "origin_solution": "import math\ndef poly(TYPEP xs:list, TYPEP x:float): INDENT\n\"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\nreturn call sum(LIST[* coeff call ATTR math.pow(x, i) for i, coeff in call enumerate(xs)])\nDEDENT\ndef find_zero(TYPEP xs:list): INDENT\n\"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\nfor i in call range(call len(xs)): INDENT\nif SUB xs[i] != 0: INDENT\nreturn call poly(SUB xs[:i], 0)\nDEDENT\nDEDENT\nreturn None\nDEDENT\ncall print(call find_zero(LIST[1, 2]))\ncall print(call find_zero(LIST[NEG 6, 11, NEG 6, 1]))\n\n"}
{"task_id": "HumanEval/33", "solution": "def sort_third(l:list):\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    divisible_by_three.sort()\n    result = []\n    divisible_by_three_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(divisible_by_three[divisible_by_three_index])\n            divisible_by_three_index += 1\n        else:\n            result.append(l[i])\n    return result\n", "origin_solution": "def sort_third(TYPEP l:list): INDENT\n= divisible_by_three LIST[SUB l[i] for i in call range(call len(l)) if % i 3 == 0]\ncall ATTR divisible_by_three.sort()\n= result LIST[]\n= divisible_by_three_index 0\nfor i in call range(call len(l)): INDENT\nif % i 3 == 0: INDENT\ncall ATTR result.append(SUB divisible_by_three[divisible_by_three_index])\n+= divisible_by_three_index 1\nDEDENT\nelse: INDENT\ncall ATTR result.append(SUB l[i])\nDEDENT\nDEDENT\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/34", "solution": "def unique(l:list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))\n", "origin_solution": "def unique(TYPEP l:list): INDENT\n\"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\nreturn call sorted(call set(l))\nDEDENT\n\n"}
{"task_id": "HumanEval/35", "solution": "def max_element(l:list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max_val = l[0]\n    for i in l:\n        if i > max_val:\n            max_val = i\n    return max_val\n", "origin_solution": "def max_element(TYPEP l:list): INDENT\n\"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n= max_val SUB l[0]\nfor i in l: INDENT\nif i > max_val: INDENT\n= max_val i\nDEDENT\nDEDENT\nreturn max_val\nDEDENT\n\n"}
{"task_id": "HumanEval/36", "solution": "def fizz_buzz(n:int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count\n", "origin_solution": "def fizz_buzz(TYPEP n:int) -> int: INDENT\n= count 0\nfor i in call range(1, n): INDENT\nif or % i 11 == 0 % i 13 == 0: INDENT\n+= count call ATTR call str(i).count('7')\nDEDENT\nDEDENT\nreturn count\nDEDENT\n\n"}
{"task_id": "HumanEval/37", "solution": "def sort_even(l:list):\n    even_indices = [i for i in range(0, len(l), 2)]\n    even_values = [l[i] for i in even_indices]\n    even_values.sort()\n    for i, index in enumerate(even_indices):\n        l[index] = even_values[i]\n    return l\n", "origin_solution": "def sort_even(TYPEP l:list): INDENT\n= even_indices LIST[i for i in call range(0, call len(l), 2)]\n= even_values LIST[SUB l[i] for i in even_indices]\ncall ATTR even_values.sort()\nfor i, index in call enumerate(even_indices): INDENT\n= SUB l[index] SUB even_values[i]\nDEDENT\nreturn l\nDEDENT\n\n"}
{"task_id": "HumanEval/38", "solution": "def encode_cyclic(s:str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\ndef decode_cyclic(s:str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n", "origin_solution": "def encode_cyclic(TYPEP s:str): INDENT\n\"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n= groups LIST[SUB s[(* 3 i):call min((+ * 3 i 3), call len(s))] for i in call range(// (+ call len(s) 2) 3)]\n= groups LIST[(+ SUB group[1:] SUB group[0]) if call len(group) == 3 else group for group in groups]\nreturn call ATTR \"\".join(groups)\nDEDENT\ndef decode_cyclic(TYPEP s:str): INDENT\n\"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n= groups LIST[SUB s[(* 3 i):call min((+ * 3 i 3), call len(s))] for i in call range(// (+ call len(s) 2) 3)]\n= groups LIST[(+ SUB group[NEG 1] SUB group[:NEG 1]) if call len(group) == 3 else group for group in groups]\nreturn call ATTR \"\".join(groups)\nDEDENT\n\n"}
{"task_id": "HumanEval/39", "solution": "def prime_fib(n:int):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    def fib(n):\n        a, b = 0, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return a\n    count = 0\n    i = 1\n    while True:\n        fib_num = fib(i)\n        if is_prime(fib_num):\n            count += 1\n            if count == n:\n                return fib_num\n        i += 1\n", "origin_solution": "def prime_fib(TYPEP n:int): INDENT\ndef is_prime(num): INDENT\nif num < 2: INDENT\nreturn False\nDEDENT\nfor i in call range(2, + call int(** num 0.5) 1): INDENT\nif % num i == 0: INDENT\nreturn False\nDEDENT\nDEDENT\nreturn True\nDEDENT\ndef fib(n): INDENT\n= a, b 0, 1\nfor _ in call range(n): INDENT\n= a, b b, + a b\nDEDENT\nreturn a\nDEDENT\n= count 0\n= i 1\nwhile True: INDENT\n= fib_num call fib(i)\nif call is_prime(fib_num): INDENT\n+= count 1\nif count == n: INDENT\nreturn fib_num\nDEDENT\nDEDENT\n+= i 1\nDEDENT\nDEDENT\n\n"}
{"task_id": "HumanEval/40", "solution": "def triples_sum_to_zero(l:list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n    l.sort()\n    for i in range(len(l) - 2):\n        if i > 0 and l[i] == l[i - 1]:\n            continue\n        left, right = i + 1, len(l) - 1\n        while left < right:\n            total = l[i] + l[left] + l[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return False\n", "origin_solution": "def triples_sum_to_zero(TYPEP l:list): INDENT\n\"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\ncall ATTR l.sort()\nfor i in call range(- call len(l) 2): INDENT\nif and i > 0 SUB l[i] == SUB l[- i 1]: INDENT\ncontinue\nDEDENT\n= left, right + i 1, - call len(l) 1\nwhile left < right: INDENT\n= total + + SUB l[i] SUB l[left] SUB l[right]\nif total == 0: INDENT\nreturn True\nDEDENT\nelif total < 0: INDENT\n+= left 1\nDEDENT\nelse: INDENT\n-= right 1\nDEDENT\nDEDENT\nDEDENT\nreturn False\nDEDENT\n\n"}
{"task_id": "HumanEval/41", "solution": "def car_race_collision(n:int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n    return n * (n - 1) // 2\n", "origin_solution": "def car_race_collision(TYPEP n:int): INDENT\n\"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\nreturn // * n (- n 1) 2\nDEDENT\n\n"}
{"task_id": "HumanEval/42", "solution": "def incr_list(l:list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return [i + 1 for i in l]\n", "origin_solution": "def incr_list(TYPEP l:list): INDENT\n\"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\nreturn LIST[+ i 1 for i in l]\nDEDENT\n\n"}
{"task_id": "HumanEval/43", "solution": "def pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    \"\"\"\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n", "origin_solution": "def pairs_sum_to_zero(l): INDENT\n\"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    \"\"\"\n= seen call set()\nfor num in l: INDENT\nif NEG num in seen: INDENT\nreturn True\nDEDENT\ncall ATTR seen.add(num)\nDEDENT\nreturn False\nDEDENT\n\n"}
{"task_id": "HumanEval/44", "solution": "def change_base(x:int, base:int) -> str:\n    if x == 0:\n        return '0'\n    digits = \"0123456789ABCDEF\"\n    result = \"\"\n    while x > 0:\n        result = digits[x % base] + result\n        x //= base\n    return result\n", "origin_solution": "def change_base(TYPEP x:int, TYPEP base:int) -> str: INDENT\nif x == 0: INDENT\nreturn '0'\nDEDENT\n= digits \"0123456789ABCDEF\"\n= result \"\"\nwhile x > 0: INDENT\n= result + SUB digits[% x base] result\n//= x base\nDEDENT\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/45", "solution": "def triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    area = 0.5 * a * h\n    return area\n", "origin_solution": "def triangle_area(a, h): INDENT\n\"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n= area * * 0.5 a h\nreturn area\nDEDENT\n\n"}
{"task_id": "HumanEval/46", "solution": "def fib4(n:int) -> int:\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    a, b, c, d = 0, 0, 2, 0\n    for i in range(4, n + 1):\n        a, b, c, d = b, c, d, a + b + c + d\n    return d\n", "origin_solution": "def fib4(TYPEP n:int) -> int: INDENT\nif or n == 0 n == 1: INDENT\nreturn 0\nDEDENT\nelif n == 2: INDENT\nreturn 2\nDEDENT\nelif n == 3: INDENT\nreturn 0\nDEDENT\n= a, b, c, d 0, 0, 2, 0\nfor i in call range(4, + n 1): INDENT\n= a, b, c, d b, c, d, + + + a b c d\nDEDENT\nreturn d\nDEDENT\n\n"}
{"task_id": "HumanEval/47", "solution": "def median(l:list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    if n % 2 == 1:\n        return sorted_list[n // 2]\n    else:\n        return (sorted_list[n // 2 - 1] + sorted_list[n // 2]) / 2\n", "origin_solution": "def median(TYPEP l:list): INDENT\n\"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n= sorted_list call sorted(l)\n= n call len(sorted_list)\nif % n 2 == 1: INDENT\nreturn SUB sorted_list[// n 2]\nDEDENT\nelse: INDENT\nreturn / (+ SUB sorted_list[- // n 2 1] SUB sorted_list[// n 2]) 2\nDEDENT\nDEDENT\n\n"}
{"task_id": "HumanEval/48", "solution": "def is_palindrome(text:str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    \"\"\"\n    text = text.lower()\n    reversed_text = text[::-1]\n    return text == reversed_text\n", "origin_solution": "def is_palindrome(TYPEP text:str) -> bool: INDENT\n\"\"\"\n    Checks if given string is a palindrome\n    \"\"\"\n= text call ATTR text.lower()\n= reversed_text SUB text[::NEG 1]\nreturn text == reversed_text\nDEDENT\n\n"}
{"task_id": "HumanEval/49", "solution": "def modp(n:int, p:int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1\n    return (modp(n // 2, p) * modp(n % 2, p)) % p\n", "origin_solution": "def modp(TYPEP n:int, TYPEP p:int): INDENT\n\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nif n == 0: INDENT\nreturn 1\nDEDENT\nreturn % (* call modp(// n 2, p) call modp(% n 2, p)) p\nDEDENT\n\n"}
{"task_id": "HumanEval/50", "solution": "def encode_shift(s:str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\ndef decode_shift(s:str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n", "origin_solution": "def encode_shift(TYPEP s:str): INDENT\n\"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\nreturn call ATTR \"\".join(LIST[call chr(+ (% (- + call ord(ch) 5 call ord(\"a\")) 26) call ord(\"a\")) for ch in s])\nDEDENT\ndef decode_shift(TYPEP s:str): INDENT\n\"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\nreturn call ATTR \"\".join(LIST[call chr(+ (% (- - call ord(ch) 5 call ord(\"a\")) 26) call ord(\"a\")) for ch in s])\nDEDENT\n\n"}
{"task_id": "HumanEval/51", "solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])\n", "origin_solution": "def remove_vowels(text): INDENT\n\"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n= vowels 'aeiouAEIOU'\nreturn call ATTR ''.join(LIST[char for char in text if char not in vowels])\nDEDENT\n\n"}
{"task_id": "HumanEval/52", "solution": "def below_threshold(l:list, t:int) -> bool:\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all(x < t for x in l)\n", "origin_solution": "def below_threshold(TYPEP l:list, TYPEP t:int) -> bool: INDENT\n\"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\nreturn call all(x < t for x in l)\nDEDENT\n\n"}
{"task_id": "HumanEval/53", "solution": "def add(x:int, y:int) -> int:\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\n", "origin_solution": "def add(TYPEP x:int, TYPEP y:int) -> int: INDENT\n\"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\nreturn + x y\nDEDENT\n\n"}
{"task_id": "HumanEval/54", "solution": "def same_chars(s0:str, s1:str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)\n", "origin_solution": "def same_chars(TYPEP s0:str, TYPEP s1:str) -> bool: INDENT\n\"\"\"\n    Check if two words have the same characters.\n    \"\"\"\nreturn call set(s0) == call set(s1)\nDEDENT\n\n"}
{"task_id": "HumanEval/55", "solution": "def fib(n:int) -> int:\n    if n <= 1:\n        return n\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n", "origin_solution": "def fib(TYPEP n:int) -> int: INDENT\nif n <= 1: INDENT\nreturn n\nDEDENT\nelse: INDENT\n= a, b 0, 1\nfor _ in call range(2, + n 1): INDENT\n= a, b b, + a b\nDEDENT\nreturn b\nDEDENT\nDEDENT\n\n"}
{"task_id": "HumanEval/56", "solution": "def correct_bracketing(brackets:str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n", "origin_solution": "def correct_bracketing(TYPEP brackets:str) -> bool: INDENT\n= stack LIST[]\nfor bracket in brackets: INDENT\nif bracket == \"<\": INDENT\ncall ATTR stack.append(bracket)\nDEDENT\nelif bracket == \">\": INDENT\nif call len(stack) == 0: INDENT\nreturn False\nDEDENT\ncall ATTR stack.pop()\nDEDENT\nDEDENT\nreturn call len(stack) == 0\nDEDENT\n\n"}
{"task_id": "HumanEval/57", "solution": "def monotonic(l:list):\n    if len(l) <= 1:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(l)):\n        if l[i] > l[i - 1]:\n            decreasing = False\n        elif l[i] < l[i - 1]:\n            increasing = False\n    return increasing or decreasing\n", "origin_solution": "def monotonic(TYPEP l:list): INDENT\nif call len(l) <= 1: INDENT\nreturn True\nDEDENT\n= increasing = decreasing True\nfor i in call range(1, call len(l)): INDENT\nif SUB l[i] > SUB l[- i 1]: INDENT\n= decreasing False\nDEDENT\nelif SUB l[i] < SUB l[- i 1]: INDENT\n= increasing False\nDEDENT\nDEDENT\nreturn or increasing decreasing\nDEDENT\n\n"}
{"task_id": "HumanEval/58", "solution": "def common(l1:list, l2:list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    return sorted(list(common_elements))\n", "origin_solution": "def common(TYPEP l1:list, TYPEP l2:list): INDENT\n\"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n= set1 call set(l1)\n= set2 call set(l2)\n= common_elements call ATTR set1.intersection(set2)\nreturn call sorted(call list(common_elements))\nDEDENT\n\n"}
{"task_id": "HumanEval/59", "solution": "def largest_prime_factor(n:int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n", "origin_solution": "def largest_prime_factor(TYPEP n:int): INDENT\n\"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n= i 2\nwhile * i i <= n: INDENT\nif % n i: INDENT\n+= i 1\nDEDENT\nelse: INDENT\n//= n i\nDEDENT\nDEDENT\nreturn n\nDEDENT\n\n"}
{"task_id": "HumanEval/60", "solution": "def sum_to_n(n:int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2\n", "origin_solution": "def sum_to_n(TYPEP n:int) -> int: INDENT\n\"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\nreturn // * n (+ n 1) 2\nDEDENT\n\n"}
{"task_id": "HumanEval/61", "solution": "def correct_bracketing(brackets:str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n", "origin_solution": "def correct_bracketing(TYPEP brackets:str) -> bool: INDENT\n= stack LIST[]\nfor bracket in brackets: INDENT\nif bracket == \"(\": INDENT\ncall ATTR stack.append(bracket)\nDEDENT\nelif bracket == \")\": INDENT\nif call len(stack) == 0: INDENT\nreturn False\nDEDENT\nelse: INDENT\ncall ATTR stack.pop()\nDEDENT\nDEDENT\nDEDENT\nreturn call len(stack) == 0\nDEDENT\n\n"}
{"task_id": "HumanEval/62", "solution": "def derivative(xs:list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    derivative_coeffs = []\n    for power, coeff in enumerate(xs):\n        if power == 0:\n            continue\n        derivative_coeffs.append(coeff * power)\n    return derivative_coeffs\n", "origin_solution": "def derivative(TYPEP xs:list): INDENT\n\"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n= derivative_coeffs LIST[]\nfor power, coeff in call enumerate(xs): INDENT\nif power == 0: INDENT\ncontinue\nDEDENT\ncall ATTR derivative_coeffs.append(* coeff power)\nDEDENT\nreturn derivative_coeffs\nDEDENT\n\n"}
{"task_id": "HumanEval/63", "solution": "def fibfib(n:int) -> int:\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    a, b, c = 0, 0, 1\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    return c\n", "origin_solution": "def fibfib(TYPEP n:int) -> int: INDENT\nif or n == 0 n == 1: INDENT\nreturn 0\nDEDENT\nelif n == 2: INDENT\nreturn 1\nDEDENT\n= a, b, c 0, 0, 1\nfor _ in call range(3, + n 1): INDENT\n= a, b, c b, c, + + a b c\nDEDENT\nreturn c\nDEDENT\n\n"}
{"task_id": "HumanEval/64", "solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    count = 0\n    for i in range(len(s)):\n        if s[i].lower() in vowels:\n            count += 1\n    if s[-1].lower() == 'y':\n        count += 1\n    return count\n", "origin_solution": "def vowels_count(s): INDENT\n= vowels 'aeiou'\n= count 0\nfor i in call range(call len(s)): INDENT\nif call ATTR SUB s[i].lower() in vowels: INDENT\n+= count 1\nDEDENT\nDEDENT\nif call ATTR SUB s[NEG 1].lower() == 'y': INDENT\n+= count 1\nDEDENT\nreturn count\nDEDENT\n\n"}
{"task_id": "HumanEval/65", "solution": "def circular_shift(x, shift):\n    x_str = str(x)\n    n = len(x_str)\n    shift %= n\n    if shift == 0:\n        return x_str\n    if shift > n:\n        shift = n\n    return x_str[-shift:] + x_str[:-shift]\n", "origin_solution": "def circular_shift(x, shift): INDENT\n= x_str call str(x)\n= n call len(x_str)\n%= shift n\nif shift == 0: INDENT\nreturn x_str\nDEDENT\nif shift > n: INDENT\n= shift n\nDEDENT\nreturn + SUB x_str[NEG shift:] SUB x_str[:NEG shift]\nDEDENT\n\n"}
{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n    return sum(ord(c) for c in s if c.isupper())\n", "origin_solution": "def digitSum(s): INDENT\n\"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\nreturn call sum(call ord(c) for c in s if call ATTR c.isupper())\nDEDENT\n\n"}
{"task_id": "HumanEval/67", "solution": "def fruit_distribution(s, n):\n    parts = s.split()\n    oranges = int(parts[0])\n    apples = int(parts[3])\n    mango_fruits = n - oranges - apples\n    return mango_fruits\n", "origin_solution": "def fruit_distribution(s, n): INDENT\n= parts call ATTR s.split()\n= oranges call int(SUB parts[0])\n= apples call int(SUB parts[3])\n= mango_fruits - - n oranges apples\nreturn mango_fruits\nDEDENT\n\n"}
{"task_id": "HumanEval/68", "solution": "def pluck(arr):\n    smallest_even = None\n    smallest_index = None\n    for i, value in enumerate(arr):\n        if value % 2 == 0:\n            if smallest_even is None or value < smallest_even:\n                smallest_even = value\n                smallest_index = i\n    if smallest_even is None:\n        return []\n    else:\n        return [smallest_even, smallest_index]\n", "origin_solution": "def pluck(arr): INDENT\n= smallest_even None\n= smallest_index None\nfor i, value in call enumerate(arr): INDENT\nif % value 2 == 0: INDENT\nif or smallest_even is None value < smallest_even: INDENT\n= smallest_even value\n= smallest_index i\nDEDENT\nDEDENT\nDEDENT\nif smallest_even is None: INDENT\nreturn LIST[]\nDEDENT\nelse: INDENT\nreturn LIST[smallest_even, smallest_index]\nDEDENT\nDEDENT\n\n"}
{"task_id": "HumanEval/69", "solution": "def search(lst):\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    max_val = -1\n    for num, count in freq.items():\n        if count >= num and num > max_val:\n            max_val = num\n    return max_val\n", "origin_solution": "def search(lst): INDENT\n= freq DICT {}\nfor num in lst: INDENT\nif num in freq: INDENT\n+= SUB freq[num] 1\nDEDENT\nelse: INDENT\n= SUB freq[num] 1\nDEDENT\nDEDENT\n= max_val NEG 1\nfor num, count in call ATTR freq.items(): INDENT\nif and count >= num num > max_val: INDENT\n= max_val num\nDEDENT\nDEDENT\nreturn max_val\nDEDENT\n\n"}
{"task_id": "HumanEval/70", "solution": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    sorted_list = []\n    while lst:\n        min_val = min(lst)\n        lst.remove(min_val)\n        sorted_list.append(min_val)\n        if not lst:\n            break\n        max_val = max(lst)\n        lst.remove(max_val)\n        sorted_list.append(max_val)\n    return sorted_list\n", "origin_solution": "def strange_sort_list(lst): INDENT\n'''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n= sorted_list LIST[]\nwhile lst: INDENT\n= min_val call min(lst)\ncall ATTR lst.remove(min_val)\ncall ATTR sorted_list.append(min_val)\nif NOT lst: INDENT\nbreak\nDEDENT\n= max_val call max(lst)\ncall ATTR lst.remove(max_val)\ncall ATTR sorted_list.append(max_val)\nDEDENT\nreturn sorted_list\nDEDENT\n\n"}
{"task_id": "HumanEval/71", "solution": "def triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1\n", "origin_solution": "def triangle_area(a, b, c): INDENT\n'''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\nif and and + a b > c + a c > b + b c > a: INDENT\n= s / (+ + a b c) 2\n= area ** (* * * s (- s a) (- s b) (- s c)) 0.5\nreturn call round(area, 2)\nDEDENT\nelse: INDENT\nreturn NEG 1\nDEDENT\nDEDENT\n\n"}
{"task_id": "HumanEval/72", "solution": "def will_it_fly(q, w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u279e False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279e False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u279e True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n    if q != q[::-1]:\n        return False\n    if sum(q) > w:\n        return False\n    return True\n", "origin_solution": "def will_it_fly(q, w): INDENT\n'''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u279e False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279e False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u279e True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\nif q != SUB q[::NEG 1]: INDENT\nreturn False\nDEDENT\nif call sum(q) > w: INDENT\nreturn False\nDEDENT\nreturn True\nDEDENT\n\n"}
{"task_id": "HumanEval/73", "solution": "def smallest_change(arr):\n    changes = 0\n    i, j = 0, len(arr) - 1\n    while i < j:\n        if arr[i] != arr[j]:\n            changes += 1\n        i += 1\n        j -= 1\n    return changes\n", "origin_solution": "def smallest_change(arr): INDENT\n= changes 0\n= i, j 0, - call len(arr) 1\nwhile i < j: INDENT\nif SUB arr[i] != SUB arr[j]: INDENT\n+= changes 1\nDEDENT\n+= i 1\n-= j 1\nDEDENT\nreturn changes\nDEDENT\n\n"}
{"task_id": "HumanEval/74", "solution": "def total_match(lst1, lst2):\n    len1 = sum(len(word) for word in lst1)\n    len2 = sum(len(word) for word in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2\n", "origin_solution": "def total_match(lst1, lst2): INDENT\n= len1 call sum(call len(word) for word in lst1)\n= len2 call sum(call len(word) for word in lst2)\nif len1 <= len2: INDENT\nreturn lst1\nDEDENT\nelse: INDENT\nreturn lst2\nDEDENT\nDEDENT\n\n"}
{"task_id": "HumanEval/75", "solution": "def is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less than 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    prime_factors = []\n    for i in range(2, a + 1):\n        if a % i == 0 and is_prime(i):\n            prime_factors.append(i)\n            a //= i\n    return len(prime_factors) == 3\n", "origin_solution": "def is_multiply_prime(a): INDENT\n\"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less than 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\ndef is_prime(n): INDENT\nif n <= 1: INDENT\nreturn False\nDEDENT\nif n <= 3: INDENT\nreturn True\nDEDENT\nif or % n 2 == 0 % n 3 == 0: INDENT\nreturn False\nDEDENT\n= i 5\nwhile * i i <= n: INDENT\nif or % n i == 0 % n (+ i 2) == 0: INDENT\nreturn False\nDEDENT\n+= i 6\nDEDENT\nreturn True\nDEDENT\n= prime_factors LIST[]\nfor i in call range(2, + a 1): INDENT\nif and % a i == 0 call is_prime(i): INDENT\ncall ATTR prime_factors.append(i)\n//= a i\nDEDENT\nDEDENT\nreturn call len(prime_factors) == 3\nDEDENT\n\n"}
{"task_id": "HumanEval/76", "solution": "def is_simple_power(x, n):\n    if x == 1:\n        return True\n    if x < 1 or x % n != 0:\n        return False\n    return is_simple_power(x // n, n)\n", "origin_solution": "def is_simple_power(x, n): INDENT\nif x == 1: INDENT\nreturn True\nDEDENT\nif or x < 1 % x n != 0: INDENT\nreturn False\nDEDENT\nreturn call is_simple_power(// x n, n)\nDEDENT\n\n"}
{"task_id": "HumanEval/77", "solution": "def iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n    if a == 0:\n        return True\n    root = round(a ** (1 / 3))\n    return root ** 3 == a\n", "origin_solution": "def iscube(a): INDENT\n'''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\nif a == 0: INDENT\nreturn True\nDEDENT\n= root call round(** a (/ 1 3))\nreturn ** root 3 == a\nDEDENT\n\n"}
{"task_id": "HumanEval/78", "solution": "def hex_key(num):\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in prime_hex_digits:\n            count += 1\n    return count\n", "origin_solution": "def hex_key(num): INDENT\n= prime_hex_digits SET {'2', '3', '5', '7', 'B', 'D'}\n= count 0\nfor digit in num: INDENT\nif digit in prime_hex_digits: INDENT\n+= count 1\nDEDENT\nDEDENT\nreturn count\nDEDENT\n\n"}
{"task_id": "HumanEval/79", "solution": "def decimal_to_binary(decimal):\n    binary = bin(decimal)[2:]\n    binary = \"db\" + binary + \"db\"\n    return binary\n", "origin_solution": "def decimal_to_binary(decimal): INDENT\n= binary SUB call bin(decimal)[2:]\n= binary + + \"db\" binary \"db\"\nreturn binary\nDEDENT\n\n"}
{"task_id": "HumanEval/80", "solution": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True\n", "origin_solution": "def is_happy(s): INDENT\nif call len(s) < 3: INDENT\nreturn False\nDEDENT\nfor i in call range(- call len(s) 2): INDENT\nif or or SUB s[i] == SUB s[+ i 1] SUB s[i] == SUB s[+ i 2] SUB s[+ i 1] == SUB s[+ i 2]: INDENT\nreturn False\nDEDENT\nDEDENT\nreturn True\nDEDENT\n\n"}
{"task_id": "HumanEval/81", "solution": "def numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa >= 4.0:\n            letter_grades.append('A+')\n        elif gpa >= 3.7:\n            letter_grades.append('A')\n        elif gpa >= 3.3:\n            letter_grades.append('A-')\n        elif gpa >= 3.0:\n            letter_grades.append('B+')\n        elif gpa >= 2.7:\n            letter_grades.append('B')\n        elif gpa >= 2.3:\n            letter_grades.append('B-')\n        elif gpa >= 2.0:\n            letter_grades.append('C+')\n        elif gpa >= 1.7:\n            letter_grades.append('C')\n        elif gpa >= 1.3:\n            letter_grades.append('C-')\n        elif gpa >= 1.0:\n            letter_grades.append('D+')\n        elif gpa >= 0.7:\n            letter_grades.append('D')\n        elif gpa >= 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades\n", "origin_solution": "def numerical_letter_grade(grades): INDENT\n= letter_grades LIST[]\nfor gpa in grades: INDENT\nif gpa >= 4.0: INDENT\ncall ATTR letter_grades.append('A+')\nDEDENT\nelif gpa >= 3.7: INDENT\ncall ATTR letter_grades.append('A')\nDEDENT\nelif gpa >= 3.3: INDENT\ncall ATTR letter_grades.append('A-')\nDEDENT\nelif gpa >= 3.0: INDENT\ncall ATTR letter_grades.append('B+')\nDEDENT\nelif gpa >= 2.7: INDENT\ncall ATTR letter_grades.append('B')\nDEDENT\nelif gpa >= 2.3: INDENT\ncall ATTR letter_grades.append('B-')\nDEDENT\nelif gpa >= 2.0: INDENT\ncall ATTR letter_grades.append('C+')\nDEDENT\nelif gpa >= 1.7: INDENT\ncall ATTR letter_grades.append('C')\nDEDENT\nelif gpa >= 1.3: INDENT\ncall ATTR letter_grades.append('C-')\nDEDENT\nelif gpa >= 1.0: INDENT\ncall ATTR letter_grades.append('D+')\nDEDENT\nelif gpa >= 0.7: INDENT\ncall ATTR letter_grades.append('D')\nDEDENT\nelif gpa >= 0.0: INDENT\ncall ATTR letter_grades.append('D-')\nDEDENT\nelse: INDENT\ncall ATTR letter_grades.append('E')\nDEDENT\nDEDENT\nreturn letter_grades\nDEDENT\n\n"}
{"task_id": "HumanEval/82", "solution": "def prime_length(string):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    return is_prime(len(string))\nprint(prime_length('Hello'))\nprint(prime_length('abcdcba'))\nprint(prime_length('kittens'))\nprint(prime_length('orange'))\n", "origin_solution": "def prime_length(string): INDENT\ndef is_prime(n): INDENT\nif n <= 1: INDENT\nreturn False\nDEDENT\nfor i in call range(2, + call int(** n 0.5) 1): INDENT\nif % n i == 0: INDENT\nreturn False\nDEDENT\nDEDENT\nreturn True\nDEDENT\nreturn call is_prime(call len(string))\nDEDENT\ncall print(call prime_length('Hello'))\ncall print(call prime_length('abcdcba'))\ncall print(call prime_length('kittens'))\ncall print(call prime_length('orange'))\n\n"}
{"task_id": "HumanEval/83", "solution": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if n == 1:\n        return 2\n    count = 0\n    for i in range(10 ** (n - 1), 10 ** n):\n        str_i = str(i)\n        if str_i[0] == '1' or str_i[-1] == '1':\n            count += 1\n    return count\n", "origin_solution": "def starts_one_ends(n): INDENT\n\"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\nif n == 1: INDENT\nreturn 2\nDEDENT\n= count 0\nfor i in call range(** 10 (- n 1), ** 10 n): INDENT\n= str_i call str(i)\nif or SUB str_i[0] == '1' SUB str_i[NEG 1] == '1': INDENT\n+= count 1\nDEDENT\nDEDENT\nreturn count\nDEDENT\n\n"}
{"task_id": "HumanEval/84", "solution": "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    sum_of_digits = 0\n    while N > 0:\n        sum_of_digits += N % 10\n        N = N // 10\n    return bin(sum_of_digits)[2:]\n", "origin_solution": "def solve(N): INDENT\n\"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n= sum_of_digits 0\nwhile N > 0: INDENT\n+= sum_of_digits % N 10\n= N // N 10\nDEDENT\nreturn SUB call bin(sum_of_digits)[2:]\nDEDENT\n\n"}
{"task_id": "HumanEval/85", "solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    result = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            result += lst[i]\n    return result\n", "origin_solution": "def add(lst): INDENT\n\"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n= result 0\nfor i in call range(1, call len(lst), 2): INDENT\nif % SUB lst[i] 2 == 0: INDENT\n+= result SUB lst[i]\nDEDENT\nDEDENT\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/86", "solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    sorted_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(sorted_words)\n", "origin_solution": "def anti_shuffle(s): INDENT\n= words call ATTR s.split(' ')\n= sorted_words LIST[call ATTR ''.join(call sorted(word)) for word in words]\nreturn call ATTR ' '.join(sorted_words)\nDEDENT\n\n"}
{"task_id": "HumanEval/87", "solution": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        if x in row:\n            col_index = row.index(x)\n            result.append((i, col_index))\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result\n", "origin_solution": "def get_row(lst, x): INDENT\n= result LIST[]\nfor i, row in call enumerate(lst): INDENT\nif x in row: INDENT\n= col_index call ATTR row.index(x)\ncall ATTR result.append(TUPLE (i, col_index))\nDEDENT\nDEDENT\ncall ATTR result.sort(key=lambda t: TUPLE (SUB t[0], NEG SUB t[1]))\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/88", "solution": "def sort_array(array):\n    if len(array) == 0:\n        return []\n    total_sum = sum(array)\n    if total_sum % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)\n", "origin_solution": "def sort_array(array): INDENT\nif call len(array) == 0: INDENT\nreturn LIST[]\nDEDENT\n= total_sum call sum(array)\nif % total_sum 2 == 0: INDENT\nreturn call sorted(array, reverse=True)\nDEDENT\nelse: INDENT\nreturn call sorted(array)\nDEDENT\nDEDENT\n\n"}
{"task_id": "HumanEval/89", "solution": "def encrypt(s):\n    encrypted_string = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2\n            if char.islower():\n                encrypted_string += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                encrypted_string += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            encrypted_string += char\n    return encrypted_string\n", "origin_solution": "def encrypt(s): INDENT\n= encrypted_string \"\"\nfor char in s: INDENT\nif call ATTR char.isalpha(): INDENT\n= shift 2\nif call ATTR char.islower(): INDENT\n+= encrypted_string call chr(+ % (+ - call ord(char) call ord('a') shift) 26 call ord('a'))\nDEDENT\nelse: INDENT\n+= encrypted_string call chr(+ % (+ - call ord(char) call ord('A') shift) 26 call ord('A'))\nDEDENT\nDEDENT\nelse: INDENT\n+= encrypted_string char\nDEDENT\nDEDENT\nreturn encrypted_string\nDEDENT\n\n"}
{"task_id": "HumanEval/90", "solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    min1, min2 = float('inf'), float('inf')\n    for num in lst:\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2 and num != min1:\n            min2 = num\n    return min2 if min2 != float('inf') else None\n", "origin_solution": "def next_smallest(lst): INDENT\nif call len(lst) < 2: INDENT\nreturn None\nDEDENT\n= min1, min2 call float('inf'), call float('inf')\nfor num in lst: INDENT\nif num < min1: INDENT\n= min2 min1\n= min1 num\nDEDENT\nelif and num < min2 num != min1: INDENT\n= min2 num\nDEDENT\nDEDENT\nreturn min2 if min2 != call float('inf') else None\nDEDENT\n\n"}
{"task_id": "HumanEval/91", "solution": "def is_bored(S):\n    \"\"\"\n    This function takes a string of words and returns the number of boredoms.\n    A boredom is a sentence that starts with the word \"I\" and is followed by a period, question mark, or exclamation mark.\n    Sentences are delimited by '.', '?' or '!'.\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    boredoms = 0\n    sentences = re.split('[.!?]', S)\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence and sentence.startswith(\"I \"):\n            boredoms += 1\n    return boredoms\n", "origin_solution": "def is_bored(S): INDENT\n\"\"\"\n    This function takes a string of words and returns the number of boredoms.\n    A boredom is a sentence that starts with the word \"I\" and is followed by a period, question mark, or exclamation mark.\n    Sentences are delimited by '.', '?' or '!'.\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n= boredoms 0\n= sentences call ATTR re.split('[.!?]', S)\nfor sentence in sentences: INDENT\n= sentence call ATTR sentence.strip()\nif and sentence call ATTR sentence.startswith(\"I \"): INDENT\n+= boredoms 1\nDEDENT\nDEDENT\nreturn boredoms\nDEDENT\n\n"}
{"task_id": "HumanEval/92", "solution": "def any_int(x, y, z):\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int) and x != y and x != z and y != z:\n        if x == y + z or y == x + z or z == x + y:\n            return True\n    return False\n", "origin_solution": "def any_int(x, y, z): INDENT\nif and and and and and call isinstance(x, int) call isinstance(y, int) call isinstance(z, int) x != y x != z y != z: INDENT\nif or or x == + y z y == + x z z == + x y: INDENT\nreturn True\nDEDENT\nDEDENT\nreturn False\nDEDENT\n\n"}
{"task_id": "HumanEval/93", "solution": "def encode(message):\n    vowels = 'aeiou'\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            char = char.swapcase()\n            if char in vowels:\n                index = vowels.index(char)\n                char = chr((index + 2) % 26 + ord('a'))\n            encoded_message += char\n        else:\n            encoded_message += char\n    return encoded_message\nprint(encode('test'))\nprint(encode('This is a message'))\n", "origin_solution": "def encode(message): INDENT\n= vowels 'aeiou'\n= encoded_message ''\nfor char in message: INDENT\nif call ATTR char.isalpha(): INDENT\n= char call ATTR char.swapcase()\nif char in vowels: INDENT\n= index call ATTR vowels.index(char)\n= char call chr(+ % (+ index 2) 26 call ord('a'))\nDEDENT\n+= encoded_message char\nDEDENT\nelse: INDENT\n+= encoded_message char\nDEDENT\nDEDENT\nreturn encoded_message\nDEDENT\ncall print(call encode('test'))\ncall print(call encode('This is a message'))\n\n"}
{"task_id": "HumanEval/94", "solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef sum_of_digits(n):\n    \"\"\"Helper function to calculate the sum of digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(n))\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "origin_solution": "def is_prime(n): INDENT\n\"\"\"Helper function to check if a number is prime.\"\"\"\nif n <= 1: INDENT\nreturn False\nDEDENT\nif n <= 3: INDENT\nreturn True\nDEDENT\nif or % n 2 == 0 % n 3 == 0: INDENT\nreturn False\nDEDENT\n= i 5\nwhile * i i <= n: INDENT\nif or % n i == 0 % n (+ i 2) == 0: INDENT\nreturn False\nDEDENT\n+= i 6\nDEDENT\nreturn True\nDEDENT\ndef sum_of_digits(n): INDENT\n\"\"\"Helper function to calculate the sum of digits of a number.\"\"\"\nreturn call sum(call int(digit) for digit in call str(n))\nDEDENT\ndef skjkasdkd(lst): INDENT\n\"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\""}
{"task_id": "HumanEval/95", "solution": "def check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n    if not dict:\n        return False\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return False\n        if key.islower() and not key.isupper():\n            return False\n        if key.isupper() and not key.islower():\n            return False\n    return True\n", "origin_solution": "def check_dict_case(dict): INDENT\n\"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\nif NOT dict: INDENT\nreturn False\nDEDENT\nfor key in call ATTR dict.keys(): INDENT\nif NOT call isinstance(key, str): INDENT\nreturn False\nDEDENT\nif and call ATTR key.islower() NOT call ATTR key.isupper(): INDENT\nreturn False\nDEDENT\nif and call ATTR key.isupper() NOT call ATTR key.islower(): INDENT\nreturn False\nDEDENT\nDEDENT\nreturn True\nDEDENT\n\n"}
{"task_id": "HumanEval/96", "solution": "def count_up_to(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    primes = []\n    i = 2\n    while len(primes) < n:\n        if is_prime(i):\n            primes.append(i)\n        i += 1\n    return primes\n", "origin_solution": "def count_up_to(n): INDENT\ndef is_prime(num): INDENT\nif num < 2: INDENT\nreturn False\nDEDENT\nfor i in call range(2, + call int(** num 0.5) 1): INDENT\nif % num i == 0: INDENT\nreturn False\nDEDENT\nDEDENT\nreturn True\nDEDENT\n= primes LIST[]\n= i 2\nwhile call len(primes) < n: INDENT\nif call is_prime(i): INDENT\ncall ATTR primes.append(i)\nDEDENT\n+= i 1\nDEDENT\nreturn primes\nDEDENT\n\n"}
{"task_id": "HumanEval/97", "solution": "def multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n    product = 1\n    while a > 0:\n        digit = a % 10\n        product *= digit\n        a //= 10\n    while b > 0:\n        digit = b % 10\n        product *= digit\n        b //= 10\n    return product\n", "origin_solution": "def multiply(a, b): INDENT\n\"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n= product 1\nwhile a > 0: INDENT\n= digit % a 10\n*= product digit\n//= a 10\nDEDENT\nwhile b > 0: INDENT\n= digit % b 10\n*= product digit\n//= b 10\nDEDENT\nreturn product\nDEDENT\n\n"}
{"task_id": "HumanEval/98", "solution": "def count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n    upper_vowels = 'AEIOU'\n    count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in upper_vowels:\n            count += 1\n    return count\n", "origin_solution": "def count_upper(s): INDENT\n\"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n= upper_vowels 'AEIOU'\n= count 0\nfor i in call range(0, call len(s), 2): INDENT\nif SUB s[i] in upper_vowels: INDENT\n+= count 1\nDEDENT\nDEDENT\nreturn count\nDEDENT\n\n"}
{"task_id": "HumanEval/99", "solution": "def closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n    num = float(value)\n    closest = round(num)\n    if abs(num - closest) == 0.5:\n        if num > 0:\n            return closest + 1\n        else:\n            return closest - 1\n    else:\n        return closest\n", "origin_solution": "def closest_integer(value): INDENT\n'''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n= num call float(value)\n= closest call round(num)\nif call abs(- num closest) == 0.5: INDENT\nif num > 0: INDENT\nreturn + closest 1\nDEDENT\nelse: INDENT\nreturn - closest 1\nDEDENT\nDEDENT\nelse: INDENT\nreturn closest\nDEDENT\nDEDENT\n\n"}
{"task_id": "HumanEval/100", "solution": "def make_a_pile(n):\n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        if current_stones % 2 == 0:\n            current_stones += 2\n        else:\n            current_stones += 2\n    return pile\n", "origin_solution": "def make_a_pile(n): INDENT\n= pile LIST[]\n= current_stones n\nfor _ in call range(n): INDENT\ncall ATTR pile.append(current_stones)\nif % current_stones 2 == 0: INDENT\n+= current_stones 2\nDEDENT\nelse: INDENT\n+= current_stones 2\nDEDENT\nDEDENT\nreturn pile\nDEDENT\n\n"}
{"task_id": "HumanEval/101", "solution": "def words_string(s):\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n    return s.split()\n", "origin_solution": "def words_string(s): INDENT\n\"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\nreturn call ATTR s.split()\nDEDENT\n\n"}
{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n    if x > y:\n        return -1\n    for i in range(y, x - 1, -1):\n        if i % 2 == 0:\n            return i\n    return -1\n", "origin_solution": "def choose_num(x, y): INDENT\n\"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\nif x > y: INDENT\nreturn NEG 1\nDEDENT\nfor i in call range(y, - x 1, NEG 1): INDENT\nif % i 2 == 0: INDENT\nreturn i\nDEDENT\nDEDENT\nreturn NEG 1\nDEDENT\n\n"}
{"task_id": "HumanEval/103", "solution": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    total_sum = sum(range(n, m + 1))\n    avg = round(total_sum / (m - n + 1))\n    return bin(avg)\n", "origin_solution": "def rounded_avg(n, m): INDENT\nif n > m: INDENT\nreturn NEG 1\nDEDENT\n= total_sum call sum(call range(n, + m 1))\n= avg call round(/ total_sum (+ - m n 1))\nreturn call bin(avg)\nDEDENT\n\n"}
{"task_id": "HumanEval/104", "solution": "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    result = []\n    for num in x:\n        digits = [int(digit) for digit in str(num)]\n        if all(digit % 2 != 0 for digit in digits):\n            result.append(num)\n    return sorted(result)\n", "origin_solution": "def unique_digits(x): INDENT\n\"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n= result LIST[]\nfor num in x: INDENT\n= digits LIST[call int(digit) for digit in call str(num)]\nif call all(% digit 2 != 0 for digit in digits): INDENT\ncall ATTR result.append(num)\nDEDENT\nDEDENT\nreturn call sorted(result)\nDEDENT\n\n"}
{"task_id": "HumanEval/105", "solution": "def by_length(arr):\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    sorted_arr = sorted(filtered_arr)\n    reversed_arr = sorted_arr[::-1]\n    result = [digit_names[num - 1] for num in reversed_arr]\n    return result\n", "origin_solution": "def by_length(arr): INDENT\n= digit_names LIST[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n= filtered_arr LIST[num for num in arr if 1 <= num <= 9]\n= sorted_arr call sorted(filtered_arr)\n= reversed_arr SUB sorted_arr[::NEG 1]\n= result LIST[SUB digit_names[- num 1] for num in reversed_arr]\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/106", "solution": "def f(n):\n    def factorial(i):\n        if i == 0:\n            return 1\n        else:\n            return i * factorial(i - 1)\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum(range(1, i + 1)))\n    return result\n", "origin_solution": "def f(n): INDENT\ndef factorial(i): INDENT\nif i == 0: INDENT\nreturn 1\nDEDENT\nelse: INDENT\nreturn * i call factorial(- i 1)\nDEDENT\nDEDENT\n= result LIST[]\nfor i in call range(1, + n 1): INDENT\nif % i 2 == 0: INDENT\ncall ATTR result.append(call factorial(i))\nDEDENT\nelse: INDENT\ncall ATTR result.append(call sum(call range(1, + i 1)))\nDEDENT\nDEDENT\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/107", "solution": "def even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n + 1):\n        str_i = str(i)\n        if str_i == str_i[::-1]:\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)\n", "origin_solution": "def even_odd_palindrome(n): INDENT\n= even_count 0\n= odd_count 0\nfor i in call range(1, + n 1): INDENT\n= str_i call str(i)\nif str_i == SUB str_i[::NEG 1]: INDENT\nif % i 2 == 0: INDENT\n+= even_count 1\nDEDENT\nelse: INDENT\n+= odd_count 1\nDEDENT\nDEDENT\nDEDENT\nreturn TUPLE (even_count, odd_count)\nDEDENT\n\n"}
{"task_id": "HumanEval/108", "solution": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = abs(num)\n        digit_sum = sum(int(digit) for digit in str(num))\n        if digit_sum > 0:\n            count += 1\n    return count\n", "origin_solution": "def count_nums(arr): INDENT\n\"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n= count 0\nfor num in arr: INDENT\nif num < 0: INDENT\n= num call abs(num)\nDEDENT\n= digit_sum call sum(call int(digit) for digit in call str(num))\nif digit_sum > 0: INDENT\n+= count 1\nDEDENT\nDEDENT\nreturn count\nDEDENT\n\n"}
{"task_id": "HumanEval/109", "solution": "def move_one_ball(arr):\n    if not arr:\n        return True\n    sorted_arr = sorted(arr)\n    n = len(arr)\n    for i in range(n):\n        rotated_arr = arr[-i:] + arr[:-i]\n        if rotated_arr == sorted_arr:\n            return True\n    return False\n", "origin_solution": "def move_one_ball(arr): INDENT\nif NOT arr: INDENT\nreturn True\nDEDENT\n= sorted_arr call sorted(arr)\n= n call len(arr)\nfor i in call range(n): INDENT\n= rotated_arr + SUB arr[NEG i:] SUB arr[:NEG i]\nif rotated_arr == sorted_arr: INDENT\nreturn True\nDEDENT\nDEDENT\nreturn False\nDEDENT\n\n"}
{"task_id": "HumanEval/110", "solution": "def exchange(lst1, lst2):\n    odd_lst1 = [x for x in lst1 if x % 2 != 0]\n    even_lst2 = [x for x in lst2 if x % 2 == 0]\n    if len(odd_lst1) <= len(even_lst2):\n        return \"YES\"\n    else:\n        return \"NO\"\n", "origin_solution": "def exchange(lst1, lst2): INDENT\n= odd_lst1 LIST[x for x in lst1 if % x 2 != 0]\n= even_lst2 LIST[x for x in lst2 if % x 2 == 0]\nif call len(odd_lst1) <= call len(even_lst2): INDENT\nreturn \"YES\"\nDEDENT\nelse: INDENT\nreturn \"NO\"\nDEDENT\nDEDENT\n\n"}
{"task_id": "HumanEval/111", "solution": "def histogram(test):\n    words = test.split()\n    hist = {}\n    for word in words:\n        if word in hist:\n            hist[word] += 1\n        else:\n            hist[word] = 1\n    max_count = max(hist.values())\n    result = {k:v for k, v in hist.items() if v == max_count}\n    return result\n", "origin_solution": "def histogram(test): INDENT\n= words call ATTR test.split()\n= hist DICT {}\nfor word in words: INDENT\nif word in hist: INDENT\n+= SUB hist[word] 1\nDEDENT\nelse: INDENT\n= SUB hist[word] 1\nDEDENT\nDEDENT\n= max_count call max(call ATTR hist.values())\n= result DICTC {k:v for k, v in call ATTR hist.items() if v == max_count}\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/112", "solution": "def reverse_delete(s, c):\n    result = ''.join([char for char in s if char not in c])\n    is_palindrome = result == result[::-1]\n    return (result, is_palindrome)\n", "origin_solution": "def reverse_delete(s, c): INDENT\n= result call ATTR ''.join(LIST[char for char in s if char not in c])\n= is_palindrome result == SUB result[::NEG 1]\nreturn TUPLE (result, is_palindrome)\nDEDENT\n\n"}
{"task_id": "HumanEval/113", "solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count))\n    return result\n", "origin_solution": "def odd_count(lst): INDENT\n= result LIST[]\nfor s in lst: INDENT\n= odd_count call sum(1 for c in s if % call int(c) 2 != 0)\ncall ATTR result.append(call ATTR \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count))\nDEDENT\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/114", "solution": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    min_sum = nums[0]\n    current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum\n", "origin_solution": "def minSubArraySum(nums): INDENT\n\"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n= min_sum SUB nums[0]\n= current_sum SUB nums[0]\nfor num in SUB nums[1:]: INDENT\n= current_sum call min(num, + current_sum num)\n= min_sum call min(min_sum, current_sum)\nDEDENT\nreturn min_sum\nDEDENT\n\n"}
{"task_id": "HumanEval/115", "solution": "def max_fill(grid, capacity):\n    total_water = sum(sum(row) for row in grid)\n    full_buckets = math.ceil(total_water / capacity)\n    empty_buckets = 0\n    for row in grid:\n        for cell in row:\n            if cell == 1:\n                empty_buckets += 1\n    total_operations = full_buckets + empty_buckets\n    return total_operations\n", "origin_solution": "def max_fill(grid, capacity): INDENT\n= total_water call sum(call sum(row) for row in grid)\n= full_buckets call ATTR math.ceil(/ total_water capacity)\n= empty_buckets 0\nfor row in grid: INDENT\nfor cell in row: INDENT\nif cell == 1: INDENT\n+= empty_buckets 1\nDEDENT\nDEDENT\nDEDENT\n= total_operations + full_buckets empty_buckets\nreturn total_operations\nDEDENT\n\n"}
{"task_id": "HumanEval/116", "solution": "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))\n", "origin_solution": "def sort_array(arr): INDENT\n\"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"\nreturn call sorted(arr, key=lambda x: TUPLE (call ATTR call bin(x).count('1'), x))\nDEDENT\n\n"}
{"task_id": "HumanEval/117", "solution": "def select_words(s, n):\n    vowels = \"aeiouAEIOU\"\n    words = s.split()\n    result = []\n    for word in words:\n        consonant_count = sum(1 for char in word if char.isalpha() and char not in vowels)\n        if consonant_count == n:\n            result.append(word)\n    return result\n", "origin_solution": "def select_words(s, n): INDENT\n= vowels \"aeiouAEIOU\"\n= words call ATTR s.split()\n= result LIST[]\nfor word in words: INDENT\n= consonant_count call sum(1 for char in word if and call ATTR char.isalpha() char not in vowels)\nif consonant_count == n: INDENT\ncall ATTR result.append(word)\nDEDENT\nDEDENT\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/118", "solution": "def get_closest_vowel(word):\n    vowels = \"aeiouAEIOU\"\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            return word[i]\n    return \"\"\n", "origin_solution": "def get_closest_vowel(word): INDENT\n= vowels \"aeiouAEIOU\"\nfor i in call range(- call len(word) 2, 0, NEG 1): INDENT\nif and and SUB word[i] in vowels SUB word[- i 1] not in vowels SUB word[+ i 1] not in vowels: INDENT\nreturn SUB word[i]\nDEDENT\nDEDENT\nreturn \"\"\nDEDENT\n\n"}
{"task_id": "HumanEval/119", "solution": "def match_parens(lst):\n    s1, s2 = lst\n    stack = []\n    for char in s1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return 'No'\n            stack.pop()\n    for char in s2:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return 'No'\n            stack.pop()\n    return 'Yes' if not stack else 'No'\n", "origin_solution": "def match_parens(lst): INDENT\n= s1, s2 lst\n= stack LIST[]\nfor char in s1: INDENT\nif char == '(': INDENT\ncall ATTR stack.append(char)\nDEDENT\nelif char == ')': INDENT\nif NOT stack: INDENT\nreturn 'No'\nDEDENT\ncall ATTR stack.pop()\nDEDENT\nDEDENT\nfor char in s2: INDENT\nif char == '(': INDENT\ncall ATTR stack.append(char)\nDEDENT\nelif char == ')': INDENT\nif NOT stack: INDENT\nreturn 'No'\nDEDENT\ncall ATTR stack.pop()\nDEDENT\nDEDENT\nreturn 'Yes' if NOT stack else 'No'\nDEDENT\n\n"}
{"task_id": "HumanEval/120", "solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort(reverse=True)\n    return arr[:k]\n", "origin_solution": "def maximum(arr, k): INDENT\n\"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\ncall ATTR arr.sort(reverse=True)\nreturn SUB arr[:k]\nDEDENT\n\n"}
{"task_id": "HumanEval/121", "solution": "def solution(lst):\n    sum_odd_in_even_positions = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum_odd_in_even_positions += lst[i]\n    return sum_odd_in_even_positions\n", "origin_solution": "def solution(lst): INDENT\n= sum_odd_in_even_positions 0\nfor i in call range(0, call len(lst), 2): INDENT\nif % SUB lst[i] 2 != 0: INDENT\n+= sum_odd_in_even_positions SUB lst[i]\nDEDENT\nDEDENT\nreturn sum_odd_in_even_positions\nDEDENT\n\n"}
{"task_id": "HumanEval/122", "solution": "def add_elements(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n    total_sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            total_sum += arr[i]\n    return total_sum\n", "origin_solution": "def add_elements(arr, k): INDENT\n\"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n= total_sum 0\nfor i in call range(k): INDENT\nif call len(call str(SUB arr[i])) <= 2: INDENT\n+= total_sum SUB arr[i]\nDEDENT\nDEDENT\nreturn total_sum\nDEDENT\n\n"}
{"task_id": "HumanEval/123", "solution": "def get_odd_collatz(n):\n    result = []\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        if n % 2 != 0:\n            result.append(n)\n    result.append(1)\n    return sorted(result)\n", "origin_solution": "def get_odd_collatz(n): INDENT\n= result LIST[]\nwhile n != 1: INDENT\nif % n 2 == 0: INDENT\n= n // n 2\nDEDENT\nelse: INDENT\n= n + * 3 n 1\nDEDENT\nif % n 2 != 0: INDENT\ncall ATTR result.append(n)\nDEDENT\nDEDENT\ncall ATTR result.append(1)\nreturn call sorted(result)\nDEDENT\n\n"}
{"task_id": "HumanEval/124", "solution": "def valid_date(date):\n    if not date:\n        return False\n    try:\n        month, day, year = map(int, date.split('-'))\n    except ValueError:\n        return False\n    if month < 1 or month > 12:\n        return False\n    if day < 1 or day > 31:\n        return False\n    if month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    return True\n", "origin_solution": "def valid_date(date): INDENT\nif NOT date: INDENT\nreturn False\nDEDENT\ntry: INDENT\n= month, day, year call map(int, call ATTR date.split('-'))\nDEDENT\nexcept ValueError: INDENT\nreturn False\nDEDENT\nif or month < 1 month > 12: INDENT\nreturn False\nDEDENT\nif or day < 1 day > 31: INDENT\nreturn False\nDEDENT\nif month in LIST[4, 6, 9, 11]: INDENT\nif or day < 1 day > 30: INDENT\nreturn False\nDEDENT\nDEDENT\nelif month == 2: INDENT\nif or day < 1 day > 29: INDENT\nreturn False\nDEDENT\nDEDENT\nreturn True\nDEDENT\n\n"}
{"task_id": "HumanEval/125", "solution": "def split_words(txt):\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum(1 for c in txt if (ord(c) - ord('a')) % 2 == 1)\nprint(split_words(\"Hello world!\"))\nprint(split_words(\"Hello,world!\"))\nprint(split_words(\"abcdef\"))\n", "origin_solution": "def split_words(txt): INDENT\nif ' ' in txt: INDENT\nreturn call ATTR txt.split(' ')\nDEDENT\nelif ',' in txt: INDENT\nreturn call ATTR txt.split(',')\nDEDENT\nelse: INDENT\nreturn call sum(1 for c in txt if % (- call ord(c) call ord('a')) 2 == 1)\nDEDENT\nDEDENT\ncall print(call split_words(\"Hello world!\"))\ncall print(call split_words(\"Hello,world!\"))\ncall print(call split_words(\"abcdef\"))\n\n"}
{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n    '''\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True\n", "origin_solution": "def is_sorted(lst): INDENT\n'''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n    '''\nfor i in call range(- call len(lst) 1): INDENT\nif SUB lst[i] > SUB lst[+ i 1]: INDENT\nreturn False\nDEDENT\nDEDENT\nreturn True\nDEDENT\n\n"}
{"task_id": "HumanEval/127", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef intersection(interval1, interval2):\n    \"\"\"Determine if the length of intersection of two intervals is a prime number.\"\"\"\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start > end:\n        return \"NO\"\n    length = end - start\n    return \"YES\" if is_prime(length) else \"NO\"\nprint(intersection((1, 2), (2, 3)))\nprint(intersection((-1, 1), (0, 4)))\nprint(intersection((-3, -1), (-5, 5)))\n", "origin_solution": "def is_prime(n): INDENT\n\"\"\"Check if a number is prime.\"\"\"\nif n <= 1: INDENT\nreturn False\nDEDENT\nif n <= 3: INDENT\nreturn True\nDEDENT\nif or % n 2 == 0 % n 3 == 0: INDENT\nreturn False\nDEDENT\n= i 5\nwhile * i i <= n: INDENT\nif or % n i == 0 % n (+ i 2) == 0: INDENT\nreturn False\nDEDENT\n+= i 6\nDEDENT\nreturn True\nDEDENT\ndef intersection(interval1, interval2): INDENT\n\"\"\"Determine if the length of intersection of two intervals is a prime number.\"\"\"\n= start call max(SUB interval1[0], SUB interval2[0])\n= end call min(SUB interval1[1], SUB interval2[1])\nif start > end: INDENT\nreturn \"NO\"\nDEDENT\n= length - end start\nreturn \"YES\" if call is_prime(length) else \"NO\"\nDEDENT\ncall print(call intersection(TUPLE (1, 2), TUPLE (2, 3)))\ncall print(call intersection(TUPLE (NEG 1, 1), TUPLE (0, 4)))\ncall print(call intersection(TUPLE (NEG 3, NEG 1), TUPLE (NEG 5, 5)))\n\n"}
{"task_id": "HumanEval/128", "solution": "def prod_signs(arr):\n    if not arr:\n        return None\n    total_sum = 0\n    product_of_signs = 1\n    for num in arr:\n        if num > 0:\n            product_of_signs *= 1\n        elif num < 0:\n            product_of_signs *= -1\n        else:\n            product_of_signs = 0\n        total_sum += abs(num)\n    return total_sum * product_of_signs\nprint(prod_signs([1, 2, 2, -4]))\nprint(prod_signs([0, 1]))\nprint(prod_signs([]))\n", "origin_solution": "def prod_signs(arr): INDENT\nif NOT arr: INDENT\nreturn None\nDEDENT\n= total_sum 0\n= product_of_signs 1\nfor num in arr: INDENT\nif num > 0: INDENT\n*= product_of_signs 1\nDEDENT\nelif num < 0: INDENT\n*= product_of_signs NEG 1\nDEDENT\nelse: INDENT\n= product_of_signs 0\nDEDENT\n+= total_sum call abs(num)\nDEDENT\nreturn * total_sum product_of_signs\nDEDENT\ncall print(call prod_signs(LIST[1, 2, 2, NEG 4]))\ncall print(call prod_signs(LIST[0, 1]))\ncall print(call prod_signs(LIST[]))\n\n"}
{"task_id": "HumanEval/129", "solution": "from heapq import heappop, heappush\ndef minPath(grid, k):\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    pq = [(grid[0][0], 0, 0)]\n    visited = set([(0, 0)])\n    while pq:\n        path_len, x, y = heappop(pq)\n        if len(path_len) == k:\n            return [grid[x][y] for x, y in path_len]\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                heappush(pq, (path_len + [grid[nx][ny]], nx, ny))\n", "origin_solution": "from heapq import heappop, heappush\ndef minPath(grid, k): INDENT\n= n call len(grid)\n= directions LIST[TUPLE (0, 1), TUPLE (1, 0), TUPLE (0, NEG 1), TUPLE (NEG 1, 0)]\n= pq LIST[TUPLE (SUB SUB grid[0][0], 0, 0)]\n= visited call set(LIST[TUPLE (0, 0)])\nwhile pq: INDENT\n= path_len, x, y call heappop(pq)\nif call len(path_len) == k: INDENT\nreturn LIST[SUB SUB grid[x][y] for x, y in path_len]\nDEDENT\nfor dx, dy in directions: INDENT\n= nx, ny + x dx, + y dy\nif and and 0 <= nx < n 0 <= ny < n TUPLE (nx, ny) not in visited: INDENT\ncall ATTR visited.add(TUPLE (nx, ny))\ncall heappush(pq, TUPLE (+ path_len LIST[SUB SUB grid[nx][ny]], nx, ny))\nDEDENT\nDEDENT\nDEDENT\nDEDENT\n\n"}
{"task_id": "HumanEval/130", "solution": "def tri(n):\n    tri_sequence = [0, 1, 1]\n    for i in range(3, n + 1):\n        if i % 2 == 0:\n            next_value = tri_sequence[i - 1] + i // 2\n        else:\n            next_value = tri_sequence[i - 1] + tri_sequence[i - 2] + tri_sequence[i + 1]\n        tri_sequence.append(next_value)\n    return tri_sequence\n", "origin_solution": "def tri(n): INDENT\n= tri_sequence LIST[0, 1, 1]\nfor i in call range(3, + n 1): INDENT\nif % i 2 == 0: INDENT\n= next_value + SUB tri_sequence[- i 1] // i 2\nDEDENT\nelse: INDENT\n= next_value + + SUB tri_sequence[- i 1] SUB tri_sequence[- i 2] SUB tri_sequence[+ i 1]\nDEDENT\ncall ATTR tri_sequence.append(next_value)\nDEDENT\nreturn tri_sequence\nDEDENT\n\n"}
{"task_id": "HumanEval/131", "solution": "def digits(n):\n    product = 1\n    has_odd = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 != 0:\n            product *= digit\n            has_odd = True\n        n = n // 10\n    return product if has_odd else 0\n", "origin_solution": "def digits(n): INDENT\n= product 1\n= has_odd False\nwhile n > 0: INDENT\n= digit % n 10\nif % digit 2 != 0: INDENT\n*= product digit\n= has_odd True\nDEDENT\n= n // n 10\nDEDENT\nreturn product if has_odd else 0\nDEDENT\n\n"}
{"task_id": "HumanEval/132", "solution": "def is_nested(string):\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) > 0\n", "origin_solution": "def is_nested(string): INDENT\n= stack LIST[]\nfor char in string: INDENT\nif char == '[': INDENT\ncall ATTR stack.append(char)\nDEDENT\nelif char == ']': INDENT\nif NOT stack: INDENT\nreturn False\nDEDENT\ncall ATTR stack.pop()\nDEDENT\nDEDENT\nreturn call len(stack) > 0\nDEDENT\n\n"}
{"task_id": "HumanEval/133", "solution": "import math\ndef sum_squares(lst):\n    \"\"\"You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n    \"\"\"\n    return sum([math.ceil(i ** 2) for i in lst])\n", "origin_solution": "import math\ndef sum_squares(lst): INDENT\n\"\"\"You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n    \"\"\"\nreturn call sum(LIST[call ATTR math.ceil(** i 2) for i in lst])\nDEDENT\n\n"}
{"task_id": "HumanEval/134", "solution": "def check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    words = txt.split()\n    if not words:\n        return False\n    last_word = words[-1]\n    if len(last_word) == 1 and last_word.isalpha():\n        return True\n    else:\n        return False\nprint(check_if_last_char_is_a_letter(\"apple pie\"))\nprint(check_if_last_char_is_a_letter(\"apple pi e\"))\nprint(check_if_last_char_is_a_letter(\"apple pi e \"))\nprint(check_if_last_char_is_a_letter(\"\"))\n", "origin_solution": "def check_if_last_char_is_a_letter(txt): INDENT\nif NOT txt: INDENT\nreturn False\nDEDENT\n= words call ATTR txt.split()\nif NOT words: INDENT\nreturn False\nDEDENT\n= last_word SUB words[NEG 1]\nif and call len(last_word) == 1 call ATTR last_word.isalpha(): INDENT\nreturn True\nDEDENT\nelse: INDENT\nreturn False\nDEDENT\nDEDENT\ncall print(call check_if_last_char_is_a_letter(\"apple pie\"))\ncall print(call check_if_last_char_is_a_letter(\"apple pi e\"))\ncall print(call check_if_last_char_is_a_letter(\"apple pi e \"))\ncall print(call check_if_last_char_is_a_letter(\"\"))\n\n"}
{"task_id": "HumanEval/135", "solution": "def can_arrange(arr):\n    max_index = -1\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            max_index = i\n    return max_index\n", "origin_solution": "def can_arrange(arr): INDENT\n= max_index NEG 1\nfor i in call range(1, call len(arr)): INDENT\nif SUB arr[i] < SUB arr[- i 1]: INDENT\n= max_index i\nDEDENT\nDEDENT\nreturn max_index\nDEDENT\n\n"}
{"task_id": "HumanEval/136", "solution": "def largest_smallest_integers(lst):\n    negative = [i for i in lst if i < 0]\n    positive = [i for i in lst if i > 0]\n    a = max(negative) if negative else None\n    b = min(positive) if positive else None\n    return (a, b)\nprint(largest_smallest_integers([2, 4, 1, 3, 5, 7]))\nprint(largest_smallest_integers([]))\nprint(largest_smallest_integers([0]))\n", "origin_solution": "def largest_smallest_integers(lst): INDENT\n= negative LIST[i for i in lst if i < 0]\n= positive LIST[i for i in lst if i > 0]\n= a call max(negative) if negative else None\n= b call min(positive) if positive else None\nreturn TUPLE (a, b)\nDEDENT\ncall print(call largest_smallest_integers(LIST[2, 4, 1, 3, 5, 7]))\ncall print(call largest_smallest_integers(LIST[]))\ncall print(call largest_smallest_integers(LIST[0]))\n\n"}
{"task_id": "HumanEval/137", "solution": "def compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) \u279e 2.5\n    compare_one(1, \"2,3\") \u279e \"2,3\"\n    compare_one(\"5,1\", \"6\") \u279e \"6\"\n    compare_one(\"1\", 1) \u279e None\n    \"\"\"\n    if type(a) == type(b):\n        if a == b:\n            return None\n        elif type(a) == int:\n            if a > b:\n                return a\n            else:\n                return b\n        elif type(a) == float:\n            if a > b:\n                return a\n            else:\n                return b\n        elif type(a) == str:\n            if a > b:\n                return a\n            else:\n                return b\n    else:\n        if type(a) == int:\n            if a > b:\n                return a\n            else:\n                return b\n        elif type(a) == float:\n            if a > b:\n                return a\n            else:\n                return b\n        elif type(a) == str:\n            if a > b:\n                return a\n            else:\n                return b\n", "origin_solution": "def compare_one(a, b): INDENT\n\"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) \u279e 2.5\n    compare_one(1, \"2,3\") \u279e \"2,3\"\n    compare_one(\"5,1\", \"6\") \u279e \"6\"\n    compare_one(\"1\", 1) \u279e None\n    \"\"\"\nif call type(a) == call type(b): INDENT\nif a == b: INDENT\nreturn None\nDEDENT\nelif call type(a) == int: INDENT\nif a > b: INDENT\nreturn a\nDEDENT\nelse: INDENT\nreturn b\nDEDENT\nDEDENT\nelif call type(a) == float: INDENT\nif a > b: INDENT\nreturn a\nDEDENT\nelse: INDENT\nreturn b\nDEDENT\nDEDENT\nelif call type(a) == str: INDENT\nif a > b: INDENT\nreturn a\nDEDENT\nelse: INDENT\nreturn b\nDEDENT\nDEDENT\nDEDENT\nelse: INDENT\nif call type(a) == int: INDENT\nif a > b: INDENT\nreturn a\nDEDENT\nelse: INDENT\nreturn b\nDEDENT\nDEDENT\nelif call type(a) == float: INDENT\nif a > b: INDENT\nreturn a\nDEDENT\nelse: INDENT\nreturn b\nDEDENT\nDEDENT\nelif call type(a) == str: INDENT\nif a > b: INDENT\nreturn a\nDEDENT\nelse: INDENT\nreturn b\nDEDENT\nDEDENT\nDEDENT\nDEDENT\n\n"}
{"task_id": "HumanEval/138", "solution": "def is_equal_to_sum_even(n):\n    if n < 8:\n        return False\n    if n % 2 != 0:\n        return False\n    return True\n", "origin_solution": "def is_equal_to_sum_even(n): INDENT\nif n < 8: INDENT\nreturn False\nDEDENT\nif % n 2 != 0: INDENT\nreturn False\nDEDENT\nreturn True\nDEDENT\n\n"}
{"task_id": "HumanEval/139", "solution": "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n", "origin_solution": "def special_factorial(n): INDENT\n\"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n= result 1\nfor i in call range(1, + n 1): INDENT\n*= result i\nDEDENT\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/140", "solution": "def fix_spaces(text):\n    text = text.replace(\" \", \"_\")\n    while \"  \" in text:\n        text = text.replace(\"  \", \"-\")\n    return text\n", "origin_solution": "def fix_spaces(text): INDENT\n= text call ATTR text.replace(\" \", \"_\")\nwhile \"  \" in text: INDENT\n= text call ATTR text.replace(\"  \", \"-\")\nDEDENT\nreturn text\nDEDENT\n\n"}
{"task_id": "HumanEval/141", "solution": "def file_name_check(file_name):\n    if file_name.count('.') != 1:\n        return 'No'\n    name_before_dot, extension = file_name.split('.')\n    if not name_before_dot or not name_before_dot[0].isalpha():\n        return 'No'\n    valid_extensions = ['txt', 'exe', 'dll']\n    if extension not in valid_extensions:\n        return 'No'\n    if any(char.isdigit() for char in file_name):\n        return 'No'\n    return 'Yes'\n", "origin_solution": "def file_name_check(file_name): INDENT\nif call ATTR file_name.count('.') != 1: INDENT\nreturn 'No'\nDEDENT\n= name_before_dot, extension call ATTR file_name.split('.')\nif or NOT name_before_dot NOT call ATTR SUB name_before_dot[0].isalpha(): INDENT\nreturn 'No'\nDEDENT\n= valid_extensions LIST['txt', 'exe', 'dll']\nif extension not in valid_extensions: INDENT\nreturn 'No'\nDEDENT\nif call any(call ATTR char.isdigit() for char in file_name): INDENT\nreturn 'No'\nDEDENT\nreturn 'Yes'\nDEDENT\n\n"}
{"task_id": "HumanEval/142", "solution": "def sum_squares(lst):\n    \"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index \n    is a multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n    \"\"\"\n    return sum(x ** 2 if i % 3 == 0 else x ** 3 for i, x in enumerate(lst))\n", "origin_solution": "def sum_squares(lst): INDENT\n\"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index \n    is a multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n    \"\"\"\nreturn call sum(** x 2 if % i 3 == 0 else ** x 3 for i, x in call enumerate(lst))\nDEDENT\n\n"}
{"task_id": "HumanEval/143", "solution": "def is_prime(n):\n    \"\"\"\n    Helper function to check if a number is prime.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef words_in_sentence(sentence):\n    \"\"\"\n    Given a string representing a sentence,\n    return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n    \"\"\"\n    words = sentence.split()\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_length_words)\n", "origin_solution": "def is_prime(n): INDENT\n\"\"\"\n    Helper function to check if a number is prime.\n    \"\"\"\nif n <= 1: INDENT\nreturn False\nDEDENT\nif n <= 3: INDENT\nreturn True\nDEDENT\nif or % n 2 == 0 % n 3 == 0: INDENT\nreturn False\nDEDENT\n= i 5\nwhile * i i <= n: INDENT\nif or % n i == 0 % n (+ i 2) == 0: INDENT\nreturn False\nDEDENT\n+= i 6\nDEDENT\nreturn True\nDEDENT\ndef words_in_sentence(sentence): INDENT\n\"\"\"\n    Given a string representing a sentence,\n    return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n    \"\"\"\n= words call ATTR sentence.split()\n= prime_length_words LIST[word for word in words if call is_prime(call len(word))]\nreturn call ATTR ' '.join(prime_length_words)\nDEDENT\n\n"}
{"task_id": "HumanEval/144", "solution": "def simplify(x, n):\n    x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    product = x_num * n_num\n    product_den = x_den * n_den\n    return product == product_den\nprint(simplify(\"1/5\", \"5/1\"))\nprint(simplify(\"1/6\", \"2/1\"))\nprint(simplify(\"7/10\", \"10/2\"))\n", "origin_solution": "def simplify(x, n): INDENT\n= x_num, x_den call map(int, call ATTR x.split('/'))\n= n_num, n_den call map(int, call ATTR n.split('/'))\n= product * x_num n_num\n= product_den * x_den n_den\nreturn product == product_den\nDEDENT\ncall print(call simplify(\"1/5\", \"5/1\"))\ncall print(call simplify(\"1/6\", \"2/1\"))\ncall print(call simplify(\"7/10\", \"10/2\"))\n\n"}
{"task_id": "HumanEval/145", "solution": "def order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(abs(n)))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))\n", "origin_solution": "def order_by_points(nums): INDENT\n\"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\ndef digit_sum(n): INDENT\nreturn call sum(call int(digit) for digit in call str(call abs(n)))\nDEDENT\nreturn call sorted(nums, key=lambda x: TUPLE (call digit_sum(x), call ATTR nums.index(x)))\nDEDENT\n\n"}
{"task_id": "HumanEval/146", "solution": "def specialFilter(nums):\n    def isOddDigit(n):\n        return n % 2 != 0\n    def isFirstDigitOdd(n):\n        return isOddDigit(int(str(n)[0]))\n    def isLastDigitOdd(n):\n        return isOddDigit(int(str(n)[-1]))\n    count = 0\n    for num in nums:\n        if num > 10 and isFirstDigitOdd(num) and isLastDigitOdd(num):\n            count += 1\n    return count\n", "origin_solution": "def specialFilter(nums): INDENT\ndef isOddDigit(n): INDENT\nreturn % n 2 != 0\nDEDENT\ndef isFirstDigitOdd(n): INDENT\nreturn call isOddDigit(call int(SUB call str(n)[0]))\nDEDENT\ndef isLastDigitOdd(n): INDENT\nreturn call isOddDigit(call int(SUB call str(n)[NEG 1]))\nDEDENT\n= count 0\nfor num in nums: INDENT\nif and and num > 10 call isFirstDigitOdd(num) call isLastDigitOdd(num): INDENT\n+= count 1\nDEDENT\nDEDENT\nreturn count\nDEDENT\n\n"}
{"task_id": "HumanEval/147", "solution": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count\n", "origin_solution": "def get_max_triples(n): INDENT\n= a LIST[+ - * i i i 1 for i in call range(1, + n 1)]\n= count 0\nfor i in call range(n): INDENT\nfor j in call range(+ i 1, n): INDENT\nfor k in call range(+ j 1, n): INDENT\nif % (+ + SUB a[i] SUB a[j] SUB a[k]) 3 == 0: INDENT\n+= count 1\nDEDENT\nDEDENT\nDEDENT\nDEDENT\nreturn count\nDEDENT\n\n"}
{"task_id": "HumanEval/148", "solution": "def bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 > index2:\n        index1, index2 = index2, index1\n    return planets[index1 + 1:index2]\n", "origin_solution": "def bf(planet1, planet2): INDENT\n'''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n= planets LIST[\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\nif or planet1 not in planets planet2 not in planets: INDENT\nreturn TUPLE ()\nDEDENT\n= index1 call ATTR planets.index(planet1)\n= index2 call ATTR planets.index(planet2)\nif index1 > index2: INDENT\n= index1, index2 index2, index1\nDEDENT\nreturn SUB planets[+ index1 1:index2]\nDEDENT\n\n"}
{"task_id": "HumanEval/149", "solution": "def sorted_list_sum(lst):\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n    sorted_words = sorted(even_length_words, key=lambda x: (len(x), x))\n    return sorted_words\n", "origin_solution": "def sorted_list_sum(lst): INDENT\n= even_length_words LIST[word for word in lst if % call len(word) 2 == 0]\n= sorted_words call sorted(even_length_words, key=lambda x: TUPLE (call len(x), x))\nreturn sorted_words\nDEDENT\n\n"}
{"task_id": "HumanEval/150", "solution": "def x_or_y(n, x, y):\n    \"\"\"A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    if is_prime(n):\n        return x\n    else:\n        return y\nprint(x_or_y(7, 34, 12))\nprint(x_or_y(15, 8, 5))\n", "origin_solution": "def x_or_y(n, x, y): INDENT\n\"\"\"A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\ndef is_prime(num): INDENT\nif num < 2: INDENT\nreturn False\nDEDENT\nfor i in call range(2, + call int(** num 0.5) 1): INDENT\nif % num i == 0: INDENT\nreturn False\nDEDENT\nDEDENT\nreturn True\nDEDENT\nif call is_prime(n): INDENT\nreturn x\nDEDENT\nelse: INDENT\nreturn y\nDEDENT\nDEDENT\ncall print(call x_or_y(7, 34, 12))\ncall print(call x_or_y(15, 8, 5))\n\n"}
{"task_id": "HumanEval/151", "solution": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n    return sum(x ** 2 for x in lst if isinstance(x, int) and x > 0 and x % 2 != 0)\n", "origin_solution": "def double_the_difference(lst): INDENT\n'''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\nreturn call sum(** x 2 for x in lst if and and call isinstance(x, int) x > 0 % x 2 != 0)\nDEDENT\n\n"}
{"task_id": "HumanEval/152", "solution": "def compare(game, guess):\n    result = []\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            result.append(0)\n        else:\n            result.append(abs(guess[i] - game[i]))\n    return result\n", "origin_solution": "def compare(game, guess): INDENT\n= result LIST[]\nfor i in call range(call len(game)): INDENT\nif SUB game[i] == SUB guess[i]: INDENT\ncall ATTR result.append(0)\nDEDENT\nelse: INDENT\ncall ATTR result.append(call abs(- SUB guess[i] SUB game[i]))\nDEDENT\nDEDENT\nreturn result\nDEDENT\n\n"}
{"task_id": "HumanEval/153", "solution": "def Strongest_Extension(class_name, extensions):\n    strongest_strength = float('-inf')\n    strongest_extension = None\n    for extension in extensions:\n        capital_count = sum(1 for char in extension if char.isupper())\n        lowercase_count = sum(1 for char in extension if char.islower())\n        strength = capital_count - lowercase_count\n        if strength > strongest_strength:\n            strongest_strength = strength\n            strongest_extension = extension\n    return class_name + '.' + strongest_extension\nprint(Strongest_Extension('my_class', ['AA', 'Be', 'CC']))\n", "origin_solution": "def Strongest_Extension(class_name, extensions): INDENT\n= strongest_strength call float('-inf')\n= strongest_extension None\nfor extension in extensions: INDENT\n= capital_count call sum(1 for char in extension if call ATTR char.isupper())\n= lowercase_count call sum(1 for char in extension if call ATTR char.islower())\n= strength - capital_count lowercase_count\nif strength > strongest_strength: INDENT\n= strongest_strength strength\n= strongest_extension extension\nDEDENT\nDEDENT\nreturn + + class_name '.' strongest_extension\nDEDENT\ncall print(call Strongest_Extension('my_class', LIST['AA', 'Be', 'CC']))\n\n"}
{"task_id": "HumanEval/154", "solution": "def cycpattern_check(a, b):\n    \"\"\"\n    You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \"\"\"\n    b_rotations = [b[i:] + b[:i] for i in range(len(b))]\n    for rotation in b_rotations:\n        if rotation in a:\n            return True\n    return False\n", "origin_solution": "def cycpattern_check(a, b): INDENT\n\"\"\"\n    You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n    \"\"\"\n= b_rotations LIST[+ SUB b[i:] SUB b[:i] for i in call range(call len(b))]\nfor rotation in b_rotations: INDENT\nif rotation in a: INDENT\nreturn True\nDEDENT\nDEDENT\nreturn False\nDEDENT\n\n"}
{"task_id": "HumanEval/155", "solution": "def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)\n", "origin_solution": "def even_odd_count(num): INDENT\n= even_count 0\n= odd_count 0\nfor digit in call str(call abs(num)): INDENT\nif % call int(digit) 2 == 0: INDENT\n+= even_count 1\nDEDENT\nelse: INDENT\n+= odd_count 1\nDEDENT\nDEDENT\nreturn TUPLE (even_count, odd_count)\nDEDENT\n\n"}
{"task_id": "HumanEval/156", "solution": "def int_to_mini_roman(number):\n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    syms = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    roman_num = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syms[i]\n            number -= val[i]\n        i += 1\n    return roman_num\n", "origin_solution": "def int_to_mini_roman(number): INDENT\n= val LIST[1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n= syms LIST[\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n= roman_num ''\n= i 0\nwhile number > 0: INDENT\nfor _ in call range(// number SUB val[i]): INDENT\n+= roman_num SUB syms[i]\n-= number SUB val[i]\nDEDENT\n+= i 1\nDEDENT\nreturn roman_num\nDEDENT\n\n"}
{"task_id": "HumanEval/157", "solution": "def right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    sides = sorted([a, b, c])\n    return sides[0] ** 2 + sides[1] ** 2 == sides[2] ** 2\n", "origin_solution": "def right_angle_triangle(a, b, c): INDENT\n'''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n= sides call sorted(LIST[a, b, c])\nreturn + ** SUB sides[0] 2 ** SUB sides[1] 2 == ** SUB sides[2] 2\nDEDENT\n\n"}
{"task_id": "HumanEval/158", "solution": "def find_max(words):\n    max_unique_chars = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique_chars or (unique_chars == max_unique_chars and word < max_word):\n            max_unique_chars = unique_chars\n            max_word = word\n    return max_word\n", "origin_solution": "def find_max(words): INDENT\n= max_unique_chars 0\n= max_word \"\"\nfor word in words: INDENT\n= unique_chars call len(call set(word))\nif or unique_chars > max_unique_chars (and unique_chars == max_unique_chars word < max_word): INDENT\n= max_unique_chars unique_chars\n= max_word word\nDEDENT\nDEDENT\nreturn max_word\nDEDENT\n\n"}
{"task_id": "HumanEval/159", "solution": "def eat(number, need, remaining):\n    if remaining >= need:\n        return [number + need - remaining, remaining - need]\n    else:\n        return [number, remaining]\n", "origin_solution": "def eat(number, need, remaining): INDENT\nif remaining >= need: INDENT\nreturn LIST[- + number need remaining, - remaining need]\nDEDENT\nelse: INDENT\nreturn LIST[number, remaining]\nDEDENT\nDEDENT\n\n"}
{"task_id": "HumanEval/160", "solution": "def do_algebra(operator, operand):\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += ' ' + operator[i] + ' ' + str(operand[i + 1])\n    result = eval(expression)\n    return result\noperator = ['+', '*', '-']\narray = [2, 3, 4, 5]\nresult = do_algebra(operator, array)\nprint(result)\n", "origin_solution": "def do_algebra(operator, operand): INDENT\n= expression call str(SUB operand[0])\nfor i in call range(call len(operator)): INDENT\n+= expression + + + ' ' SUB operator[i] ' ' call str(SUB operand[+ i 1])\nDEDENT\n= result call eval(expression)\nreturn result\nDEDENT\n= operator LIST['+', '*', '-']\n= array LIST[2, 3, 4, 5]\n= result call do_algebra(operator, array)\ncall print(result)\n\n"}
{"task_id": "HumanEval/161", "solution": "def solve(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                result += char.upper()\n            else:\n                result += char.lower()\n        else:\n            result += char\n    if result == s:\n        return result[::-1]\n    return result\nprint(solve(\"1234\"))\nprint(solve(\"ab\"))\nprint(solve(\"#a@C\"))\n", "origin_solution": "def solve(s): INDENT\n= result \"\"\nfor char in s: INDENT\nif call ATTR char.isalpha(): INDENT\nif call ATTR char.islower(): INDENT\n+= result call ATTR char.upper()\nDEDENT\nelse: INDENT\n+= result call ATTR char.lower()\nDEDENT\nDEDENT\nelse: INDENT\n+= result char\nDEDENT\nDEDENT\nif result == s: INDENT\nreturn SUB result[::NEG 1]\nDEDENT\nreturn result\nDEDENT\ncall print(call solve(\"1234\"))\ncall print(call solve(\"ab\"))\ncall print(call solve(\"#a@C\"))\n\n"}
{"task_id": "HumanEval/162", "solution": "import hashlib\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if not text:\n        return None\n    return hashlib.md5(text.encode()).hexdigest()\n", "origin_solution": "import hashlib\ndef string_to_md5(text): INDENT\n\"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\nif NOT text: INDENT\nreturn None\nDEDENT\nreturn call ATTR call ATTR hashlib.md5(call ATTR text.encode()).hexdigest()\nDEDENT\n\n"}
{"task_id": "HumanEval/163", "solution": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n    result = []\n    for i in range(a, b + 1):\n        for digit in str(i):\n            if int(digit) % 2 == 0:\n                result.append(int(digit))\n    return result\n", "origin_solution": "def generate_integers(a, b): INDENT\n\"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n= result LIST[]\nfor i in call range(a, + b 1): INDENT\nfor digit in call str(i): INDENT\nif % call int(digit) 2 == 0: INDENT\ncall ATTR result.append(call int(digit))\nDEDENT\nDEDENT\nDEDENT\nreturn result\nDEDENT\n\n"}
