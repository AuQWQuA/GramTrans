{"task_id": "Mbpp/2", "origin_solution": "<def_stmt>similar_elements list1 list2<block_start><return>tuple(set(list1)&set(list2))<block_end>\n", "solution": "\ndef similar_elements (list1, list2):\n    return tuple(set(list1)&set(list2))\n    \n\n"}
{"task_id": "Mbpp/3", "origin_solution": "<def_stmt>is_not_prime n<block_start><if_stmt>n<le>1<block_start><return><true><block_end><for_stmt>i range(2 int(n<power>0.5)+1)<block_start><if_stmt>n%i<eq>0<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef is_not_prime (n):\n    if n<=1:\n        return  True \n        \n    for i in range(2, int(n**0.5)+1):\n        if n%i==0:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/4", "origin_solution": "<import_stmt>heapq<def_stmt>heap_queue_largest nums n<block_start><return>heapq.nlargest(n nums)<block_end>\n", "solution": "\nimport heapq\ndef heap_queue_largest (nums, n):\n    return heapq.nlargest(n, nums)\n    \n\n"}
{"task_id": "Mbpp/6", "origin_solution": "<def_stmt>differ_At_One_Bit_Pos x y<block_start>xor_result=x^y<line_sep><return>xor_result&(xor_result-1)<ne>0<block_end>\n", "solution": "\ndef differ_At_One_Bit_Pos (x, y):\n    xor_result=x^y\n    return xor_result&(xor_result-1)!=0\n    \n\n"}
{"task_id": "Mbpp/7", "origin_solution": "<def_stmt>find_char_long s<block_start>words=s.split()<line_sep><return>[word<for>word words<if>len(word)<ge>4]<block_end>\n", "solution": "\ndef find_char_long (s):\n    words=s.split()\n    return [word for word in words if len(word)>=4]\n    \n\n"}
{"task_id": "Mbpp/8", "origin_solution": "<def_stmt>square_nums nums<block_start><return>[num<power>2<for>num nums]<block_end>\n", "solution": "\ndef square_nums (nums):\n    return [num**2 for num in nums]\n    \n\n"}
{"task_id": "Mbpp/9", "origin_solution": "<def_stmt>find_Rotations s<block_start>n=len(s)<line_sep>rotations=0<for_stmt>i range(1 n)<block_start>rotated=s[i:]+s[:i]<if_stmt>rotated<eq>s<block_start>rotations=i<line_sep><break><block_end><block_end><return>rotations<block_end>\n", "solution": "\ndef find_Rotations (s):\n    n=len(s)\n    rotations=0\n    for i in range(1, n):\n        rotated=s[i:]+s[:i]\n        if rotated==s:\n            rotations=i\n            break \n            \n    \n    return rotations\n    \n\n"}
{"task_id": "Mbpp/11", "origin_solution": "<def_stmt>remove_Occ s char<block_start>first_index=s.find(char)<line_sep>last_index=s.rfind(char)<if_stmt>first_index<eq>-1<or>last_index<eq>-1<block_start><return>s<block_end><return>s[:first_index]+s[last_index+1:]<block_end>print(remove_Occ(\"hello\" \"l\"))<line_sep>print(remove_Occ(\"abcda\" \"a\"))<line_sep>print(remove_Occ(\"PHP\" \"P\"))<line_sep>\n", "solution": "\ndef remove_Occ (s, char):\n    first_index=s.find(char)\n    last_index=s.rfind(char)\n    if first_index==-1 or last_index==-1:\n        return s\n        \n    return s[:first_index]+s[last_index+1:]\n    \nprint(remove_Occ(\"hello\", \"l\"))\nprint(remove_Occ(\"abcda\", \"a\"))\nprint(remove_Occ(\"PHP\", \"P\"))\n\n"}
{"task_id": "Mbpp/12", "origin_solution": "<def_stmt>sort_matrix matrix<block_start>sorted_matrix=sorted(matrix key=<lambda>row:sum(row))<line_sep><return>sorted_matrix<block_end>\n", "solution": "\ndef sort_matrix (matrix):\n    sorted_matrix=sorted(matrix, key=lambda row:sum(row))\n    return sorted_matrix\n    \n\n"}
{"task_id": "Mbpp/14", "origin_solution": "<def_stmt>find_Volume length width height<block_start><return>(1/3)<times>length<times>width<times>height<block_end>\n", "solution": "\ndef find_Volume (length, width, height):\n    return (1/3)*length*width*height\n    \n\n"}
{"task_id": "Mbpp/16", "origin_solution": "<import_stmt>re<def_stmt>text_lowercase_underscore text<block_start>pattern=r'^[a-z]+_[a-z]+$'<line_sep><return>bool(re.match(pattern text))<block_end>\n", "solution": "\nimport re\ndef text_lowercase_underscore (text):\n    pattern=r'^[a-z]+_[a-z]+$'\n    return bool(re.match(pattern, text))\n    \n\n"}
{"task_id": "Mbpp/17", "origin_solution": "<def_stmt>square_perimeter side_length<block_start><return>4<times>side_length<block_end>\n", "solution": "\ndef square_perimeter (side_length):\n    return 4*side_length\n    \n\n"}
{"task_id": "Mbpp/18", "origin_solution": "<def_stmt>remove_dirty_chars s1 s2<block_start><return>''.join([char<for>char s1<if>char<not><in>s2])<block_end>\n", "solution": "\ndef remove_dirty_chars (s1, s2):\n    return ''.join([char for char in s1 if char not  in s2])\n    \n\n"}
{"task_id": "Mbpp/19", "origin_solution": "<def_stmt>test_duplicate arr<block_start><return>len(arr)<ne>len(set(arr))<block_end>\n", "solution": "\ndef test_duplicate (arr):\n    return len(arr)!=len(set(arr))\n    \n\n"}
{"task_id": "Mbpp/20", "origin_solution": "<def_stmt>is_woodall num<block_start><return>num%7<eq>0<block_end>\n", "solution": "\ndef is_woodall (num):\n    return num%7==0\n    \n\n"}
{"task_id": "Mbpp/56", "origin_solution": "<def_stmt>check num<block_start>reverse_num=int(str(num)[::-1])<line_sep><return>num-reverse_num<eq>1<block_end>\n", "solution": "\ndef check (num):\n    reverse_num=int(str(num)[::-1])\n    return num-reverse_num==1\n    \n\n"}
{"task_id": "Mbpp/57", "origin_solution": "<def_stmt>find_Max_Num digits<block_start>digits.sort(reverse=<true>)<line_sep><return>int(''.join(map(str digits)))<block_end>\n", "solution": "\ndef find_Max_Num (digits):\n    digits.sort(reverse= True )\n    return int(''.join(map(str, digits)))\n    \n\n"}
{"task_id": "Mbpp/58", "origin_solution": "<def_stmt>opposite_Signs a b<block_start><return>a<times>b<l>0<block_end>\n", "solution": "\ndef opposite_Signs (a, b):\n    return a*b<0\n    \n\n"}
{"task_id": "Mbpp/59", "origin_solution": "<def_stmt>is_octagonal n<block_start><return>n<times>(3<times>n-1)<block_end>\n", "solution": "\ndef is_octagonal (n):\n    return n*(3*n-1)\n    \n\n"}
{"task_id": "Mbpp/61", "origin_solution": "<def_stmt>count_Substrings s<block_start>count=0<for_stmt>i range(len(s))<block_start>sum=0<for_stmt>j range(i len(s))<block_start>sum<augadd>int(s[j])<if_stmt>sum<eq>j-i+1<block_start>count<augadd>1<block_end><block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_Substrings (s):\n    count=0\n    for i in range(len(s)):\n        sum=0\n        for j in range(i, len(s)):\n            sum+=int(s[j])\n            if sum==j-i+1:\n                count+=1\n                \n        \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/62", "origin_solution": "<def_stmt>smallest_num lst<block_start><return>min(lst)<block_end>\n", "solution": "\ndef smallest_num (lst):\n    return min(lst)\n    \n\n"}
{"task_id": "Mbpp/63", "origin_solution": "<def_stmt>max_difference test_list<block_start>test_list.sort(key=<lambda>x:x[0])<line_sep>max_diff=0<for_stmt>i range(len(test_list)-1)<block_start>diff=abs(test_list[i][0]-test_list[i+1][0])<if_stmt>diff<g>max_diff<block_start>max_diff=diff<block_end><block_end><return>max_diff<block_end>\n", "solution": "\ndef max_difference (test_list):\n    test_list.sort(key=lambda x:x[0])\n    max_diff=0\n    for i in range(len(test_list)-1):\n        diff=abs(test_list[i][0]-test_list[i+1][0])\n        if diff>max_diff:\n            max_diff=diff\n            \n    \n    return max_diff\n    \n\n"}
{"task_id": "Mbpp/64", "origin_solution": "<def_stmt>subject_marks lst<block_start><return>sorted(lst key=<lambda>x:x[1])<block_end>\n", "solution": "\ndef subject_marks (lst):\n    return sorted(lst, key=lambda x:x[1])\n    \n\n"}
{"task_id": "Mbpp/65", "origin_solution": "<def_stmt>recursive_list_sum lst<block_start>total=0<for_stmt>element lst<block_start><if_stmt>isinstance(element list)<block_start>total<augadd>recursive_list_sum(element)<block_end><else_stmt><block_start>total<augadd>element<block_end><block_end><return>total<block_end>\n", "solution": "\ndef recursive_list_sum (lst):\n    total=0\n    for element in lst:\n        if isinstance(element, list):\n            total+=recursive_list_sum(element)\n            \n        \n        else :\n            total+=element\n            \n    \n    return total\n    \n\n"}
{"task_id": "Mbpp/66", "origin_solution": "<def_stmt>pos_count lst<block_start>count=0<for_stmt>num lst<block_start><if_stmt>num<g>0<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef pos_count (lst):\n    count=0\n    for num in lst:\n        if num>0:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/67", "origin_solution": "<def_stmt>bell_number n<block_start>bell=[[0<for>i range(n+1)]<for>j range(n+1)]<line_sep>bell[0][0]=1<for_stmt>i range(1 n+1)<block_start>bell[i][0]=bell[i-1][i-1]<for_stmt>j range(1 i+1)<block_start>bell[i][j]=bell[i-1][j-1]+bell[i][j-1]<block_end><block_end><return>sum(bell[n])<block_end>\n", "solution": "\ndef bell_number (n):\n    bell=[[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0]=1\n    for i in range(1, n+1):\n        bell[i][0]=bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j]=bell[i-1][j-1]+bell[i][j-1]\n            \n    \n    return sum(bell[n])\n    \n\n"}
{"task_id": "Mbpp/68", "origin_solution": "<def_stmt>is_Monotonic arr<block_start><return>all(arr[i]<le>arr[i+1]<for>i range(len(arr)-1))<or>all(arr[i]<ge>arr[i+1]<for>i range(len(arr)-1))<block_end>\n", "solution": "\ndef is_Monotonic (arr):\n    return all(arr[i]<=arr[i+1] for i in range(len(arr)-1)) or all(arr[i]>=arr[i+1] for i in range(len(arr)-1))\n    \n\n"}
{"task_id": "Mbpp/69", "origin_solution": "<def_stmt>is_sublist lst sublst<block_start><for_stmt>i range(len(lst)-len(sublst)+1)<block_start><if_stmt>lst[i:i+len(sublst)]<eq>sublst<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef is_sublist (lst, sublst):\n    for i in range(len(lst)-len(sublst)+1):\n        if lst[i:i+len(sublst)]==sublst:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/70", "origin_solution": "<def_stmt>get_equal tuples<block_start><return>all(len(t)<eq>len(tuples[0])<for>t tuples)<block_end>\n", "solution": "\ndef get_equal (tuples):\n    return all(len(t)==len(tuples[0]) for t in tuples)\n    \n\n"}
{"task_id": "Mbpp/71", "origin_solution": "<def_stmt>comb_sort lst<block_start>gap=len(lst)<line_sep>shrink_factor=1.3<line_sep>sorted=<false><while_stmt><not>sorted<block_start>gap=int(gap/shrink_factor)<if_stmt>gap<le>1<block_start>gap=1<line_sep>sorted=<true><block_end>i=0<while_stmt>i+gap<l>len(lst)<block_start><if_stmt>lst[i]<g>lst[i+gap]<block_start>lst[i],lst[i+gap]=lst[i+gap] lst[i]<line_sep>sorted=<false><block_end>i<augadd>1<block_end><block_end><return>lst<block_end>\n", "solution": "\ndef comb_sort (lst):\n    gap=len(lst)\n    shrink_factor=1.3\n    sorted= False \n    while  not sorted:\n        gap=int(gap/shrink_factor)\n        if gap<=1:\n            gap=1\n            sorted= True \n            \n        i=0\n        while i+gap<len(lst):\n            if lst[i]>lst[i+gap]:\n                lst[i],lst[i+gap]=lst[i+gap], lst[i]\n                sorted= False \n                \n            i+=1\n            \n    \n    return lst\n    \n\n"}
{"task_id": "Mbpp/72", "origin_solution": "<def_stmt>dif_Square n<block_start>i=0<while_stmt>i<times>i<le>n<block_start>j=int((n-i<times>i)<power>0.5)<if_stmt>i<times>i+j<times>j<eq>n<block_start><return><true><block_end>i<augadd>1<block_end><return><false><block_end>\n", "solution": "\ndef dif_Square (n):\n    i=0\n    while i*i<=n:\n        j=int((n-i*i)**0.5)\n        if i*i+j*j==n:\n            return  True \n            \n        i+=1\n        \n    return  False \n    \n\n"}
{"task_id": "Mbpp/74", "origin_solution": "<def_stmt>is_samepatterns patterns sequence<block_start><return>patterns<eq>sequence<block_end>\n", "solution": "\ndef is_samepatterns (patterns, sequence):\n    return patterns==sequence\n    \n\n"}
{"task_id": "Mbpp/75", "origin_solution": "<def_stmt>find_tuples tuples_list k<block_start>result=[]<for_stmt>t tuples_list<block_start><if_stmt>all(i%k<eq>0<for>i t)<block_start>result.append(t)<block_end><block_end><return>result<block_end>\n", "solution": "\ndef find_tuples (tuples_list, k):\n    result=[]\n    for t in tuples_list:\n        if all(i%k==0 for i in t):\n            result.append(t)\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/77", "origin_solution": "<def_stmt>is_Diff n<block_start><return>n%11<eq>0<block_end>\n", "solution": "\ndef is_Diff (n):\n    return n%11==0\n    \n\n"}
{"task_id": "Mbpp/79", "origin_solution": "<def_stmt>word_len word<block_start><return>len(word)%2<ne>0<block_end>\n", "solution": "\ndef word_len (word):\n    return len(word)%2!=0\n    \n\n"}
{"task_id": "Mbpp/80", "origin_solution": "<def_stmt>tetrahedral_number n<block_start><return>n<times>(n+1)<times>(n+2)<floordiv>6<block_end>\n", "solution": "\ndef tetrahedral_number (n):\n    return n*(n+1)*(n+2)//6\n    \n\n"}
{"task_id": "Mbpp/82", "origin_solution": "<import_stmt>math<def_stmt>volume_sphere radius<block_start><return>(4/3)<times>math.pi<times>(radius<power>3)<block_end>\n", "solution": "\nimport math\ndef volume_sphere (radius):\n    return (4/3)*math.pi*(radius**3)\n    \n\n"}
{"task_id": "Mbpp/84", "origin_solution": "<def_stmt>sequence n<block_start><if_stmt>n<eq>1<block_start><return>1<block_end><elif_stmt>n<eq>2<block_start><return>1<block_end><elif_stmt>n<eq>3<block_start><return>2<block_end><else_stmt><block_start>a,b,c=1 1 2<for_stmt>_ range(3 n)<block_start>a,b,c=b c a+b<block_end><return>c<block_end><block_end>\n", "solution": "\ndef sequence (n):\n    if n==1:\n        return 1\n        \n    \n    elif n==2:\n        return 1\n        \n    \n    elif n==3:\n        return 2\n        \n    \n    else :\n        a,b,c=1, 1, 2\n        for _ in range(3, n):\n            a,b,c=b, c, a+b\n            \n        return c\n        \n\n\n"}
{"task_id": "Mbpp/85", "origin_solution": "<import_stmt>math<def_stmt>surfacearea_sphere radius<block_start><return>4<times>math.pi<times>radius<power>2<block_end>\n", "solution": "\nimport math\ndef surfacearea_sphere (radius):\n    return 4*math.pi*radius**2\n    \n\n"}
{"task_id": "Mbpp/86", "origin_solution": "<def_stmt>centered_hexagonal_number n<block_start><return>3<times>n<times>(n-1)+1<block_end>\n", "solution": "\ndef centered_hexagonal_number (n):\n    return 3*n*(n-1)+1\n    \n\n"}
{"task_id": "Mbpp/87", "origin_solution": "<def_stmt>merge_dictionaries_three dict1 dict2 dict3<block_start>merged_dict={}<for_stmt>key,value dict1.items()<block_start>merged_dict[key]=value<block_end><for_stmt>key,value dict2.items()<block_start>merged_dict[key]=value<block_end><for_stmt>key,value dict3.items()<block_start>merged_dict[key]=value<block_end><return>merged_dict<block_end>\n", "solution": "\ndef merge_dictionaries_three (dict1, dict2, dict3):\n    merged_dict={}\n    for key,value in dict1.items():\n        merged_dict[key]=value\n        \n    for key,value in dict2.items():\n        merged_dict[key]=value\n        \n    for key,value in dict3.items():\n        merged_dict[key]=value\n        \n    return merged_dict\n    \n\n"}
{"task_id": "Mbpp/88", "origin_solution": "<def_stmt>freq_count lst<block_start>freq_dict={}<for_stmt>element lst<block_start><if_stmt>element<in>freq_dict<block_start>freq_dict[element]<augadd>1<block_end><else_stmt><block_start>freq_dict[element]=1<block_end><block_end><return>freq_dict<block_end>\n", "solution": "\ndef freq_count (lst):\n    freq_dict={}\n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element]+=1\n            \n        \n        else :\n            freq_dict[element]=1\n            \n    \n    return freq_dict\n    \n\n"}
{"task_id": "Mbpp/89", "origin_solution": "<def_stmt>closest_num n<block_start><return>n-1<block_end>\n", "solution": "\ndef closest_num (n):\n    return n-1\n    \n\n"}
{"task_id": "Mbpp/90", "origin_solution": "<def_stmt>len_log words<block_start><return>max(len(word)<for>word words)<block_end>\n", "solution": "\ndef len_log (words):\n    return max(len(word) for word in words)\n    \n\n"}
{"task_id": "Mbpp/91", "origin_solution": "<def_stmt>find_substring list_of_strings substring<block_start><for_stmt>string list_of_strings<block_start><if_stmt>substring<in>string<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef find_substring (list_of_strings, substring):\n    for string in list_of_strings:\n        if substring in string:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/92", "origin_solution": "<def_stmt>is_undulating n<block_start>n_str=str(n)<line_sep><return>n_str[0]<eq>n_str[-1]<and>n_str[0]<eq>n_str[1]<block_end>\n", "solution": "\ndef is_undulating (n):\n    n_str=str(n)\n    return n_str[0]==n_str[-1] and n_str[0]==n_str[1]\n    \n\n"}
{"task_id": "Mbpp/93", "origin_solution": "<def_stmt>power a b<block_start>result=1<for_stmt>_ range(b)<block_start>result<augmul>a<block_end><return>result<block_end>\n", "solution": "\ndef power (a, b):\n    result=1\n    for _ in range(b):\n        result*=a\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/94", "origin_solution": "<def_stmt>index_minimum lst<block_start><return>min(lst key=<lambda>x:x[1])[0]<block_end>\n", "solution": "\ndef index_minimum (lst):\n    return min(lst, key=lambda x:x[1])[0]\n    \n\n"}
{"task_id": "Mbpp/95", "origin_solution": "<def_stmt>Find_Min_Length list_of_lists<block_start>min_length=float('inf')<for_stmt>sublist list_of_lists<block_start><if_stmt>len(sublist)<l>min_length<block_start>min_length=len(sublist)<block_end><block_end><return>min_length<block_end>\n", "solution": "\ndef Find_Min_Length (list_of_lists):\n    min_length=float('inf')\n    for sublist in list_of_lists:\n        if len(sublist)<min_length:\n            min_length=len(sublist)\n            \n    \n    return min_length\n    \n\n"}
{"task_id": "Mbpp/96", "origin_solution": "<def_stmt>divisor n<block_start>count=0<for_stmt>i range(1 n+1)<block_start><if_stmt>n%i<eq>0<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef divisor (n):\n    count=0\n    for i in range(1, n+1):\n        if n%i==0:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/97", "origin_solution": "<def_stmt>frequency_lists list_of_lists<block_start>flattened_list=[item<for>sublist list_of_lists<for>item sublist]<line_sep>frequency_dict={}<for_stmt>item flattened_list<block_start><if_stmt>item<in>frequency_dict<block_start>frequency_dict[item]<augadd>1<block_end><else_stmt><block_start>frequency_dict[item]=1<block_end><block_end><return>frequency_dict<block_end>\n", "solution": "\ndef frequency_lists (list_of_lists):\n    flattened_list=[item for sublist in list_of_lists for item in sublist]\n    frequency_dict={}\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item]+=1\n            \n        \n        else :\n            frequency_dict[item]=1\n            \n    \n    return frequency_dict\n    \n\n"}
{"task_id": "Mbpp/98", "origin_solution": "<import_stmt>math<def_stmt>multiply_num lst<block_start><return>math.prod(lst)/len(lst)<block_end>\n", "solution": "\nimport math\ndef multiply_num (lst):\n    return math.prod(lst)/len(lst)\n    \n\n"}
{"task_id": "Mbpp/99", "origin_solution": "<def_stmt>decimal_to_binary decimal<block_start>binary=bin(decimal)[2:]<line_sep><return>binary<block_end>\n", "solution": "\ndef decimal_to_binary (decimal):\n    binary=bin(decimal)[2:]\n    return binary\n    \n\n"}
{"task_id": "Mbpp/100", "origin_solution": "<def_stmt>next_smallest_palindrome n<block_start>n<augadd>1<while_stmt><not>is_palindrome(n)<block_start>n<augadd>1<block_end><return>n<block_end><def_stmt>is_palindrome n<block_start><return>str(n)<eq>str(n)[::-1]<block_end>\n", "solution": "\ndef next_smallest_palindrome (n):\n    n+=1\n    while  not is_palindrome(n):\n        n+=1\n        \n    return n\n    \ndef is_palindrome (n):\n    return str(n)==str(n)[::-1]\n    \n\n"}
{"task_id": "Mbpp/101", "origin_solution": "<def_stmt>kth_element arr k<block_start><return>arr[k-1]<block_end>\n", "solution": "\ndef kth_element (arr, k):\n    return arr[k-1]\n    \n\n"}
{"task_id": "Mbpp/102", "origin_solution": "<def_stmt>snake_to_camel snake_str<block_start>components=snake_str.split('_')<line_sep><return>''.join(x.title()<for>x components)<block_end>print(snake_to_camel('python_program'))<line_sep>print(snake_to_camel('python_language'))<line_sep>print(snake_to_camel('programming_language'))<line_sep>\n", "solution": "\ndef snake_to_camel (snake_str):\n    components=snake_str.split('_')\n    return ''.join(x.title() for x in components)\n    \nprint(snake_to_camel('python_program'))\nprint(snake_to_camel('python_language'))\nprint(snake_to_camel('programming_language'))\n\n"}
{"task_id": "Mbpp/103", "origin_solution": "<def_stmt>eulerian_num n m<block_start><if_stmt>n<eq>m<block_start><return>n<times>(n+1)<floordiv>2<block_end><elif_stmt>n<g>m<block_start>n,m=m n<block_end><return>eulerian_num(n-1 m-1)+eulerian_num(n m-1)<block_end>\n", "solution": "\ndef eulerian_num (n, m):\n    if n==m:\n        return n*(n+1)//2\n        \n    \n    elif n>m:\n        n,m=m, n\n        \n    return eulerian_num(n-1, m-1)+eulerian_num(n, m-1)\n    \n\n"}
{"task_id": "Mbpp/104", "origin_solution": "<def_stmt>sort_sublists list_of_lists<block_start><return>[sorted(sublist)<for>sublist list_of_lists]<block_end>\n", "solution": "\ndef sort_sublists (list_of_lists):\n    return [sorted(sublist) for sublist in list_of_lists]\n    \n\n"}
{"task_id": "Mbpp/105", "origin_solution": "<def_stmt>count lst<block_start><return>sum(map(bool lst))<block_end>\n", "solution": "\ndef count (lst):\n    return sum(map(bool, lst))\n    \n\n"}
{"task_id": "Mbpp/106", "origin_solution": "<def_stmt>add_lists list1 tuple1<block_start><return>tuple1+tuple(list1)<block_end>\n", "solution": "\ndef add_lists (list1, tuple1):\n    return tuple1+tuple(list1)\n    \n\n"}
{"task_id": "Mbpp/108", "origin_solution": "<def_stmt>merge_sorted_list list1 list2 list3<block_start>merged_list=[]<while_stmt>list1<or>list2<or>list3<block_start><if_stmt>list1<and>min(list1)<le>min(list2 list3)<block_start>merged_list.append(min(list1))<line_sep>list1.remove(min(list1))<block_end><elif_stmt>list2<and>min(list2)<le>min(list1 list3)<block_start>merged_list.append(min(list2))<line_sep>list2.remove(min(list2))<block_end><else_stmt><block_start>merged_list.append(min(list3))<line_sep>list3.remove(min(list3))<block_end><block_end><return>merged_list<block_end>\n", "solution": "\ndef merge_sorted_list (list1, list2, list3):\n    merged_list=[]\n    while list1 or list2 or list3:\n        if list1 and min(list1)<=min(list2, list3):\n            merged_list.append(min(list1))\n            list1.remove(min(list1))\n            \n        \n        elif list2 and min(list2)<=min(list1, list3):\n            merged_list.append(min(list2))\n            list2.remove(min(list2))\n            \n        \n        else :\n            merged_list.append(min(list3))\n            list3.remove(min(list3))\n            \n    \n    return merged_list\n    \n\n"}
{"task_id": "Mbpp/109", "origin_solution": "<def_stmt>odd_Equivalent s k<block_start>binary_string=list(s)<for_stmt>_ range(k)<block_start>binary_string.insert(0 binary_string.pop())<block_end>count=0<for_stmt>bit binary_string<block_start><if_stmt>bit%2<eq>1<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef odd_Equivalent (s, k):\n    binary_string=list(s)\n    for _ in range(k):\n        binary_string.insert(0, binary_string.pop())\n        \n    count=0\n    for bit in binary_string:\n        if bit%2==1:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/111", "origin_solution": "<def_stmt>common_in_nested_lists nested_lists<block_start>common_elements=set(nested_lists[0])<for_stmt>sublist nested_lists[1:]<block_start>common_elements.intersection_update(sublist)<block_end><return>common_elements<block_end>\n", "solution": "\ndef common_in_nested_lists (nested_lists):\n    common_elements=set(nested_lists[0])\n    for sublist in nested_lists[1:]:\n        common_elements.intersection_update(sublist)\n        \n    return common_elements\n    \n\n"}
{"task_id": "Mbpp/113", "origin_solution": "<def_stmt>check_integer s<block_start><try_stmt><block_start>int(s)<line_sep><return><true><block_end><except_stmt>ValueError<block_start><return><false><block_end><block_end>\n", "solution": "\ndef check_integer (s):\n    try:\n        int(s)\n        return  True \n        \n    \n    except ValueError:\n        return  False \n        \n\n\n"}
{"task_id": "Mbpp/116", "origin_solution": "<def_stmt>tuple_to_int t<block_start><return>int(''.join(map(str t)))<block_end>\n", "solution": "\ndef tuple_to_int (t):\n    return int(''.join(map(str, t)))\n    \n\n"}
{"task_id": "Mbpp/118", "origin_solution": "<def_stmt>string_to_list s<block_start><return>s.split()<block_end>\n", "solution": "\ndef string_to_list (s):\n    return s.split()\n    \n\n"}
{"task_id": "Mbpp/119", "origin_solution": "<def_stmt>search nums<block_start>left,right=0 len(nums)-1<while_stmt>left<l>right<block_start>mid=(left+right)<floordiv>2<if_stmt>nums[mid]<eq>nums[mid^1]<block_start>left=mid+1<block_end><else_stmt><block_start>right=mid<block_end><block_end><return>nums[left]<block_end>\n", "solution": "\ndef search (nums):\n    left,right=0, len(nums)-1\n    while left<right:\n        mid=(left+right)//2\n        if nums[mid]==nums[mid^1]:\n            left=mid+1\n            \n        \n        else :\n            right=mid\n            \n    \n    return nums[left]\n    \n\n"}
{"task_id": "Mbpp/120", "origin_solution": "<def_stmt>max_product_tuple tuples<block_start>max_product=0<for_stmt>t tuples<block_start>product=t[0]<times>t[1]<if_stmt>product<g>max_product<block_start>max_product=product<block_end><block_end><return>max_product<block_end>\n", "solution": "\ndef max_product_tuple (tuples):\n    max_product=0\n    for t in tuples:\n        product=t[0]*t[1]\n        if product>max_product:\n            max_product=product\n            \n    \n    return max_product\n    \n\n"}
{"task_id": "Mbpp/123", "origin_solution": "<def_stmt>sum_of_divisors n<block_start>result=1<line_sep>i=2<while_stmt>i<times>i<le>n<block_start><if_stmt>(n%i<eq>0)<block_start><if_stmt>(n<floordiv>i<eq>i)<block_start>result=result+i<block_end><else_stmt><block_start>result=result+(i+n<floordiv>i)<block_end><block_end>i<augadd>1<block_end><return>result<block_end><def_stmt>amicable_numbers_sum n<block_start>sum1=0<for_stmt>i range(1 n+1)<block_start>sum2=sum_of_divisors(i)<if_stmt>(sum2<ne>i<and>sum_of_divisors(sum2)<eq>i)<block_start>sum1<augadd>i<block_end><block_end><return>sum1<block_end>\n", "solution": "\ndef sum_of_divisors (n):\n    result=1\n    i=2\n    while i*i<=n:\n        if (n%i==0):\n            if (n//i==i):\n                result=result+i\n                \n            \n            else :\n                result=result+(i+n//i)\n                \n        \n        i+=1\n        \n    return result\n    \ndef amicable_numbers_sum (n):\n    sum1=0\n    for i in range(1, n+1):\n        sum2=sum_of_divisors(i)\n        if (sum2!=i and sum_of_divisors(sum2)==i):\n            sum1+=i\n            \n    \n    return sum1\n    \n\n"}
{"task_id": "Mbpp/124", "origin_solution": "<import_stmt>math<def_stmt>angle_complex real imag<block_start><return>math.atan2(imag real)<block_end>\n", "solution": "\nimport math\ndef angle_complex (real, imag):\n    return math.atan2(imag, real)\n    \n\n"}
{"task_id": "Mbpp/125", "origin_solution": "<def_stmt>find_length binary_string<block_start>max_diff=0<line_sep>count=0<for_stmt>char binary_string<block_start><if_stmt>char<eq>'0'<block_start>count<augsub>1<block_end><else_stmt><block_start>count<augadd>1<block_end>max_diff=max(max_diff count)<block_end><return>max_diff<block_end>\n", "solution": "\ndef find_length (binary_string):\n    max_diff=0\n    count=0\n    for char in binary_string:\n        if char=='0':\n            count-=1\n            \n        \n        else :\n            count+=1\n            \n        max_diff=max(max_diff, count)\n        \n    return max_diff\n    \n\n"}
{"task_id": "Mbpp/126", "origin_solution": "<def_stmt>sum_of_common_divisors a b<block_start><def_stmt>gcd x y<block_start><while_stmt>(y)<block_start>x,y=y x%y<block_end><return>x<block_end><return>a<times>b<floordiv>gcd(a b)<block_end>\n", "solution": "\ndef sum_of_common_divisors (a, b):\n    def gcd (x, y):\n        while (y):\n            x,y=y, x%y\n            \n        return x\n        \n    return a*b//gcd(a, b)\n    \n\n"}
{"task_id": "Mbpp/127", "origin_solution": "<def_stmt>multiply_int a b<block_start><return>a<times>b<block_end>\n", "solution": "\ndef multiply_int (a, b):\n    return a*b\n    \n\n"}
{"task_id": "Mbpp/128", "origin_solution": "<def_stmt>long_words n text<block_start>words=text.split()<line_sep><return>[word<for>word words<if>len(word)<g>n]<block_end>\n", "solution": "\ndef long_words (n, text):\n    words=text.split()\n    return [word for word in words if len(word)>n]\n    \n\n"}
{"task_id": "Mbpp/129", "origin_solution": "<def_stmt>magic_square_test matrix<block_start>n=len(matrix)<line_sep>magic_constant=n<times>(n<power>2+1)<floordiv>2<for_stmt>i range(n)<block_start><if_stmt>sum(matrix[i])<ne>magic_constant<or>sum([row[i]<for>row matrix])<ne>magic_constant<block_start><return><false><block_end><block_end><if_stmt>sum([matrix[i][i]<for>i range(n)])<ne>magic_constant<or>sum([matrix[i][n-i-1]<for>i range(n)])<ne>magic_constant<block_start><return><false><block_end><return><true><block_end>\n", "solution": "\ndef magic_square_test (matrix):\n    n=len(matrix)\n    magic_constant=n*(n**2+1)//2\n    for i in range(n):\n        if sum(matrix[i])!=magic_constant or sum([row[i] for row in matrix])!=magic_constant:\n            return  False \n            \n    \n    if sum([matrix[i][i] for i in range(n)])!=magic_constant or sum([matrix[i][n-i-1] for i in range(n)])!=magic_constant:\n        return  False \n        \n    return  True \n    \n\n"}
{"task_id": "Mbpp/130", "origin_solution": "<def_stmt>max_occurrences lst<block_start>count_dict={}<for_stmt>item lst<block_start><if_stmt>item<in>count_dict<block_start>count_dict[item]<augadd>1<block_end><else_stmt><block_start>count_dict[item]=1<block_end><block_end>max_item=max(count_dict key=count_dict.get)<line_sep><return>max_item<block_end>\n", "solution": "\ndef max_occurrences (lst):\n    count_dict={}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item]+=1\n            \n        \n        else :\n            count_dict[item]=1\n            \n    \n    max_item=max(count_dict, key=count_dict.get)\n    return max_item\n    \n\n"}
{"task_id": "Mbpp/131", "origin_solution": "<def_stmt>reverse_vowels s<block_start>vowels=set(\"aeiouAEIOU\")<line_sep>s=list(s)<line_sep>i,j=0 len(s)-1<while_stmt>i<l>j<block_start><if_stmt>s[i]<not><in>vowels<block_start>i<augadd>1<block_end><elif_stmt>s[j]<not><in>vowels<block_start>j<augsub>1<block_end><else_stmt><block_start>s[i],s[j]=s[j] s[i]<line_sep>i<augadd>1<line_sep>j<augsub>1<block_end><block_end><return>\"\".join(s)<block_end>\n", "solution": "\ndef reverse_vowels (s):\n    vowels=set(\"aeiouAEIOU\")\n    s=list(s)\n    i,j=0, len(s)-1\n    while i<j:\n        if s[i] not  in vowels:\n            i+=1\n            \n        \n        elif s[j] not  in vowels:\n            j-=1\n            \n        \n        else :\n            s[i],s[j]=s[j], s[i]\n            i+=1\n            j-=1\n            \n    \n    return \"\".join(s)\n    \n\n"}
{"task_id": "Mbpp/132", "origin_solution": "<def_stmt>tup_string tup<block_start><return>''.join(tup)<block_end>\n", "solution": "\ndef tup_string (tup):\n    return ''.join(tup)\n    \n\n"}
{"task_id": "Mbpp/133", "origin_solution": "<def_stmt>sum_negativenum nums<block_start><return>sum(num<for>num nums<if>num<l>0)<block_end>\n", "solution": "\ndef sum_negativenum (nums):\n    return sum(num for num in nums if num<0)\n    \n\n"}
{"task_id": "Mbpp/135", "origin_solution": "<def_stmt>hexagonal_num n<block_start><return>n<times>(2<times>n-1)<block_end>\n", "solution": "\ndef hexagonal_num (n):\n    return n*(2*n-1)\n    \n\n"}
{"task_id": "Mbpp/137", "origin_solution": "<def_stmt>zero_count arr<block_start>zero_count=0<for_stmt>num arr<block_start><if_stmt>num<eq>0<block_start>zero_count<augadd>1<block_end><block_end><return>zero_count/len(arr)<block_end>\n", "solution": "\ndef zero_count (arr):\n    zero_count=0\n    for num in arr:\n        if num==0:\n            zero_count+=1\n            \n    \n    return zero_count/len(arr)\n    \n\n"}
{"task_id": "Mbpp/138", "origin_solution": "<def_stmt>is_Sum_Of_Powers_Of_Two n<block_start>binary_representation=bin(n)[2:]<for_stmt>bit binary_representation<block_start><if_stmt>bit<ne>'0'<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef is_Sum_Of_Powers_Of_Two (n):\n    binary_representation=bin(n)[2:]\n    for bit in binary_representation:\n        if bit!='0':\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/139", "origin_solution": "<import_stmt>math<def_stmt>circle_circumference radius<block_start><return>2<times>math.pi<times>radius<block_end>\n", "solution": "\nimport math\ndef circle_circumference (radius):\n    return 2*math.pi*radius\n    \n\n"}
{"task_id": "Mbpp/140", "origin_solution": "<def_stmt>extract_singly list_of_tuples<block_start>flattened_list=[item<for>sublist list_of_tuples<for>item sublist]<line_sep><return>set(flattened_list)<block_end>\n", "solution": "\ndef extract_singly (list_of_tuples):\n    flattened_list=[item for sublist in list_of_tuples for item in sublist]\n    return set(flattened_list)\n    \n\n"}
{"task_id": "Mbpp/141", "origin_solution": "<def_stmt>pancake_sort lst<block_start><def_stmt>flip lst i<block_start>lst[:i+1]=lst[:i+1][::-1]<block_end><def_stmt>find_max lst n<block_start>max_index=0<for_stmt>i range(1 n)<block_start><if_stmt>lst[i]<g>lst[max_index]<block_start>max_index=i<block_end><block_end><return>max_index<block_end>n=len(lst)<for_stmt>i range(n 1 -1)<block_start>max_index=find_max(lst i)<if_stmt>max_index<ne>i-1<block_start>flip(lst max_index)<line_sep>flip(lst i)<block_end><block_end><return>lst<block_end>\n", "solution": "\ndef pancake_sort (lst):\n    def flip (lst, i):\n        lst[:i+1]=lst[:i+1][::-1]\n        \n    def find_max (lst, n):\n        max_index=0\n        for i in range(1, n):\n            if lst[i]>lst[max_index]:\n                max_index=i\n                \n        \n        return max_index\n        \n    n=len(lst)\n    for i in range(n, 1, -1):\n        max_index=find_max(lst, i)\n        if max_index!=i-1:\n            flip(lst, max_index)\n            flip(lst, i)\n            \n    \n    return lst\n    \n\n"}
{"task_id": "Mbpp/142", "origin_solution": "<def_stmt>count_samepair list1 list2 list3<block_start>count=0<for_stmt>i range(len(list1))<block_start><if_stmt>list1[i]<eq>list2[i]<eq>list3[i]<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_samepair (list1, list2, list3):\n    count=0\n    for i in range(len(list1)):\n        if list1[i]==list2[i]==list3[i]:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/145", "origin_solution": "<def_stmt>max_Abs_Diff arr<block_start>max_val=max(arr)<line_sep>min_val=min(arr)<line_sep><return>abs(max_val-min_val)<block_end>\n", "solution": "\ndef max_Abs_Diff (arr):\n    max_val=max(arr)\n    min_val=min(arr)\n    return abs(max_val-min_val)\n    \n\n"}
{"task_id": "Mbpp/160", "origin_solution": "<def_stmt>find_solution a b n<block_start><for_stmt>x range(n<floordiv>a+1)<block_start>y=(n-a<times>x)<floordiv>b<if_stmt>y<ge>0<and>x+y<times>a<eq>n<block_start><return>(x y)<block_end><block_end><return><none><block_end>\n", "solution": "\ndef find_solution (a, b, n):\n    for x in range(n//a+1):\n        y=(n-a*x)//b\n        if y>=0 and x+y*a==n:\n            return (x, y)\n            \n    \n    return  None \n    \n\n"}
{"task_id": "Mbpp/161", "origin_solution": "<def_stmt>remove_elements lst remove_lst<block_start><return>[x<for>x lst<if>x<not><in>remove_lst]<block_end>\n", "solution": "\ndef remove_elements (lst, remove_lst):\n    return [x for x in lst if x not  in remove_lst]\n    \n\n"}
{"task_id": "Mbpp/162", "origin_solution": "<def_stmt>sum_series n<block_start>sum=0<for_stmt>i range(n<floordiv>2+1)<block_start>sum<augadd>n-2<times>i<block_end><return>sum<block_end>print(sum_series(6))<line_sep>print(sum_series(10))<line_sep>print(sum_series(9))<line_sep>print(sum_series(0))<line_sep>\n", "solution": "\ndef sum_series (n):\n    sum=0\n    for i in range(n//2+1):\n        sum+=n-2*i\n        \n    return sum\n    \nprint(sum_series(6))\nprint(sum_series(10))\nprint(sum_series(9))\nprint(sum_series(0))\n\n"}
{"task_id": "Mbpp/165", "origin_solution": "<def_stmt>count_char_position s<block_start>count=0<for_stmt>i range(len(s))<block_start><if_stmt>s[i].lower()<eq>chr(ord('a')+i)<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_char_position (s):\n    count=0\n    for i in range(len(s)):\n        if s[i].lower()==chr(ord('a')+i):\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/166", "origin_solution": "<def_stmt>find_even_pair nums<block_start>count=0<for_stmt>i range(len(nums))<block_start><for_stmt>j range(i+1 len(nums))<block_start><if_stmt>(nums[i]^nums[j])%2<eq>0<block_start>count<augadd>1<block_end><block_end><block_end><return>count<block_end>\n", "solution": "\ndef find_even_pair (nums):\n    count=0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i]^nums[j])%2==0:\n                count+=1\n                \n        \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/167", "origin_solution": "<def_stmt>next_power_of_2 n<block_start><if_stmt>n<eq>0<block_start><return>1<block_end><elif_stmt>n&(n-1)<eq>0<block_start><return>n<block_end><else_stmt><block_start><return>1<lshift>(n-1).bit_length()<block_end><block_end>\n", "solution": "\ndef next_power_of_2 (n):\n    if n==0:\n        return 1\n        \n    \n    elif n&(n-1)==0:\n        return n\n        \n    \n    else :\n        return 1<<(n-1).bit_length()\n        \n\n\n"}
{"task_id": "Mbpp/168", "origin_solution": "<def_stmt>frequency lst num<block_start><return>lst.count(num)<block_end>\n", "solution": "\ndef frequency (lst, num):\n    return lst.count(num)\n    \n\n"}
{"task_id": "Mbpp/170", "origin_solution": "<def_stmt>sum_range_list lst start end<block_start><return>sum(lst[start:end+1])<block_end>\n", "solution": "\ndef sum_range_list (lst, start, end):\n    return sum(lst[start:end+1])\n    \n\n"}
{"task_id": "Mbpp/171", "origin_solution": "<def_stmt>perimeter_pentagon n<block_start><return>n<times>5<block_end>\n", "solution": "\ndef perimeter_pentagon (n):\n    return n*5\n    \n\n"}
{"task_id": "Mbpp/172", "origin_solution": "<def_stmt>count_occurance s<block_start><return>s.count('std')<block_end>\n", "solution": "\ndef count_occurance (s):\n    return s.count('std')\n    \n\n"}
{"task_id": "Mbpp/222", "origin_solution": "<def_stmt>check_type t<block_start><if_stmt><not>t<block_start><return><true><block_end>first_type=type(t[0])<for_stmt>element t<block_start><if_stmt>type(element)<ne>first_type<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef check_type (t):\n    if  not t:\n        return  True \n        \n    first_type=type(t[0])\n    for element in t:\n        if type(element)!=first_type:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/223", "origin_solution": "<def_stmt>is_majority arr n element<block_start>count=0<for_stmt>i range(n)<block_start><if_stmt>arr[i]<eq>element<block_start>count<augadd>1<block_end><block_end><return>count<g>n<floordiv>2<block_end>\n", "solution": "\ndef is_majority (arr, n, element):\n    count=0\n    for i in range(n):\n        if arr[i]==element:\n            count+=1\n            \n    \n    return count>n//2\n    \n\n"}
{"task_id": "Mbpp/224", "origin_solution": "<def_stmt>count_Set_Bits n<block_start>count=0<while_stmt>n<block_start>count<augadd>n&1<line_sep>n<augrshift>1<block_end><return>count<block_end>\n", "solution": "\ndef count_Set_Bits (n):\n    count=0\n    while n:\n        count+=n&1\n        n>>=1\n        \n    return count\n    \n\n"}
{"task_id": "Mbpp/226", "origin_solution": "<def_stmt>odd_values_string s<block_start><return>s[::2]<block_end>\n", "solution": "\ndef odd_values_string (s):\n    return s[::2]\n    \n\n"}
{"task_id": "Mbpp/227", "origin_solution": "<def_stmt>min_of_three a b c<block_start><return>min(a b c)<block_end>\n", "solution": "\ndef min_of_three (a, b, c):\n    return min(a, b, c)\n    \n\n"}
{"task_id": "Mbpp/230", "origin_solution": "<def_stmt>replace_blank string char<block_start><return>string.replace(\" \" char)<block_end>\n", "solution": "\ndef replace_blank (string, char):\n    return string.replace(\" \", char)\n    \n\n"}
{"task_id": "Mbpp/232", "origin_solution": "<def_stmt>larg_nnum lst n<block_start><return>sorted(lst reverse=<true>)[:n]<block_end>\n", "solution": "\ndef larg_nnum (lst, n):\n    return sorted(lst, reverse= True )[:n]\n    \n\n"}
{"task_id": "Mbpp/233", "origin_solution": "<import_stmt>math<def_stmt>lateralsuface_cylinder radius height<block_start>lateral_surface_area=2<times>math.pi<times>radius<times>(radius+height)<line_sep><return>lateral_surface_area<block_end>\n", "solution": "\nimport math\ndef lateralsuface_cylinder (radius, height):\n    lateral_surface_area=2*math.pi*radius*(radius+height)\n    return lateral_surface_area\n    \n\n"}
{"task_id": "Mbpp/234", "origin_solution": "<def_stmt>volume_cube side_length<block_start><return>side_length<power>3<block_end>\n", "solution": "\ndef volume_cube (side_length):\n    return side_length**3\n    \n\n"}
{"task_id": "Mbpp/235", "origin_solution": "<def_stmt>even_bit_set_number n<block_start><return>n|0xAAAAAAAA<block_end>\n", "solution": "\ndef even_bit_set_number (n):\n    return n|0xAAAAAAAA\n    \n\n"}
{"task_id": "Mbpp/237", "origin_solution": "<def_stmt>check_occurences lst<block_start>result={}<for_stmt>tup lst<block_start><if_stmt>tup<in>result<block_start>result[tup]<augadd>1<block_end><else_stmt><block_start>result[tup]=1<block_end><block_end><return>result<block_end>\n", "solution": "\ndef check_occurences (lst):\n    result={}\n    for tup in lst:\n        if tup in result:\n            result[tup]+=1\n            \n        \n        else :\n            result[tup]=1\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/238", "origin_solution": "<def_stmt>number_of_substrings s<block_start>n=len(s)<line_sep><return>n<times>(n+1)<floordiv>2<block_end>\n", "solution": "\ndef number_of_substrings (s):\n    n=len(s)\n    return n*(n+1)//2\n    \n\n"}
{"task_id": "Mbpp/239", "origin_solution": "<def_stmt>get_total_number_of_sequences m n<block_start><if_stmt>n<eq>1<block_start><return>m<block_end><else_stmt><block_start><return>sum([m-2<times>i<for>i range(1 m)])<block_end><block_end>\n", "solution": "\ndef get_total_number_of_sequences (m, n):\n    if n==1:\n        return m\n        \n    \n    else :\n        return sum([m-2*i for i in range(1, m)])\n        \n\n\n"}
{"task_id": "Mbpp/240", "origin_solution": "<def_stmt>replace_list list1 list2<block_start>list1[-1]=list2<line_sep><return>list1<block_end>\n", "solution": "\ndef replace_list (list1, list2):\n    list1[-1]=list2\n    return list1\n    \n\n"}
{"task_id": "Mbpp/242", "origin_solution": "<def_stmt>count_charac string<block_start>count=0<for_stmt>char string<block_start>count<augadd>1<block_end><return>count<block_end>\n", "solution": "\ndef count_charac (string):\n    count=0\n    for char in string:\n        count+=1\n        \n    return count\n    \n\n"}
{"task_id": "Mbpp/244", "origin_solution": "<import_stmt>math<def_stmt>next_Perfect_Square n<block_start>next_square=math.ceil(math.sqrt(n))<line_sep><return>next_square<power>2<block_end>\n", "solution": "\nimport math\ndef next_Perfect_Square (n):\n    next_square=math.ceil(math.sqrt(n))\n    return next_square**2\n    \n\n"}
{"task_id": "Mbpp/245", "origin_solution": "<def_stmt>max_sum arr<block_start>n=len(arr)<line_sep>inc=[0]<times>n<line_sep>dec=[0]<times>n<line_sep>inc[0]=arr[0]<line_sep>dec[n-1]=arr[n-1]<for_stmt>i range(1 n)<block_start>inc[i]=max(inc[i-1]+arr[i] arr[i])<block_end><for_stmt>i range(n-2 -1 -1)<block_start>dec[i]=max(dec[i+1]+arr[i] arr[i])<block_end>max_sum=0<for_stmt>i range(n)<block_start>max_sum<augadd>max(inc[i] dec[i])<block_end><return>max_sum<block_end>\n", "solution": "\ndef max_sum (arr):\n    n=len(arr)\n    inc=[0]*n\n    dec=[0]*n\n    inc[0]=arr[0]\n    dec[n-1]=arr[n-1]\n    for i in range(1, n):\n        inc[i]=max(inc[i-1]+arr[i], arr[i])\n        \n    for i in range(n-2, -1, -1):\n        dec[i]=max(dec[i+1]+arr[i], arr[i])\n        \n    max_sum=0\n    for i in range(n):\n        max_sum+=max(inc[i], dec[i])\n        \n    return max_sum\n    \n\n"}
{"task_id": "Mbpp/247", "origin_solution": "<def_stmt>lps s<block_start>n=len(s)<line_sep>L=[[0<for>x range(n)]<for>x range(n)]<for_stmt>i range(n)<block_start>L[i][i]=1<block_end><for_stmt>cl range(2 n+1)<block_start><for_stmt>i range(n-cl+1)<block_start>j=i+cl-1<if_stmt>s[i]<eq>s[j]<and>cl<eq>2<block_start>L[i][j]=2<block_end><elif_stmt>s[i]<eq>s[j]<block_start>L[i][j]=L[i+1][j-1]+2<block_end><else_stmt><block_start>L[i][j]=max(L[i][j-1] L[i+1][j])<block_end><block_end><block_end><return>L[0][n-1]<block_end>\n", "solution": "\ndef lps (s):\n    n=len(s)\n    L=[[0 for x in range(n)] for x in range(n)]\n    for i in range(n):\n        L[i][i]=1\n        \n    for cl in range(2, n+1):\n        for i in range(n-cl+1):\n            j=i+cl-1\n            if s[i]==s[j] and cl==2:\n                L[i][j]=2\n                \n            \n            elif s[i]==s[j]:\n                L[i][j]=L[i+1][j-1]+2\n                \n            \n            else :\n                L[i][j]=max(L[i][j-1], L[i+1][j])\n                \n        \n    \n    return L[0][n-1]\n    \n\n"}
{"task_id": "Mbpp/250", "origin_solution": "<def_stmt>count_X tup element<block_start>count=0<for_stmt>i tup<block_start><if_stmt>i<eq>element<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_X (tup, element):\n    count=0\n    for i in tup:\n        if i==element:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/251", "origin_solution": "<def_stmt>insert_element lst element<block_start>result=[]<for_stmt>item lst<block_start>result.append(element)<line_sep>result.append(item)<block_end><return>result<block_end>\n", "solution": "\ndef insert_element (lst, element):\n    result=[]\n    for item in lst:\n        result.append(element)\n        result.append(item)\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/252", "origin_solution": "<import_stmt>cmath<def_stmt>convert num<block_start><return>cmath.polar(num)<block_end>\n", "solution": "\nimport cmath\ndef convert (num):\n    return cmath.polar(num)\n    \n\n"}
{"task_id": "Mbpp/253", "origin_solution": "<def_stmt>count_integer lst<block_start>count=0<for_stmt>i lst<block_start><if_stmt>type(i)<eq>int<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_integer (lst):\n    count=0\n    for i in lst:\n        if type(i)==int:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/255", "origin_solution": "<import_from_stmt>itertools combinations_with_replacement<def_stmt>combinations_colors lst n<block_start><return>[tuple(combination)<for>combination combinations_with_replacement(lst n)]<block_end>\n", "solution": "\nfrom itertools import combinations_with_replacement\ndef combinations_colors (lst, n):\n    return [tuple(combination) for combination in combinations_with_replacement(lst, n)]\n    \n\n"}
{"task_id": "Mbpp/256", "origin_solution": "<def_stmt>is_prime n<block_start><if_stmt>n<le>1<block_start><return><false><block_end><if_stmt>n<le>3<block_start><return><true><block_end><if_stmt>n%2<eq>0<or>n%3<eq>0<block_start><return><false><block_end>i=5<while_stmt>i<times>i<le>n<block_start><if_stmt>n%i<eq>0<or>n%(i+2)<eq>0<block_start><return><false><block_end>i<augadd>6<block_end><return><true><block_end><def_stmt>count_Primes_nums n<block_start>count=0<for_stmt>i range(2 n)<block_start><if_stmt>is_prime(i)<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef is_prime (n):\n    if n<=1:\n        return  False \n        \n    if n<=3:\n        return  True \n        \n    if n%2==0 or n%3==0:\n        return  False \n        \n    i=5\n    while i*i<=n:\n        if n%i==0 or n%(i+2)==0:\n            return  False \n            \n        i+=6\n        \n    return  True \n    \ndef count_Primes_nums (n):\n    count=0\n    for i in range(2, n):\n        if is_prime(i):\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/257", "origin_solution": "<def_stmt>swap_numbers a b<block_start><return>(b a)<block_end>\n", "solution": "\ndef swap_numbers (a, b):\n    return (b, a)\n    \n\n"}
{"task_id": "Mbpp/259", "origin_solution": "<def_stmt>maximize_elements tuple_list<block_start><return>sorted(tuple_list key=<lambda>x:x[0] reverse=<true>)+sorted(tuple_list key=<lambda>x:x[1] reverse=<true>)<block_end>\n", "solution": "\ndef maximize_elements (tuple_list):\n    return sorted(tuple_list, key=lambda x:x[0], reverse= True )+sorted(tuple_list, key=lambda x:x[1], reverse= True )\n    \n\n"}
{"task_id": "Mbpp/260", "origin_solution": "<def_stmt>newman_prime n<block_start><if_stmt>n<eq>1<block_start><return>1<block_end><elif_stmt>n<eq>2<block_start><return>4<block_end><else_stmt><block_start><return>4<times>(2<times>n-1)<block_end><block_end>print(newman_prime(3))<line_sep>print(newman_prime(4))<line_sep>print(newman_prime(5))<line_sep>\n", "solution": "\ndef newman_prime (n):\n    if n==1:\n        return 1\n        \n    \n    elif n==2:\n        return 4\n        \n    \n    else :\n        return 4*(2*n-1)\n        \n\nprint(newman_prime(3))\nprint(newman_prime(4))\nprint(newman_prime(5))\n\n"}
{"task_id": "Mbpp/261", "origin_solution": "<def_stmt>division_elements tuple1 tuple2<block_start><return>tuple(element1/element2<for>element1,element2 zip(tuple1 tuple2))<block_end>\n", "solution": "\ndef division_elements (tuple1, tuple2):\n    return tuple(element1/element2 for element1,element2 in zip(tuple1, tuple2))\n    \n\n"}
{"task_id": "Mbpp/262", "origin_solution": "<def_stmt>split_two_parts lst L<block_start><return>(lst[:L] lst[L:])<block_end>\n", "solution": "\ndef split_two_parts (lst, L):\n    return (lst[:L], lst[L:])\n    \n\n"}
{"task_id": "Mbpp/264", "origin_solution": "<def_stmt>dog_age dog_years<block_start>dog_years_in_dog_years=dog_years<times>10<line_sep>dog_years_in_human_years=dog_years_in_dog_years/12<line_sep><return>dog_years_in_human_years<block_end>\n", "solution": "\ndef dog_age (dog_years):\n    dog_years_in_dog_years=dog_years*10\n    dog_years_in_human_years=dog_years_in_dog_years/12\n    return dog_years_in_human_years\n    \n\n"}
{"task_id": "Mbpp/265", "origin_solution": "<def_stmt>list_split lst n<block_start>result=[]<for_stmt>i range(0 len(lst) n)<block_start>result.append(lst[i:i+n])<block_end><return>result<block_end>\n", "solution": "\ndef list_split (lst, n):\n    result=[]\n    for i in range(0, len(lst), n):\n        result.append(lst[i:i+n])\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/266", "origin_solution": "<def_stmt>lateralsurface_cube side_length<block_start>lateral_surface_area=6<times>side_length<power>2<line_sep><return>lateral_surface_area<block_end>\n", "solution": "\ndef lateralsurface_cube (side_length):\n    lateral_surface_area=6*side_length**2\n    return lateral_surface_area\n    \n\n"}
{"task_id": "Mbpp/267", "origin_solution": "<def_stmt>square_Sum n<block_start>sum=0<for_stmt>i range(1 2<times>n 2)<block_start>sum<augadd>i<power>2<block_end><return>sum<block_end>\n", "solution": "\ndef square_Sum (n):\n    sum=0\n    for i in range(1, 2*n, 2):\n        sum+=i**2\n        \n    return sum\n    \n\n"}
{"task_id": "Mbpp/268", "origin_solution": "<def_stmt>find_star_num n<block_start><return>6<times>(n<power>2-n)+1<block_end>\n", "solution": "\ndef find_star_num (n):\n    return 6*(n**2-n)+1\n    \n\n"}
{"task_id": "Mbpp/269", "origin_solution": "<def_stmt>ascii_value char<block_start><return>ord(char)<block_end>\n", "solution": "\ndef ascii_value (char):\n    return ord(char)\n    \n\n"}
{"task_id": "Mbpp/270", "origin_solution": "<def_stmt>sum_even_and_even_index lst<block_start><return>sum(lst[i]<for>i range(0 len(lst) 2)<if>lst[i]%2<eq>0)<block_end>\n", "solution": "\ndef sum_even_and_even_index (lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i]%2==0)\n    \n\n"}
{"task_id": "Mbpp/271", "origin_solution": "<def_stmt>even_Power_Sum n<block_start>sum=0<line_sep>count=0<line_sep>num=2<while_stmt>count<l>n<block_start>power=num<power>5<line_sep>sum<augadd>power<line_sep>count<augadd>1<line_sep>num<augadd>2<block_end><return>sum<block_end>\n", "solution": "\ndef even_Power_Sum (n):\n    sum=0\n    count=0\n    num=2\n    while count<n:\n        power=num**5\n        sum+=power\n        count+=1\n        num+=2\n        \n    return sum\n    \n\n"}
{"task_id": "Mbpp/272", "origin_solution": "<def_stmt>rear_extract tuples_list<block_start><return>[t[2]<for>t tuples_list]<block_end>\n", "solution": "\ndef rear_extract (tuples_list):\n    return [t[2] for t in tuples_list]\n    \n\n"}
{"task_id": "Mbpp/273", "origin_solution": "<def_stmt>subtract_elements tuple1 tuple2<block_start><return>tuple(a-b<for>a,b zip(tuple1 tuple2))<block_end>\n", "solution": "\ndef subtract_elements (tuple1, tuple2):\n    return tuple(a-b for a,b in zip(tuple1, tuple2))\n    \n\n"}
{"task_id": "Mbpp/274", "origin_solution": "<def_stmt>even_binomial_Coeff_Sum n<block_start>result=0<for_stmt>i range(0 n 2)<block_start>result<augadd>comb(n i)<block_end><return>result<block_end><import_from_stmt>math comb<line_sep>print(even_binomial_Coeff_Sum(4))<line_sep>print(even_binomial_Coeff_Sum(6))<line_sep>print(even_binomial_Coeff_Sum(2))<line_sep>\n", "solution": "\ndef even_binomial_Coeff_Sum (n):\n    result=0\n    for i in range(0, n, 2):\n        result+=comb(n, i)\n        \n    return result\n    \nfrom math import comb\nprint(even_binomial_Coeff_Sum(4))\nprint(even_binomial_Coeff_Sum(6))\nprint(even_binomial_Coeff_Sum(2))\n\n"}
{"task_id": "Mbpp/276", "origin_solution": "<import_stmt>math<def_stmt>volume_cylinder radius height<block_start><return>math.pi<times>radius<power>2<times>height<block_end>\n", "solution": "\nimport math\ndef volume_cylinder (radius, height):\n    return math.pi*radius**2*height\n    \n\n"}
{"task_id": "Mbpp/277", "origin_solution": "<def_stmt>dict_filter d n<block_start><return>{k:v<for>k,v d.items()<if>v<ge>n}<block_end>\n", "solution": "\ndef dict_filter (d, n):\n    return {k:v for k,v in d.items() if v>=n}\n    \n\n"}
{"task_id": "Mbpp/278", "origin_solution": "<def_stmt>count_first_elements t<block_start>count=0<for_stmt>i t<block_start><if_stmt>isinstance(i tuple)<block_start><break><block_end>count<augadd>1<block_end><return>count<block_end>\n", "solution": "\ndef count_first_elements (t):\n    count=0\n    for i in t:\n        if isinstance(i, tuple):\n            break \n            \n        count+=1\n        \n    return count\n    \n\n"}
{"task_id": "Mbpp/279", "origin_solution": "<def_stmt>is_num_decagonal n<block_start><return>n<times>(3<times>n-1)<block_end>\n", "solution": "\ndef is_num_decagonal (n):\n    return n*(3*n-1)\n    \n\n"}
{"task_id": "Mbpp/280", "origin_solution": "<def_stmt>sequential_search arr target<block_start><for_stmt>i range(len(arr))<block_start><if_stmt>arr[i]<eq>target<block_start><return>(<true> i)<block_end><block_end><return>(<false> -1)<block_end>\n", "solution": "\ndef sequential_search (arr, target):\n    for i in range(len(arr)):\n        if arr[i]==target:\n            return ( True , i)\n            \n    \n    return ( False , -1)\n    \n\n"}
{"task_id": "Mbpp/281", "origin_solution": "<def_stmt>all_unique lst<block_start><return>len(lst)<eq>len(set(lst))<block_end>\n", "solution": "\ndef all_unique (lst):\n    return len(lst)==len(set(lst))\n    \n\n"}
{"task_id": "Mbpp/282", "origin_solution": "<def_stmt>sub_list list1 list2<block_start><return>[a-b<for>a,b zip(list1 list2)]<block_end>\n", "solution": "\ndef sub_list (list1, list2):\n    return [a-b for a,b in zip(list1, list2)]\n    \n\n"}
{"task_id": "Mbpp/283", "origin_solution": "<def_stmt>validate num<block_start>num_str=str(num)<line_sep>digit_count={}<for_stmt>digit num_str<block_start><if_stmt>digit<in>digit_count<block_start>digit_count[digit]<augadd>1<block_end><else_stmt><block_start>digit_count[digit]=1<block_end><block_end><for_stmt>digit,count digit_count.items()<block_start><if_stmt>int(digit)<g>count<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef validate (num):\n    num_str=str(num)\n    digit_count={}\n    for digit in num_str:\n        if digit in digit_count:\n            digit_count[digit]+=1\n            \n        \n        else :\n            digit_count[digit]=1\n            \n    \n    for digit,count in digit_count.items():\n        if int(digit)>count:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/284", "origin_solution": "<def_stmt>check_element lst element<block_start><return>all(x<eq>element<for>x lst)<block_end>\n", "solution": "\ndef check_element (lst, element):\n    return all(x==element for x in lst)\n    \n\n"}
{"task_id": "Mbpp/285", "origin_solution": "<import_stmt>re<def_stmt>text_match_two_three text<block_start>pattern=r\"ab{2,3}\"<line_sep><return>bool(re.search(pattern text))<block_end>\n", "solution": "\nimport re\ndef text_match_two_three (text):\n    pattern=r\"ab{2,3}\"\n    return bool(re.search(pattern, text))\n    \n\n"}
{"task_id": "Mbpp/286", "origin_solution": "<def_stmt>max_sub_array_sum_repeated arr k<block_start><def_stmt>max_sub_array_sum arr<block_start>max_so_far=arr[0]<line_sep>curr_max=arr[0]<for_stmt>i range(1 len(arr))<block_start>curr_max=max(arr[i] curr_max+arr[i])<line_sep>max_so_far=max(max_so_far curr_max)<block_end><return>max_so_far<block_end>sum_arr=k<times>sum(arr)<line_sep><return>max(max_sub_array_sum(arr) sum_arr)<block_end>\n", "solution": "\ndef max_sub_array_sum_repeated (arr, k):\n    def max_sub_array_sum (arr):\n        max_so_far=arr[0]\n        curr_max=arr[0]\n        for i in range(1, len(arr)):\n            curr_max=max(arr[i], curr_max+arr[i])\n            max_so_far=max(max_so_far, curr_max)\n            \n        return max_so_far\n        \n    sum_arr=k*sum(arr)\n    return max(max_sub_array_sum(arr), sum_arr)\n    \n\n"}
{"task_id": "Mbpp/287", "origin_solution": "<def_stmt>square_Sum n<block_start>sum=0<for_stmt>i range(1 n+1)<block_start>sum<augadd>(2<times>i)<power>2<block_end><return>sum<block_end>\n", "solution": "\ndef square_Sum (n):\n    sum=0\n    for i in range(1, n+1):\n        sum+=(2*i)**2\n        \n    return sum\n    \n\n"}
{"task_id": "Mbpp/290", "origin_solution": "<def_stmt>max_length list_of_lists<block_start>max_length=0<line_sep>max_list=[]<for_stmt>lst list_of_lists<block_start><if_stmt>len(lst)<g>max_length<block_start>max_length=len(lst)<line_sep>max_list=lst<block_end><block_end><return>max_length max_list<block_end>\n", "solution": "\ndef max_length (list_of_lists):\n    max_length=0\n    max_list=[]\n    for lst in list_of_lists:\n        if len(lst)>max_length:\n            max_length=len(lst)\n            max_list=lst\n            \n    \n    return max_length, max_list\n    \n\n"}
{"task_id": "Mbpp/292", "origin_solution": "<def_stmt>find a b<block_start><return>a<floordiv>b<block_end>\n", "solution": "\ndef find (a, b):\n    return a//b\n    \n\n"}
{"task_id": "Mbpp/293", "origin_solution": "<import_stmt>math<def_stmt>otherside_rightangle a b<block_start><return>math.sqrt(a<power>2+b<power>2)<block_end>\n", "solution": "\nimport math\ndef otherside_rightangle (a, b):\n    return math.sqrt(a**2+b**2)\n    \n\n"}
{"task_id": "Mbpp/294", "origin_solution": "<def_stmt>max_val input_list<block_start>max_val=max(input_list)<line_sep><return>max_val<block_end>\n", "solution": "\ndef max_val (input_list):\n    max_val=max(input_list)\n    return max_val\n    \n\n"}
{"task_id": "Mbpp/296", "origin_solution": "<def_stmt>get_Inv_Count arr<block_start>inv_count=0<for_stmt>i range(len(arr))<block_start><for_stmt>j range(i+1 len(arr))<block_start><if_stmt>arr[i]<g>arr[j]<block_start>inv_count<augadd>1<block_end><block_end><block_end><return>inv_count<block_end>\n", "solution": "\ndef get_Inv_Count (arr):\n    inv_count=0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]>arr[j]:\n                inv_count+=1\n                \n        \n    \n    return inv_count\n    \n\n"}
{"task_id": "Mbpp/297", "origin_solution": "<def_stmt>flatten_list nested_list<block_start>flat_list=[]<for_stmt>item nested_list<block_start><if_stmt>isinstance(item list)<block_start>flat_list.extend(flatten_list(item))<block_end><else_stmt><block_start>flat_list.append(item)<block_end><block_end><return>flat_list<block_end>\n", "solution": "\ndef flatten_list (nested_list):\n    flat_list=[]\n    for item in nested_list:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n            \n        \n        else :\n            flat_list.append(item)\n            \n    \n    return flat_list\n    \n\n"}
{"task_id": "Mbpp/299", "origin_solution": "<def_stmt>max_aggregate lst<block_start><return>max(lst key=<lambda>x:x[1])<block_end>\n", "solution": "\ndef max_aggregate (lst):\n    return max(lst, key=lambda x:x[1])\n    \n\n"}
{"task_id": "Mbpp/300", "origin_solution": "<def_stmt>count_binary_seq n<block_start><if_stmt>n<eq>1<block_start><return>2<block_end><else_stmt><block_start><return>2<power>(n-1)<times>(2<power>n-2)<block_end><block_end>\n", "solution": "\ndef count_binary_seq (n):\n    if n==1:\n        return 2\n        \n    \n    else :\n        return 2**(n-1)*(2**n-2)\n        \n\n\n"}
{"task_id": "Mbpp/301", "origin_solution": "<def_stmt>dict_depth d<block_start><if_stmt>isinstance(d dict)<block_start><return>1+(max(map(dict_depth d.values()))<if>d<else>0)<block_end><else_stmt><block_start><return>0<block_end><block_end>\n", "solution": "\ndef dict_depth (d):\n    if isinstance(d, dict):\n        return 1+(max(map(dict_depth, d.values())) if d else 0)\n        \n    \n    else :\n        return 0\n        \n\n\n"}
{"task_id": "Mbpp/305", "origin_solution": "<def_stmt>start_withp words<block_start>p_words=[word<for>word words<if>word.startswith('p')]<if_stmt>len(p_words)<g>0<block_start><return>p_words[0].split()<block_end><else_stmt><block_start><return><none><block_end><block_end>\n", "solution": "\ndef start_withp (words):\n    p_words=[word for word in words if word.startswith('p')]\n    if len(p_words)>0:\n        return p_words[0].split()\n        \n    \n    else :\n        return  None \n        \n\n\n"}
{"task_id": "Mbpp/306", "origin_solution": "<def_stmt>max_sum_increasing_subseq arr k i<block_start>dp=[0]<times>len(arr)<line_sep>dp[i]=arr[i]<for_stmt>j range(i+1 len(arr))<block_start><if_stmt>arr[j]<g>arr[i]<and>j<g>k<block_start>dp[j]=max(dp[j] dp[i]+arr[j])<block_end><block_end><return>max(dp)<block_end>\n", "solution": "\ndef max_sum_increasing_subseq (arr, k, i):\n    dp=[0]*len(arr)\n    dp[i]=arr[i]\n    for j in range(i+1, len(arr)):\n        if arr[j]>arr[i] and j>k:\n            dp[j]=max(dp[j], dp[i]+arr[j])\n            \n    \n    return max(dp)\n    \n\n"}
{"task_id": "Mbpp/308", "origin_solution": "<def_stmt>large_product list1 list2 n<block_start>products=[a<times>b<for>a list1<for>b list2]<line_sep>products.sort(reverse=<true>)<line_sep><return>products[:n]<block_end>\n", "solution": "\ndef large_product (list1, list2, n):\n    products=[a*b for a in list1 for b in list2]\n    products.sort(reverse= True )\n    return products[:n]\n    \n\n"}
{"task_id": "Mbpp/309", "origin_solution": "<def_stmt>maximum a b<block_start><if_stmt>a<g>b<block_start><return>a<block_end><else_stmt><block_start><return>b<block_end><block_end>\n", "solution": "\ndef maximum (a, b):\n    if a>b:\n        return a\n        \n    \n    else :\n        return b\n        \n\n\n"}
{"task_id": "Mbpp/310", "origin_solution": "<def_stmt>string_to_tuple s<block_start><return>tuple(s)<block_end>\n", "solution": "\ndef string_to_tuple (s):\n    return tuple(s)\n    \n\n"}
{"task_id": "Mbpp/311", "origin_solution": "<def_stmt>set_left_most_unset_bit n<block_start><return>n|(n-1)<block_end>\n", "solution": "\ndef set_left_most_unset_bit (n):\n    return n|(n-1)\n    \n\n"}
{"task_id": "Mbpp/312", "origin_solution": "<import_stmt>math<def_stmt>volume_cone radius height<block_start><return>(1/3)<times>math.pi<times>radius<times>radius<times>height<block_end>\n", "solution": "\nimport math\ndef volume_cone (radius, height):\n    return (1/3)*math.pi*radius*radius*height\n    \n\n"}
{"task_id": "Mbpp/388", "origin_solution": "<def_stmt>highest_Power_of_2 n<block_start>power=1<while_stmt>power<le>n<block_start>power<augmul>2<block_end><return>power<floordiv>2<block_end>\n", "solution": "\ndef highest_Power_of_2 (n):\n    power=1\n    while power<=n:\n        power*=2\n        \n    return power//2\n    \n\n"}
{"task_id": "Mbpp/389", "origin_solution": "<def_stmt>find_lucas n<block_start><if_stmt>n<eq>0<block_start><return>2<block_end><elif_stmt>n<eq>1<block_start><return>1<block_end><else_stmt><block_start>a,b=2 1<for_stmt>_ range(n-1)<block_start>a,b=b a+b<block_end><return>b<block_end><block_end>\n", "solution": "\ndef find_lucas (n):\n    if n==0:\n        return 2\n        \n    \n    elif n==1:\n        return 1\n        \n    \n    else :\n        a,b=2, 1\n        for _ in range(n-1):\n            a,b=b, a+b\n            \n        return b\n        \n\n\n"}
{"task_id": "Mbpp/390", "origin_solution": "<def_stmt>add_string lst fmt<block_start><return>[fmt.format(i)<for>i lst]<block_end>\n", "solution": "\ndef add_string (lst, fmt):\n    return [fmt.format(i) for i in lst]\n    \n\n"}
{"task_id": "Mbpp/391", "origin_solution": "<def_stmt>convert_list_dictionary keys values scores<block_start>result=[]<for_stmt>i range(len(keys))<block_start>result.append({keys[i]:{values[i]:scores[i]}})<block_end><return>result<block_end>\n", "solution": "\ndef convert_list_dictionary (keys, values, scores):\n    result=[]\n    for i in range(len(keys)):\n        result.append({keys[i]:{values[i]:scores[i]}})\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/392", "origin_solution": "<def_stmt>get_max_sum n<block_start><if_stmt>n<eq>0<or>n<eq>1<block_start><return>n<block_end>dp=[0]<times>(n+1)<line_sep>dp[0]=0<line_sep>dp[1]=1<for_stmt>i range(2 n+1)<block_start>dp[i]=max(dp[i<floordiv>2]+dp[i<floordiv>3]+dp[i<floordiv>4]+dp[i<floordiv>5] i)<block_end><return>dp[n]<block_end>print(get_max_sum(60))<line_sep>print(get_max_sum(10))<line_sep>print(get_max_sum(2))<line_sep>\n", "solution": "\ndef get_max_sum (n):\n    if n==0 or n==1:\n        return n\n        \n    dp=[0]*(n+1)\n    dp[0]=0\n    dp[1]=1\n    for i in range(2, n+1):\n        dp[i]=max(dp[i//2]+dp[i//3]+dp[i//4]+dp[i//5], i)\n        \n    return dp[n]\n    \nprint(get_max_sum(60))\nprint(get_max_sum(10))\nprint(get_max_sum(2))\n\n"}
{"task_id": "Mbpp/394", "origin_solution": "<def_stmt>check_distinct t<block_start><return>len(t)<eq>len(set(t))<block_end>\n", "solution": "\ndef check_distinct (t):\n    return len(t)==len(set(t))\n    \n\n"}
{"task_id": "Mbpp/395", "origin_solution": "<def_stmt>first_non_repeating_character s<block_start>char_count={}<for_stmt>char s<block_start><if_stmt>char<in>char_count<block_start>char_count[char]<augadd>1<block_end><else_stmt><block_start>char_count[char]=1<block_end><block_end><for_stmt>char s<block_start><if_stmt>char_count[char]<eq>1<block_start><return>char<block_end><block_end><return><none><block_end>\n", "solution": "\ndef first_non_repeating_character (s):\n    char_count={}\n    for char in s:\n        if char in char_count:\n            char_count[char]+=1\n            \n        \n        else :\n            char_count[char]=1\n            \n    \n    for char in s:\n        if char_count[char]==1:\n            return char\n            \n    \n    return  None \n    \n\n"}
{"task_id": "Mbpp/397", "origin_solution": "<def_stmt>median_numbers a b c<block_start>numbers=[a b c]<line_sep>numbers.sort()<line_sep><return>numbers[1]<block_end>\n", "solution": "\ndef median_numbers (a, b, c):\n    numbers=[a, b, c]\n    numbers.sort()\n    return numbers[1]\n    \n\n"}
{"task_id": "Mbpp/398", "origin_solution": "<def_stmt>sum_of_digits lst<block_start>total=0<for_stmt>i lst<block_start><if_stmt>isinstance(i list)<block_start>total<augadd>sum_of_digits(i)<block_end><else_stmt><block_start><for_stmt>j str(i)<block_start>total<augadd>int(j)<block_end><block_end><block_end><return>total<block_end>\n", "solution": "\ndef sum_of_digits (lst):\n    total=0\n    for i in lst:\n        if isinstance(i, list):\n            total+=sum_of_digits(i)\n            \n        \n        else :\n            for j in str(i):\n                total+=int(j)\n                \n        \n    \n    return total\n    \n\n"}
{"task_id": "Mbpp/404", "origin_solution": "<def_stmt>minimum a b<block_start><if_stmt>a<l>b<block_start><return>a<block_end><else_stmt><block_start><return>b<block_end><block_end>\n", "solution": "\ndef minimum (a, b):\n    if a<b:\n        return a\n        \n    \n    else :\n        return b\n        \n\n\n"}
{"task_id": "Mbpp/405", "origin_solution": "<def_stmt>check_tuplex tpl element<block_start><return>element<in>tpl<block_end>\n", "solution": "\ndef check_tuplex (tpl, element):\n    return element in tpl\n    \n\n"}
{"task_id": "Mbpp/406", "origin_solution": "<def_stmt>find_Parity number<block_start><return>number%2<eq>1<block_end>\n", "solution": "\ndef find_Parity (number):\n    return number%2==1\n    \n\n"}
{"task_id": "Mbpp/409", "origin_solution": "<def_stmt>min_product_tuple tuples<block_start>min_product=float('inf')<for_stmt>t tuples<block_start>product=t[0]<times>t[1]<if_stmt>product<l>min_product<block_start>min_product=product<block_end><block_end><return>min_product<block_end>\n", "solution": "\ndef min_product_tuple (tuples):\n    min_product=float('inf')\n    for t in tuples:\n        product=t[0]*t[1]\n        if product<min_product:\n            min_product=product\n            \n    \n    return min_product\n    \n\n"}
{"task_id": "Mbpp/410", "origin_solution": "<def_stmt>min_val lst<block_start><return>min(lst)<block_end>\n", "solution": "\ndef min_val (lst):\n    return min(lst)\n    \n\n"}
{"task_id": "Mbpp/412", "origin_solution": "<def_stmt>remove_odd lst<block_start><return>[num<for>num lst<if>num%2<eq>0]<block_end>\n", "solution": "\ndef remove_odd (lst):\n    return [num for num in lst if num%2==0]\n    \n\n"}
{"task_id": "Mbpp/413", "origin_solution": "<def_stmt>extract_nth_element list_of_tuples n<block_start><return>[t[n]<for>t list_of_tuples]<block_end>\n", "solution": "\ndef extract_nth_element (list_of_tuples, n):\n    return [t[n] for t in list_of_tuples]\n    \n\n"}
{"task_id": "Mbpp/414", "origin_solution": "<def_stmt>overlapping seq1 seq2<block_start><for_stmt>i seq1<block_start><if_stmt>i<in>seq2<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef overlapping (seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/415", "origin_solution": "<def_stmt>max_Product arr<block_start>arr.sort()<line_sep>n=len(arr)<line_sep><return>(arr[n-1] arr[n-2])<block_end>\n", "solution": "\ndef max_Product (arr):\n    arr.sort()\n    n=len(arr)\n    return (arr[n-1], arr[n-2])\n    \n\n"}
{"task_id": "Mbpp/418", "origin_solution": "<def_stmt>Find_Max lst<block_start>max_length=-1<line_sep>max_list=[]<for_stmt>sub_list lst<block_start><if_stmt>len(sub_list)<g>max_length<block_start>max_length=len(sub_list)<line_sep>max_list=sub_list<block_end><block_end><return>max_list<block_end>\n", "solution": "\ndef Find_Max (lst):\n    max_length=-1\n    max_list=[]\n    for sub_list in lst:\n        if len(sub_list)>max_length:\n            max_length=len(sub_list)\n            max_list=sub_list\n            \n    \n    return max_list\n    \n\n"}
{"task_id": "Mbpp/419", "origin_solution": "<def_stmt>round_and_sum numbers<block_start>rounded_numbers=[round(num)<for>num numbers]<line_sep>total_sum=sum(rounded_numbers)<line_sep><return>len(numbers)<times>total_sum<block_end>\n", "solution": "\ndef round_and_sum (numbers):\n    rounded_numbers=[round(num) for num in numbers]\n    total_sum=sum(rounded_numbers)\n    return len(numbers)*total_sum\n    \n\n"}
{"task_id": "Mbpp/420", "origin_solution": "<def_stmt>cube_Sum n<block_start>sum=0<for_stmt>i range(1 n+1)<block_start>sum<augadd>(2<times>i)<power>3<block_end><return>sum<block_end>\n", "solution": "\ndef cube_Sum (n):\n    sum=0\n    for i in range(1, n+1):\n        sum+=(2*i)**3\n        \n    return sum\n    \n\n"}
{"task_id": "Mbpp/421", "origin_solution": "<def_stmt>concatenate_tuple t<block_start><return>'-'.join(str(i)<for>i t)<block_end>\n", "solution": "\ndef concatenate_tuple (t):\n    return '-'.join(str(i) for i in t)\n    \n\n"}
{"task_id": "Mbpp/422", "origin_solution": "<def_stmt>find_Average_Of_Cube n<block_start>sum_of_cubes=0<for_stmt>i range(1 n+1)<block_start>sum_of_cubes<augadd>i<power>3<block_end><return>sum_of_cubes/n<block_end>\n", "solution": "\ndef find_Average_Of_Cube (n):\n    sum_of_cubes=0\n    for i in range(1, n+1):\n        sum_of_cubes+=i**3\n        \n    return sum_of_cubes/n\n    \n\n"}
{"task_id": "Mbpp/424", "origin_solution": "<def_stmt>extract_rear tup<block_start><return>[s[-1]<for>s tup]<block_end>\n", "solution": "\ndef extract_rear (tup):\n    return [s[-1] for s in tup]\n    \n\n"}
{"task_id": "Mbpp/425", "origin_solution": "<def_stmt>count_element_in_list lst element<block_start>count=0<for_stmt>sublist lst<block_start><if_stmt>element<in>sublist<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_element_in_list (lst, element):\n    count=0\n    for sublist in lst:\n        if element in sublist:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/426", "origin_solution": "<def_stmt>filter_oddnumbers numbers<block_start><return>[num<for>num numbers<if>num%2<ne>0]<block_end>\n", "solution": "\ndef filter_oddnumbers (numbers):\n    return [num for num in numbers if num%2!=0]\n    \n\n"}
{"task_id": "Mbpp/427", "origin_solution": "<def_stmt>change_date_format date<block_start><return>date.replace(\"-\" \"-\")<block_end>\n", "solution": "\ndef change_date_format (date):\n    return date.replace(\"-\", \"-\")\n    \n\n"}
{"task_id": "Mbpp/428", "origin_solution": "<def_stmt>shell_sort arr<block_start>n=len(arr)<line_sep>gap=n<floordiv>2<while_stmt>gap<g>0<block_start><for_stmt>i range(gap n)<block_start>temp=arr[i]<line_sep>j=i<while_stmt>j<ge>gap<and>arr[j-gap]<g>temp<block_start>arr[j]=arr[j-gap]<line_sep>j<augsub>gap<block_end>arr[j]=temp<block_end>gap<augfloordiv>2<block_end><return>arr<block_end>\n", "solution": "\ndef shell_sort (arr):\n    n=len(arr)\n    gap=n//2\n    while gap>0:\n        for i in range(gap, n):\n            temp=arr[i]\n            j=i\n            while j>=gap and arr[j-gap]>temp:\n                arr[j]=arr[j-gap]\n                j-=gap\n                \n            arr[j]=temp\n            \n        gap//=2\n        \n    return arr\n    \n\n"}
{"task_id": "Mbpp/429", "origin_solution": "<def_stmt>and_tuples t1 t2<block_start><return>tuple(a&b<for>a,b zip(t1 t2))<block_end>\n", "solution": "\ndef and_tuples (t1, t2):\n    return tuple(a&b for a,b in zip(t1, t2))\n    \n\n"}
{"task_id": "Mbpp/430", "origin_solution": "<def_stmt>parabola_directrix x1 y1 x2 y2<block_start><return>-y1<times>(x1-x2)/(y1-y2)<block_end>\n", "solution": "\ndef parabola_directrix (x1, y1, x2, y2):\n    return -y1*(x1-x2)/(y1-y2)\n    \n\n"}
{"task_id": "Mbpp/432", "origin_solution": "<def_stmt>median_trapezium a b c<block_start>sides=sorted([a b c])<line_sep><return>sum(sides)/2<block_end>\n", "solution": "\ndef median_trapezium (a, b, c):\n    sides=sorted([a, b, c])\n    return sum(sides)/2\n    \n\n"}
{"task_id": "Mbpp/433", "origin_solution": "<def_stmt>check_greater arr num<block_start><for_stmt>element arr<block_start><if_stmt>element<g>num<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef check_greater (arr, num):\n    for element in arr:\n        if element>num:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/435", "origin_solution": "<def_stmt>last_Digit n<block_start><return>n%10<block_end>\n", "solution": "\ndef last_Digit (n):\n    return n%10\n    \n\n"}
{"task_id": "Mbpp/436", "origin_solution": "<def_stmt>neg_nos lst<block_start><return>[num<for>num lst<if>num<l>0]<block_end>\n", "solution": "\ndef neg_nos (lst):\n    return [num for num in lst if num<0]\n    \n\n"}
{"task_id": "Mbpp/437", "origin_solution": "<def_stmt>remove_odd s<block_start><return>''.join([c<for>c s<if>c%2<eq>0])<block_end>\n", "solution": "\ndef remove_odd (s):\n    return ''.join([c for c in s if c%2==0])\n    \n\n"}
{"task_id": "Mbpp/439", "origin_solution": "<def_stmt>multiple_to_single numbers<block_start><return>int(''.join(map(str numbers)))<block_end>\n", "solution": "\ndef multiple_to_single (numbers):\n    return int(''.join(map(str, numbers)))\n    \n\n"}
{"task_id": "Mbpp/440", "origin_solution": "<def_stmt>find_adverb_position sentence<block_start>adverbs=['clearly' 'seriously' 'unfortunately']<for_stmt>adverb adverbs<block_start>start_index=sentence.find(adverb)<if_stmt>start_index<ne>-1<block_start><return>(start_index start_index+len(adverb) adverb)<block_end><block_end><return><none><block_end>\n", "solution": "\ndef find_adverb_position (sentence):\n    adverbs=['clearly', 'seriously', 'unfortunately']\n    for adverb in adverbs:\n        start_index=sentence.find(adverb)\n        if start_index!=-1:\n            return (start_index, start_index+len(adverb), adverb)\n            \n    \n    return  None \n    \n\n"}
{"task_id": "Mbpp/441", "origin_solution": "<def_stmt>surfacearea_cube side_length<block_start><return>6<times>side_length<power>2<block_end>\n", "solution": "\ndef surfacearea_cube (side_length):\n    return 6*side_length**2\n    \n\n"}
{"task_id": "Mbpp/445", "origin_solution": "<def_stmt>index_multiplication test_tup1 test_tup2<block_start>res=[]<for_stmt>tup1,tup2 zip(test_tup1 test_tup2)<block_start>res.append((tup1[0]<times>tup2[0] tup1[1]<times>tup2[1]))<block_end><return>tuple(res)<block_end>\n", "solution": "\ndef index_multiplication (test_tup1, test_tup2):\n    res=[]\n    for tup1,tup2 in zip(test_tup1, test_tup2):\n        res.append((tup1[0]*tup2[0], tup1[1]*tup2[1]))\n        \n    return tuple(res)\n    \n\n"}
{"task_id": "Mbpp/446", "origin_solution": "<def_stmt>count_Occurrence lst elements<block_start>count=0<for_stmt>i lst<block_start><if_stmt>i<in>elements<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_Occurrence (lst, elements):\n    count=0\n    for i in lst:\n        if i in elements:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/447", "origin_solution": "<def_stmt>cube_nums nums<block_start><return>[num<power>3<for>num nums]<block_end>\n", "solution": "\ndef cube_nums (nums):\n    return [num**3 for num in nums]\n    \n\n"}
{"task_id": "Mbpp/448", "origin_solution": "<def_stmt>cal_sum n<block_start>sum=0<for_stmt>i range(1 n)<block_start><if_stmt>i%2<eq>0<block_start>sum<augadd>i<block_end><block_end><return>sum<block_end>print(cal_sum(9))<line_sep>print(cal_sum(10))<line_sep>print(cal_sum(11))<line_sep>\n", "solution": "\ndef cal_sum (n):\n    sum=0\n    for i in range(1, n):\n        if i%2==0:\n            sum+=i\n            \n    \n    return sum\n    \nprint(cal_sum(9))\nprint(cal_sum(10))\nprint(cal_sum(11))\n\n"}
{"task_id": "Mbpp/450", "origin_solution": "<def_stmt>extract_string list values<block_start><return>[i<for>i list<if>len(i)<eq>values]<block_end>\n", "solution": "\ndef extract_string (list, values):\n    return [i for i in list if len(i)==values]\n    \n\n"}
{"task_id": "Mbpp/451", "origin_solution": "<def_stmt>remove_whitespaces s<block_start><return>s.replace(\" \" \"\")<block_end>\n", "solution": "\ndef remove_whitespaces (s):\n    return s.replace(\" \", \"\")\n    \n\n"}
{"task_id": "Mbpp/453", "origin_solution": "<def_stmt>sumofFactors n<block_start>sum=0<for_stmt>i range(2 n+1)<block_start><if_stmt>n%i<eq>0<and>i%2<eq>0<block_start>sum<augadd>i<block_end><block_end><return>sum<block_end>\n", "solution": "\ndef sumofFactors (n):\n    sum=0\n    for i in range(2, n+1):\n        if n%i==0 and i%2==0:\n            sum+=i\n            \n    \n    return sum\n    \n\n"}
{"task_id": "Mbpp/454", "origin_solution": "<import_stmt>re<def_stmt>text_match_wordz text<block_start>pattern=r'z'<if_stmt>re.search(pattern text)<block_start><return><true><block_end><else_stmt><block_start><return><false><block_end><block_end>\n", "solution": "\nimport re\ndef text_match_wordz (text):\n    pattern=r'z'\n    if re.search(pattern, text):\n        return  True \n        \n    \n    else :\n        return  False \n        \n\n\n"}
{"task_id": "Mbpp/455", "origin_solution": "<def_stmt>check_monthnumb_number month_number<block_start><return>month_number<in>[1 3 5 7 8 10 12]<block_end>\n", "solution": "\ndef check_monthnumb_number (month_number):\n    return month_number in [1, 3, 5, 7, 8, 10, 12]\n    \n\n"}
{"task_id": "Mbpp/456", "origin_solution": "<def_stmt>reverse_string_list string_list<block_start><return>[s[::-1]<for>s string_list]<block_end>\n", "solution": "\ndef reverse_string_list (string_list):\n    return [s[::-1] for s in string_list]\n    \n\n"}
{"task_id": "Mbpp/457", "origin_solution": "<def_stmt>Find_Min lst<block_start>min_length=float('inf')<line_sep>min_sublist=[]<for_stmt>sublist lst<block_start><if_stmt>len(sublist)<l>min_length<block_start>min_length=len(sublist)<line_sep>min_sublist=sublist<block_end><block_end><return>min_sublist<block_end>\n", "solution": "\ndef Find_Min (lst):\n    min_length=float('inf')\n    min_sublist=[]\n    for sublist in lst:\n        if len(sublist)<min_length:\n            min_length=len(sublist)\n            min_sublist=sublist\n            \n    \n    return min_sublist\n    \n\n"}
{"task_id": "Mbpp/458", "origin_solution": "<def_stmt>rectangle_area length width<block_start><return>length<times>width<block_end>\n", "solution": "\ndef rectangle_area (length, width):\n    return length*width\n    \n\n"}
{"task_id": "Mbpp/459", "origin_solution": "<def_stmt>remove_uppercase s<block_start>result=''<for_stmt>char s<block_start><if_stmt>char.islower()<block_start>result<augadd>char<block_end><block_end><return>result<block_end>\n", "solution": "\ndef remove_uppercase (s):\n    result=''\n    for char in s:\n        if char.islower():\n            result+=char\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/460", "origin_solution": "<def_stmt>Extract lst<block_start><return>[sublist[0]<for>sublist lst]<block_end>\n", "solution": "\ndef Extract (lst):\n    return [sublist[0] for sublist in lst]\n    \n\n"}
{"task_id": "Mbpp/462", "origin_solution": "<import_from_stmt>itertools combinations<def_stmt>combinations_list lst<block_start>result=[]<for_stmt>i range(len(lst)+1)<block_start><for_stmt>subset combinations.comb(lst i)<block_start>result.append(list(subset))<block_end><block_end><return>result<block_end>\n", "solution": "\nfrom itertools import combinations\ndef combinations_list (lst):\n    result=[]\n    for i in range(len(lst)+1):\n        for subset in combinations.comb(lst, i):\n            result.append(list(subset))\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/463", "origin_solution": "<def_stmt>max_subarray_product nums<block_start><if_stmt><not>nums<block_start><return>0<block_end>max_product=min_product=result=nums[0]<for_stmt>i range(1 len(nums))<block_start><if_stmt>nums[i]<l>0<block_start>max_product,min_product=min_product max_product<block_end>max_product=max(nums[i] max_product<times>nums[i])<line_sep>min_product=min(nums[i] min_product<times>nums[i])<line_sep>result=max(result max_product)<block_end><return>result<block_end>\n", "solution": "\ndef max_subarray_product (nums):\n    if  not nums:\n        return 0\n        \n    max_product=min_product=result=nums[0]\n    for i in range(1, len(nums)):\n        if nums[i]<0:\n            max_product,min_product=min_product, max_product\n            \n        max_product=max(nums[i], max_product*nums[i])\n        min_product=min(nums[i], min_product*nums[i])\n        result=max(result, max_product)\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/465", "origin_solution": "<def_stmt>drop_empty d<block_start><return>{k:v<for>k,v d.items()<if>v<is><not><none>}<block_end>\n", "solution": "\ndef drop_empty (d):\n    return {k:v for k,v in d.items() if v is  not  None }\n    \n\n"}
{"task_id": "Mbpp/468", "origin_solution": "<def_stmt>max_product nums<block_start>nums.sort()<line_sep><return>max(nums[-1]<times>nums[-2] nums[0]<times>nums[1])<block_end>\n", "solution": "\ndef max_product (nums):\n    nums.sort()\n    return max(nums[-1]*nums[-2], nums[0]*nums[1])\n    \n\n"}
{"task_id": "Mbpp/470", "origin_solution": "<def_stmt>add_pairwise tup<block_start><return>tuple(a+b<for>a,b zip(tup tup[1:]))<block_end>\n", "solution": "\ndef add_pairwise (tup):\n    return tuple(a+b for a,b in zip(tup, tup[1:]))\n    \n\n"}
{"task_id": "Mbpp/471", "origin_solution": "<def_stmt>find_remainder arr n<block_start>product=1<for_stmt>i arr<block_start>product<augmul>i<block_end><return>product%n<block_end>\n", "solution": "\ndef find_remainder (arr, n):\n    product=1\n    for i in arr:\n        product*=i\n        \n    return product%n\n    \n\n"}
{"task_id": "Mbpp/472", "origin_solution": "<def_stmt>check_Consecutive lst<block_start><return>sorted(lst)<eq>lst<block_end>\n", "solution": "\ndef check_Consecutive (lst):\n    return sorted(lst)==lst\n    \n\n"}
{"task_id": "Mbpp/473", "origin_solution": "<def_stmt>tuple_intersection list1 list2<block_start><return>set(list1)&set(list2)<block_end>\n", "solution": "\ndef tuple_intersection (list1, list2):\n    return set(list1)&set(list2)\n    \n\n"}
{"task_id": "Mbpp/474", "origin_solution": "<def_stmt>replace_char s old_char new_char<block_start><return>s.replace(old_char new_char)<block_end>\n", "solution": "\ndef replace_char (s, old_char, new_char):\n    return s.replace(old_char, new_char)\n    \n\n"}
{"task_id": "Mbpp/475", "origin_solution": "<def_stmt>sort_counter d<block_start><return>sorted(d.items() key=<lambda>x:x[1])<block_end>\n", "solution": "\ndef sort_counter (d):\n    return sorted(d.items(), key=lambda x:x[1])\n    \n\n"}
{"task_id": "Mbpp/476", "origin_solution": "<def_stmt>big_sum arr<block_start><return>max(arr)+min(arr)<block_end>\n", "solution": "\ndef big_sum (arr):\n    return max(arr)+min(arr)\n    \n\n"}
{"task_id": "Mbpp/477", "origin_solution": "<def_stmt>is_lower s<block_start><return>s.lower()<block_end>\n", "solution": "\ndef is_lower (s):\n    return s.lower()\n    \n\n"}
{"task_id": "Mbpp/478", "origin_solution": "<def_stmt>remove_lowercase s<block_start>result=\"\"<for_stmt>char s<block_start><if_stmt>char.isupper()<block_start>result<augadd>char<block_end><else_stmt><block_start>result<augadd>char.lower()<block_end><block_end><return>result<block_end>\n", "solution": "\ndef remove_lowercase (s):\n    result=\"\"\n    for char in s:\n        if char.isupper():\n            result+=char\n            \n        \n        else :\n            result+=char.lower()\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/479", "origin_solution": "<def_stmt>first_Digit n<block_start><while_stmt>n<ge>10<block_start>n<augfloordiv>10<block_end><return>n<block_end>\n", "solution": "\ndef first_Digit (n):\n    while n>=10:\n        n//=10\n        \n    return n\n    \n\n"}
{"task_id": "Mbpp/554", "origin_solution": "<def_stmt>Split lst<block_start><return>[i<for>i lst<if>i%2<ne>0]<block_end>\n", "solution": "\ndef Split (lst):\n    return [i for i in lst if i%2!=0]\n    \n\n"}
{"task_id": "Mbpp/555", "origin_solution": "<def_stmt>difference n<block_start>sum_of_cubes=sum([i<power>3<for>i range(1 n+1)])<line_sep>sum_of_numbers=sum(range(1 n+1))<line_sep><return>sum_of_cubes-sum_of_numbers<block_end>\n", "solution": "\ndef difference (n):\n    sum_of_cubes=sum([i**3 for i in range(1, n+1)])\n    sum_of_numbers=sum(range(1, n+1))\n    return sum_of_cubes-sum_of_numbers\n    \n\n"}
{"task_id": "Mbpp/556", "origin_solution": "<def_stmt>find_Odd_Pair arr xor_val<block_start>count=0<for_stmt>i range(len(arr))<block_start><for_stmt>j range(i+1 len(arr))<block_start><if_stmt>(arr[i]^arr[j]^xor_val)%2<eq>1<block_start>count<augadd>1<block_end><block_end><block_end><return>count<block_end>\n", "solution": "\ndef find_Odd_Pair (arr, xor_val):\n    count=0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if (arr[i]^arr[j]^xor_val)%2==1:\n                count+=1\n                \n        \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/557", "origin_solution": "<def_stmt>toggle_string s<block_start><return>s.swapcase()<block_end>\n", "solution": "\ndef toggle_string (s):\n    return s.swapcase()\n    \n\n"}
{"task_id": "Mbpp/558", "origin_solution": "<def_stmt>digit_distance_nums num1 num2<block_start>str_num1=str(num1)<line_sep>str_num2=str(num2)<line_sep>sum_diff=0<for_stmt>i range(len(str_num1))<block_start>sum_diff<augadd>abs(int(str_num1[i])-int(str_num2[i]))<block_end><return>sum_diff<block_end>\n", "solution": "\ndef digit_distance_nums (num1, num2):\n    str_num1=str(num1)\n    str_num2=str(num2)\n    sum_diff=0\n    for i in range(len(str_num1)):\n        sum_diff+=abs(int(str_num1[i])-int(str_num2[i]))\n        \n    return sum_diff\n    \n\n"}
{"task_id": "Mbpp/559", "origin_solution": "<def_stmt>max_sub_array_sum nums k<block_start>max_sum=float('-inf')<line_sep>current_sum=0<for_stmt>i range(len(nums))<block_start>current_sum<augadd>nums[i]<if_stmt>current_sum<eq>k<block_start>max_sum=max(max_sum current_sum)<block_end><if_stmt>current_sum<l>0<block_start>current_sum=0<block_end><block_end><return>max_sum<block_end>\n", "solution": "\ndef max_sub_array_sum (nums, k):\n    max_sum=float('-inf')\n    current_sum=0\n    for i in range(len(nums)):\n        current_sum+=nums[i]\n        if current_sum==k:\n            max_sum=max(max_sum, current_sum)\n            \n        if current_sum<0:\n            current_sum=0\n            \n    \n    return max_sum\n    \n\n"}
{"task_id": "Mbpp/560", "origin_solution": "<def_stmt>union_elements tuple1 tuple2<block_start><return>sorted(set(tuple1)|set(tuple2))<block_end>\n", "solution": "\ndef union_elements (tuple1, tuple2):\n    return sorted(set(tuple1)|set(tuple2))\n    \n\n"}
{"task_id": "Mbpp/562", "origin_solution": "<def_stmt>Find_Max_Length lst<block_start>max_length=0<for_stmt>sublist lst<block_start><if_stmt>len(sublist)<g>max_length<block_start>max_length=len(sublist)<block_end><block_end><return>max_length<block_end>\n", "solution": "\ndef Find_Max_Length (lst):\n    max_length=0\n    for sublist in lst:\n        if len(sublist)>max_length:\n            max_length=len(sublist)\n            \n    \n    return max_length\n    \n\n"}
{"task_id": "Mbpp/563", "origin_solution": "<def_stmt>extract_values s<block_start>values=[]<line_sep>start=0<line_sep>end=0<for_stmt>i range(len(s))<block_start><if_stmt>s[i]<eq>'\"'<block_start><if_stmt>start<eq>0<block_start>start=i+1<block_end><else_stmt><block_start>end=i<line_sep>values.append(s[start:end])<line_sep>start=0<block_end><block_end><block_end><return>values<block_end>\n", "solution": "\ndef extract_values (s):\n    values=[]\n    start=0\n    end=0\n    for i in range(len(s)):\n        if s[i]=='\"':\n            if start==0:\n                start=i+1\n                \n            \n            else :\n                end=i\n                values.append(s[start:end])\n                start=0\n                \n        \n    \n    return values\n    \n\n"}
{"task_id": "Mbpp/564", "origin_solution": "<def_stmt>count_Pairs lst n<block_start>count=0<for_stmt>i range(n)<block_start><for_stmt>j range(i+1 n)<block_start><if_stmt>lst[i]<ne>lst[j]<block_start>count<augadd>1<block_end><block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_Pairs (lst, n):\n    count=0\n    for i in range(n):\n        for j in range(i+1, n):\n            if lst[i]!=lst[j]:\n                count+=1\n                \n        \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/565", "origin_solution": "<def_stmt>split string<block_start><return>list(string)<block_end>\n", "solution": "\ndef split (string):\n    return list(string)\n    \n\n"}
{"task_id": "Mbpp/566", "origin_solution": "<def_stmt>sum_digits n<block_start><return>sum(int(digit)<for>digit str(n))<block_end>\n", "solution": "\ndef sum_digits (n):\n    return sum(int(digit) for digit in str(n))\n    \n\n"}
{"task_id": "Mbpp/567", "origin_solution": "<def_stmt>issort_list lst<block_start><return>all(lst[i]<le>lst[i+1]<for>i range(len(lst)-1))<block_end>\n", "solution": "\ndef issort_list (lst):\n    return all(lst[i]<=lst[i+1] for i in range(len(lst)-1))\n    \n\n"}
{"task_id": "Mbpp/568", "origin_solution": "<def_stmt>empty_list n<block_start><return>[{}<for>_ range(n)]<block_end>\n", "solution": "\ndef empty_list (n):\n    return [{} for _ in range(n)]\n    \n\n"}
{"task_id": "Mbpp/569", "origin_solution": "<def_stmt>sort_sublists list_of_lists<block_start><return>[sorted(sublist)<for>sublist list_of_lists]<block_end>\n", "solution": "\ndef sort_sublists (list_of_lists):\n    return [sorted(sublist) for sublist in list_of_lists]\n    \n\n"}
{"task_id": "Mbpp/572", "origin_solution": "<def_stmt>two_unique_nums nums<block_start>unique_nums=[]<for_stmt>num nums<block_start><if_stmt>num<not><in>unique_nums<block_start>unique_nums.append(num)<block_end><block_end><return>unique_nums<block_end>\n", "solution": "\ndef two_unique_nums (nums):\n    unique_nums=[]\n    for num in nums:\n        if num not  in unique_nums:\n            unique_nums.append(num)\n            \n    \n    return unique_nums\n    \n\n"}
{"task_id": "Mbpp/573", "origin_solution": "<def_stmt>unique_product lst<block_start>unique_nums=set(lst)<line_sep>product=1<for_stmt>num unique_nums<block_start>product<augmul>num<block_end><return>product<block_end>\n", "solution": "\ndef unique_product (lst):\n    unique_nums=set(lst)\n    product=1\n    for num in unique_nums:\n        product*=num\n        \n    return product\n    \n\n"}
{"task_id": "Mbpp/576", "origin_solution": "<def_stmt>is_Sub_Array lst sub<block_start>sub_len=len(sub)<for_stmt>i range(len(lst)-sub_len+1)<block_start><if_stmt>lst[i:i+sub_len]<eq>sub<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef is_Sub_Array (lst, sub):\n    sub_len=len(sub)\n    for i in range(len(lst)-sub_len+1):\n        if lst[i:i+sub_len]==sub:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/577", "origin_solution": "<def_stmt>last_Digit_Factorial n<block_start>last_digit=1<for_stmt>i range(2 n+1)<block_start>last_digit=(last_digit<times>i)%10<block_end><return>last_digit<block_end>\n", "solution": "\ndef last_Digit_Factorial (n):\n    last_digit=1\n    for i in range(2, n+1):\n        last_digit=(last_digit*i)%10\n        \n    return last_digit\n    \n\n"}
{"task_id": "Mbpp/578", "origin_solution": "<def_stmt>interleave_lists list1 list2 list3<block_start><return>[item<for>sublist zip(list1 list2 list3)<for>item sublist]<block_end>\n", "solution": "\ndef interleave_lists (list1, list2, list3):\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]\n    \n\n"}
{"task_id": "Mbpp/579", "origin_solution": "<def_stmt>find_dissimilar t1 t2<block_start>dissimilar=tuple(x<for>x t1<if>x<not><in>t2)+tuple(x<for>x t2<if>x<not><in>t1)<line_sep><return>dissimilar<block_end>\n", "solution": "\ndef find_dissimilar (t1, t2):\n    dissimilar=tuple(x for x in t1 if x not  in t2)+tuple(x for x in t2 if x not  in t1)\n    return dissimilar\n    \n\n"}
{"task_id": "Mbpp/580", "origin_solution": "<def_stmt>extract_even t<block_start>result=[]<for_stmt>i t<block_start><if_stmt>isinstance(i tuple)<block_start>result.append(tuple(filter(<lambda>x:x%2<eq>0 extract(i))))<block_end><elif_stmt>i%2<eq>0<block_start>result.append(i)<block_end><block_end><return>tuple(result)<block_end>\n", "solution": "\ndef extract_even (t):\n    result=[]\n    for i in t:\n        if isinstance(i, tuple):\n            result.append(tuple(filter(lambda x:x%2==0, extract(i))))\n            \n        \n        elif i%2==0:\n            result.append(i)\n            \n    \n    return tuple(result)\n    \n\n"}
{"task_id": "Mbpp/581", "origin_solution": "<def_stmt>surface_Area base_edge height<block_start><return>(base_edge<power>2+4<times>base_edge<times>height+4<times>height<power>2)<block_end>\n", "solution": "\ndef surface_Area (base_edge, height):\n    return (base_edge**2+4*base_edge*height+4*height**2)\n    \n\n"}
{"task_id": "Mbpp/583", "origin_solution": "<def_stmt>catalan_number n<block_start><if_stmt>n<le>1<block_start><return>1<block_end>catalan=[0<for>i range(n+1)]<line_sep>catalan[0]=1<line_sep>catalan[1]=1<for_stmt>i range(2 n+1)<block_start>catalan[i]=0<for_stmt>j range(i)<block_start>catalan[i]<augadd>catalan[j]<times>catalan[i-j-1]<block_end><block_end><return>catalan[n]<block_end>print(catalan_number(10))<line_sep>print(catalan_number(9))<line_sep>print(catalan_number(7))<line_sep>\n", "solution": "\ndef catalan_number (n):\n    if n<=1:\n        return 1\n        \n    catalan=[0 for i in range(n+1)]\n    catalan[0]=1\n    catalan[1]=1\n    for i in range(2, n+1):\n        catalan[i]=0\n        for j in range(i):\n            catalan[i]+=catalan[j]*catalan[i-j-1]\n            \n    \n    return catalan[n]\n    \nprint(catalan_number(10))\nprint(catalan_number(9))\nprint(catalan_number(7))\n\n"}
{"task_id": "Mbpp/585", "origin_solution": "<def_stmt>expensive_items items n<block_start>sorted_items=sorted(items key=<lambda>x:x['price'] reverse=<true>)<line_sep><return>sorted_items[:n]<block_end>\n", "solution": "\ndef expensive_items (items, n):\n    sorted_items=sorted(items, key=lambda x:x['price'], reverse= True )\n    return sorted_items[:n]\n    \n\n"}
{"task_id": "Mbpp/586", "origin_solution": "<def_stmt>split_Arr arr n<block_start><return>arr[n:]+arr[:n]<block_end>\n", "solution": "\ndef split_Arr (arr, n):\n    return arr[n:]+arr[:n]\n    \n\n"}
{"task_id": "Mbpp/587", "origin_solution": "<def_stmt>list_tuple lst<block_start><return>tuple(lst)<block_end>\n", "solution": "\ndef list_tuple (lst):\n    return tuple(lst)\n    \n\n"}
{"task_id": "Mbpp/588", "origin_solution": "<def_stmt>big_diff lst<block_start><return>max(lst)-min(lst)<block_end>\n", "solution": "\ndef big_diff (lst):\n    return max(lst)-min(lst)\n    \n\n"}
{"task_id": "Mbpp/589", "origin_solution": "<def_stmt>perfect_squares start end<block_start><return>[i<power>2<for>i range(start end+1)<if>i<power>2<ge>start<and>i<power>2<le>end]<block_end>\n", "solution": "\ndef perfect_squares (start, end):\n    return [i**2 for i in range(start, end+1) if i**2>=start and i**2<=end]\n    \n\n"}
{"task_id": "Mbpp/590", "origin_solution": "<import_stmt>cmath<def_stmt>polar_rect r theta<block_start>x=r<times>cmath.cos(theta)<line_sep>y=r<times>cmath.sin(theta)<line_sep><return>(x y)<block_end>\n", "solution": "\nimport cmath\ndef polar_rect (r, theta):\n    x=r*cmath.cos(theta)\n    y=r*cmath.sin(theta)\n    return (x, y)\n    \n\n"}
{"task_id": "Mbpp/591", "origin_solution": "<def_stmt>swap_List lst<block_start>lst[0],lst[-1]=lst[-1] lst[0]<line_sep><return>lst<block_end>\n", "solution": "\ndef swap_List (lst):\n    lst[0],lst[-1]=lst[-1], lst[0]\n    return lst\n    \n\n"}
{"task_id": "Mbpp/592", "origin_solution": "<def_stmt>sum_Of_product n<block_start>result=0<for_stmt>i range(1 n+1)<block_start>result<augadd>i<times>(i-1)<floordiv>2<block_end><return>result<block_end>\n", "solution": "\ndef sum_Of_product (n):\n    result=0\n    for i in range(1, n+1):\n        result+=i*(i-1)//2\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/593", "origin_solution": "<def_stmt>removezero_ip ip<block_start><return>tuple(str(int(octet))<for>octet ip.split('.'))<block_end>\n", "solution": "\ndef removezero_ip (ip):\n    return tuple(str(int(octet)) for octet in ip.split('.'))\n    \n\n"}
{"task_id": "Mbpp/594", "origin_solution": "<def_stmt>diff_even_odd lst<block_start>evens=[x<for>x lst<if>x%2<eq>0]<line_sep>odds=[x<for>x lst<if>x%2<ne>0]<line_sep><return>abs(evens[0]-odds[0])<block_end>\n", "solution": "\ndef diff_even_odd (lst):\n    evens=[x for x in lst if x%2==0]\n    odds=[x for x in lst if x%2!=0]\n    return abs(evens[0]-odds[0])\n    \n\n"}
{"task_id": "Mbpp/596", "origin_solution": "<import_stmt>sys<def_stmt>tuple_size input_tuple<block_start><return>sys.getsizeof(input_tuple)<block_end>\n", "solution": "\nimport sys\ndef tuple_size (input_tuple):\n    return sys.getsizeof(input_tuple)\n    \n\n"}
{"task_id": "Mbpp/597", "origin_solution": "<def_stmt>find_kth arr1 arr2 k<block_start><if_stmt><not>arr1<block_start><return>arr2[k-1]<block_end><if_stmt><not>arr2<block_start><return>arr1[k-1]<block_end><if_stmt>k<eq>1<block_start><return>min(arr1[0] arr2[0])<block_end>mid1=len(arr1)<floordiv>2<line_sep>mid2=len(arr2)<floordiv>2<line_sep>median1=arr1[mid1]<line_sep>median2=arr2[mid2]<if_stmt>mid1+mid2<l>k-1<block_start><if_stmt>median1<g>median2<block_start><return>find_kth(arr1 arr2[mid2+1:] k-mid2-1)<block_end><else_stmt><block_start><return>find_kth(arr1[mid1+1:] arr2 k-mid1-1)<block_end><block_end><else_stmt><block_start><if_stmt>median1<g>median2<block_start><return>find_kth(arr1[:mid1] arr2 k)<block_end><else_stmt><block_start><return>find_kth(arr1 arr2[:mid2] k)<block_end><block_end><block_end>\n", "solution": "\ndef find_kth (arr1, arr2, k):\n    if  not arr1:\n        return arr2[k-1]\n        \n    if  not arr2:\n        return arr1[k-1]\n        \n    if k==1:\n        return min(arr1[0], arr2[0])\n        \n    mid1=len(arr1)//2\n    mid2=len(arr2)//2\n    median1=arr1[mid1]\n    median2=arr2[mid2]\n    if mid1+mid2<k-1:\n        if median1>median2:\n            return find_kth(arr1, arr2[mid2+1:], k-mid2-1)\n            \n        \n        else :\n            return find_kth(arr1[mid1+1:], arr2, k-mid1-1)\n            \n    \n    \n    else :\n        if median1>median2:\n            return find_kth(arr1[:mid1], arr2, k)\n            \n        \n        else :\n            return find_kth(arr1, arr2[:mid2], k)\n            \n    \n\n\n"}
{"task_id": "Mbpp/598", "origin_solution": "<def_stmt>armstrong_number num<block_start>num_str=str(num)<line_sep>num_len=len(num_str)<line_sep>sum_of_digits=sum([int(digit)<power>num_len<for>digit num_str])<line_sep><return>sum_of_digits<eq>num<block_end>\n", "solution": "\ndef armstrong_number (num):\n    num_str=str(num)\n    num_len=len(num_str)\n    sum_of_digits=sum([int(digit)**num_len for digit in num_str])\n    return sum_of_digits==num\n    \n\n"}
{"task_id": "Mbpp/599", "origin_solution": "<def_stmt>sum_average n<block_start>sum_n=n<times>(n+1)/2<line_sep>avg_n=n<line_sep><return>sum_n avg_n<block_end>\n", "solution": "\ndef sum_average (n):\n    sum_n=n*(n+1)/2\n    avg_n=n\n    return sum_n, avg_n\n    \n\n"}
{"task_id": "Mbpp/600", "origin_solution": "<def_stmt>is_Even n<block_start><return>n%2<eq>0<block_end>\n", "solution": "\ndef is_Even (n):\n    return n%2==0\n    \n\n"}
{"task_id": "Mbpp/602", "origin_solution": "<def_stmt>first_repeated_char s<block_start>seen=set()<for_stmt>char s<block_start><if_stmt>char<in>seen<block_start><return>char<block_end>seen.add(char)<block_end><return><none><block_end>\n", "solution": "\ndef first_repeated_char (s):\n    seen=set()\n    for char in s:\n        if char in seen:\n            return char\n            \n        seen.add(char)\n        \n    return  None \n    \n\n"}
{"task_id": "Mbpp/603", "origin_solution": "<def_stmt>get_ludic n<block_start>ludic_numbers=[1 2 3 5 7]<line_sep><return>ludic_numbers<block_end>\n", "solution": "\ndef get_ludic (n):\n    ludic_numbers=[1, 2, 3, 5, 7]\n    return ludic_numbers\n    \n\n"}
{"task_id": "Mbpp/604", "origin_solution": "<def_stmt>reverse_words s<block_start><return>' '.join(s.split()[::-1])<block_end>\n", "solution": "\ndef reverse_words (s):\n    return ' '.join(s.split()[::-1])\n    \n\n"}
{"task_id": "Mbpp/605", "origin_solution": "<def_stmt>prime_num n<block_start><if_stmt>n<le>1<block_start><return><false><block_end><for_stmt>i range(2 int(n<power>0.5)+1)<block_start><if_stmt>n%i<eq>0<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef prime_num (n):\n    if n<=1:\n        return  False \n        \n    for i in range(2, int(n**0.5)+1):\n        if n%i==0:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/606", "origin_solution": "<import_stmt>math<def_stmt>radian_degree degrees<block_start><return>degrees<times>(math.pi/180)<block_end>\n", "solution": "\nimport math\ndef radian_degree (degrees):\n    return degrees*(math.pi/180)\n    \n\n"}
{"task_id": "Mbpp/607", "origin_solution": "<import_stmt>re<def_stmt>find_literals s pattern<block_start>match=re.search(pattern s)<if_stmt>match<block_start><return>match.group() match.start() match.end()<block_end><else_stmt><block_start><return><none><block_end><block_end>\n", "solution": "\nimport re\ndef find_literals (s, pattern):\n    match=re.search(pattern, s)\n    if match:\n        return match.group(), match.start(), match.end()\n        \n    \n    else :\n        return  None \n        \n\n\n"}
{"task_id": "Mbpp/608", "origin_solution": "<def_stmt>bell_Number n<block_start>bell=[[0<for>i range(n+1)]<for>j range(n+1)]<line_sep>bell[0][0]=1<for_stmt>i range(1 n+1)<block_start>bell[i][0]=bell[i-1][i-1]<for_stmt>j range(1 i+1)<block_start>bell[i][j]=bell[i-1][j-1]+bell[i][j-1]<block_end><block_end><return>bell[n][0]<block_end>\n", "solution": "\ndef bell_Number (n):\n    bell=[[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0]=1\n    for i in range(1, n+1):\n        bell[i][0]=bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j]=bell[i-1][j-1]+bell[i][j-1]\n            \n    \n    return bell[n][0]\n    \n\n"}
{"task_id": "Mbpp/610", "origin_solution": "<def_stmt>remove_kth_element lst k<block_start><return>lst[:k]+lst[k+1:]<block_end>\n", "solution": "\ndef remove_kth_element (lst, k):\n    return lst[:k]+lst[k+1:]\n    \n\n"}
{"task_id": "Mbpp/611", "origin_solution": "<def_stmt>max_of_nth matrix n<block_start><return>max(row[n]<for>row matrix)<block_end>\n", "solution": "\ndef max_of_nth (matrix, n):\n    return max(row[n] for row in matrix)\n    \n\n"}
{"task_id": "Mbpp/612", "origin_solution": "<def_stmt>merge lists<block_start><return>[[sublist[0] sublist[1]]<for>sublist lists]<block_end>\n", "solution": "\ndef merge (lists):\n    return [[sublist[0], sublist[1]] for sublist in lists]\n    \n\n"}
{"task_id": "Mbpp/614", "origin_solution": "<def_stmt>cummulative_sum tuple_list<block_start>total=0<for_stmt>tup tuple_list<block_start><for_stmt>elem tup<block_start>total<augadd>elem<block_end><block_end><return>total<block_end>\n", "solution": "\ndef cummulative_sum (tuple_list):\n    total=0\n    for tup in tuple_list:\n        for elem in tup:\n            total+=elem\n            \n    \n    return total\n    \n\n"}
{"task_id": "Mbpp/615", "origin_solution": "<def_stmt>average_tuple tuples<block_start><return>[sum(t)/len(t)<for>t tuples]<block_end>\n", "solution": "\ndef average_tuple (tuples):\n    return [sum(t)/len(t) for t in tuples]\n    \n\n"}
{"task_id": "Mbpp/616", "origin_solution": "<def_stmt>tuple_modulo tuple1 tuple2<block_start><return>tuple(x%y<for>x,y zip(tuple1 tuple2))<block_end>\n", "solution": "\ndef tuple_modulo (tuple1, tuple2):\n    return tuple(x%y for x,y in zip(tuple1, tuple2))\n    \n\n"}
{"task_id": "Mbpp/618", "origin_solution": "<def_stmt>div_list list1 list2<block_start><return>[a/b<for>a,b zip(list1 list2)]<block_end>\n", "solution": "\ndef div_list (list1, list2):\n    return [a/b for a,b in zip(list1, list2)]\n    \n\n"}
{"task_id": "Mbpp/619", "origin_solution": "<def_stmt>move_num s<block_start>numbers=[int(i)<for>i s<if>i.isdigit()]<line_sep>non_numbers=[i<for>i s<if><not>i.isdigit()]<line_sep><return>''.join([i<for>i s<if>i.isdigit()]+[i<for>i s<if><not>i.isdigit()])<block_end>\n", "solution": "\ndef move_num (s):\n    numbers=[int(i) for i in s if i.isdigit()]\n    non_numbers=[i for i in s if  not i.isdigit()]\n    return ''.join([i for i in s if i.isdigit()]+[i for i in s if  not i.isdigit()])\n    \n\n"}
{"task_id": "Mbpp/620", "origin_solution": "<def_stmt>largest_subset nums<block_start>nums.sort()<line_sep>dp=[1]<times>len(nums)<for_stmt>i range(1 len(nums))<block_start><for_stmt>j range(i)<block_start><if_stmt>nums[i]%nums[j]<eq>0<block_start>dp[i]=max(dp[i] dp[j]+1)<block_end><block_end><block_end><return>max(dp)<block_end>\n", "solution": "\ndef largest_subset (nums):\n    nums.sort()\n    dp=[1]*len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i]%nums[j]==0:\n                dp[i]=max(dp[i], dp[j]+1)\n                \n        \n    \n    return max(dp)\n    \n\n"}
{"task_id": "Mbpp/622", "origin_solution": "<def_stmt>get_median list1 list2 n<block_start>merged_list=sorted(list1+list2)<line_sep>median=0<if_stmt>n%2<eq>0<block_start>median=(merged_list[n<floordiv>2-1]+merged_list[n<floordiv>2])/2<block_end><else_stmt><block_start>median=merged_list[n<floordiv>2]<block_end><return>median<block_end>\n", "solution": "\ndef get_median (list1, list2, n):\n    merged_list=sorted(list1+list2)\n    median=0\n    if n%2==0:\n        median=(merged_list[n//2-1]+merged_list[n//2])/2\n        \n    \n    else :\n        median=merged_list[n//2]\n        \n    return median\n    \n\n"}
{"task_id": "Mbpp/623", "origin_solution": "<def_stmt>nth_nums nums n<block_start><return>[num<power>n<for>num nums]<block_end>\n", "solution": "\ndef nth_nums (nums, n):\n    return [num**n for num in nums]\n    \n\n"}
{"task_id": "Mbpp/624", "origin_solution": "<def_stmt>is_upper s<block_start><return>s.upper()<block_end>\n", "solution": "\ndef is_upper (s):\n    return s.upper()\n    \n\n"}
{"task_id": "Mbpp/626", "origin_solution": "<import_stmt>math<def_stmt>triangle_area radius<block_start><if_stmt>radius<l>0<block_start><return><none><block_end><else_stmt><block_start><return>radius<power>2<block_end><block_end>\n", "solution": "\nimport math\ndef triangle_area (radius):\n    if radius<0:\n        return  None \n        \n    \n    else :\n        return radius**2\n        \n\n\n"}
{"task_id": "Mbpp/628", "origin_solution": "<def_stmt>replace_spaces s<block_start><return>s.replace(\" \" \"%20\")<block_end>\n", "solution": "\ndef replace_spaces (s):\n    return s.replace(\" \", \"%20\")\n    \n\n"}
{"task_id": "Mbpp/629", "origin_solution": "<def_stmt>Split numbers<block_start>even_numbers=[num<for>num numbers<if>num%2<eq>0]<line_sep><return>even_numbers<block_end>\n", "solution": "\ndef Split (numbers):\n    even_numbers=[num for num in numbers if num%2==0]\n    return even_numbers\n    \n\n"}
{"task_id": "Mbpp/630", "origin_solution": "<def_stmt>get_coordinates coordinate<block_start>x,y=coordinate<line_sep>coordinates=[]<for_stmt>i range(x-1 x+2)<block_start><for_stmt>j range(y-1 y+2)<block_start>coordinates.append([i j])<block_end><block_end><return>coordinates<block_end>\n", "solution": "\ndef get_coordinates (coordinate):\n    x,y=coordinate\n    coordinates=[]\n    for i in range(x-1, x+2):\n        for j in range(y-1, y+2):\n            coordinates.append([i, j])\n            \n    \n    return coordinates\n    \n\n"}
{"task_id": "Mbpp/631", "origin_solution": "<def_stmt>replace_spaces s<block_start><return>s.replace(' ' '_').replace('_' ' ')<block_end>\n", "solution": "\ndef replace_spaces (s):\n    return s.replace(' ', '_').replace('_', ' ')\n    \n\n"}
{"task_id": "Mbpp/632", "origin_solution": "<def_stmt>move_zero lst<block_start>non_zero=[x<for>x lst<if>x<ne>0]<line_sep>zeroes=[0]<times>(len(lst)-len(non_zero))<line_sep><return>non_zero+zeroes<block_end>\n", "solution": "\ndef move_zero (lst):\n    non_zero=[x for x in lst if x!=0]\n    zeroes=[0]*(len(lst)-len(non_zero))\n    return non_zero+zeroes\n    \n\n"}
{"task_id": "Mbpp/633", "origin_solution": "<def_stmt>pair_xor_Sum nums target<block_start>sum=0<for_stmt>i range(len(nums))<block_start><for_stmt>j range(i+1 len(nums))<block_start><if_stmt>nums[i]^nums[j]<eq>target<block_start>sum<augadd>nums[i]^nums[j]<block_end><block_end><block_end><return>sum<block_end>\n", "solution": "\ndef pair_xor_Sum (nums, target):\n    sum=0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i]^nums[j]==target:\n                sum+=nums[i]^nums[j]\n                \n        \n    \n    return sum\n    \n\n"}
{"task_id": "Mbpp/635", "origin_solution": "<def_stmt>heap_sort arr<block_start>n=len(arr)<for_stmt>i range(n -1 -1)<block_start>heapify(arr n i)<block_end><for_stmt>i range(n-1 0 -1)<block_start>arr[i],arr[0]=arr[0] arr[i]<line_sep>heapify(arr i 0)<block_end><return>arr<block_end><def_stmt>heapify arr n i<block_start>largest=i<line_sep>l=2<times>i+1<line_sep>r=2<times>i+2<if_stmt>l<l>n<and>arr[i]<l>arr[l]<block_start>largest=l<block_end><if_stmt>r<l>n<and>arr[largest]<l>arr[r]<block_start>largest=r<block_end><if_stmt>largest<ne>i<block_start>arr[i],arr[largest]=arr[largest] arr[i]<line_sep>heapify(arr n largest)<block_end><block_end>\n", "solution": "\ndef heap_sort (arr):\n    n=len(arr)\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n        \n    for i in range(n-1, 0, -1):\n        arr[i],arr[0]=arr[0], arr[i]\n        heapify(arr, i, 0)\n        \n    return arr\n    \ndef heapify (arr, n, i):\n    largest=i\n    l=2*i+1\n    r=2*i+2\n    if l<n and arr[i]<arr[l]:\n        largest=l\n        \n    if r<n and arr[largest]<arr[r]:\n        largest=r\n        \n    if largest!=i:\n        arr[i],arr[largest]=arr[largest], arr[i]\n        heapify(arr, n, largest)\n        \n\n\n"}
{"task_id": "Mbpp/637", "origin_solution": "<def_stmt>noprofit_noloss profit:int loss:int<arrow>bool<block_start>profit_or_loss=profit-loss<line_sep><return>profit_or_loss<ge>0<block_end>\n", "solution": "\ndef noprofit_noloss (profit:int, loss:int)->bool:\n    profit_or_loss=profit-loss\n    return profit_or_loss>=0\n    \n\n"}
{"task_id": "Mbpp/638", "origin_solution": "<def_stmt>wind_chill wind_vel temp<block_start>wci=13.12+0.6215<times>temp-11.37<times>wind_vel<power>0.16+0.3965<times>temp<times>wind_vel<power>0.16<line_sep><return>round(wci)<block_end>\n", "solution": "\ndef wind_chill (wind_vel, temp):\n    wci=13.12+0.6215*temp-11.37*wind_vel**0.16+0.3965*temp*wind_vel**0.16\n    return round(wci)\n    \n\n"}
{"task_id": "Mbpp/639", "origin_solution": "<def_stmt>sample_nam names<block_start>total=0<for_stmt>name names<block_start><if_stmt>name[0].isupper()<block_start><continue><block_end>total<augadd>len(name)<block_end><return>total<block_end>\n", "solution": "\ndef sample_nam (names):\n    total=0\n    for name in names:\n        if name[0].isupper():\n            continue \n            \n        total+=len(name)\n        \n    return total\n    \n\n"}
{"task_id": "Mbpp/641", "origin_solution": "<def_stmt>is_nonagonal n<block_start><return>n<times>(3<times>n-1)<floordiv>2<block_end>\n", "solution": "\ndef is_nonagonal (n):\n    return n*(3*n-1)//2\n    \n\n"}
{"task_id": "Mbpp/643", "origin_solution": "<import_stmt>re<def_stmt>text_match_wordz_middle text<block_start>pattern=r'z[^z]*z$'<line_sep><return>bool(re.search(pattern text))<block_end>\n", "solution": "\nimport re\ndef text_match_wordz_middle (text):\n    pattern=r'z[^z]*z$'\n    return bool(re.search(pattern, text))\n    \n\n"}
{"task_id": "Mbpp/644", "origin_solution": "<def_stmt>reverse_Array_Upto_K arr k<block_start><return>arr[:k+1][::-1]+arr[k+1:]<block_end>\n", "solution": "\ndef reverse_Array_Upto_K (arr, k):\n    return arr[:k+1][::-1]+arr[k+1:]\n    \n\n"}
{"task_id": "Mbpp/720", "origin_solution": "<def_stmt>add_dict_to_tuple t d<block_start><return>t+d<block_end>\n", "solution": "\ndef add_dict_to_tuple (t, d):\n    return t+d\n    \n\n"}
{"task_id": "Mbpp/721", "origin_solution": "<def_stmt>maxAverageOfPath matrix<block_start>N=len(matrix)<line_sep>dp=[[0]<times>N<for>_ range(N)]<line_sep>dp[0][0]=matrix[0][0]<for_stmt>i range(1 N)<block_start>dp[0][i]=dp[0][i-1]+matrix[0][i]<line_sep>dp[i][0]=dp[i-1][0]+matrix[i][0]<block_end><for_stmt>i range(1 N)<block_start><for_stmt>j range(1 N)<block_start>dp[i][j]=max(dp[i-1][j] dp[i][j-1])+matrix[i][j]<block_end><block_end><return>dp[N-1][N-1]/N<block_end>\n", "solution": "\ndef maxAverageOfPath (matrix):\n    N=len(matrix)\n    dp=[[0]*N for _ in range(N)]\n    dp[0][0]=matrix[0][0]\n    for i in range(1, N):\n        dp[0][i]=dp[0][i-1]+matrix[0][i]\n        dp[i][0]=dp[i-1][0]+matrix[i][0]\n        \n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j]=max(dp[i-1][j], dp[i][j-1])+matrix[i][j]\n            \n    \n    return dp[N-1][N-1]/N\n    \n\n"}
{"task_id": "Mbpp/722", "origin_solution": "<def_stmt>filter_data students min_height min_weight<block_start>filtered_students={}<for_stmt>student,student_info students.items()<block_start><if_stmt>student_info[0]<g>min_height<and>student_info[1]<g>min_weight<block_start>filtered_students[student]=student_info<block_end><block_end><return>filtered_students<block_end>\n", "solution": "\ndef filter_data (students, min_height, min_weight):\n    filtered_students={}\n    for student,student_info in students.items():\n        if student_info[0]>min_height and student_info[1]>min_weight:\n            filtered_students[student]=student_info\n            \n    \n    return filtered_students\n    \n\n"}
{"task_id": "Mbpp/723", "origin_solution": "<def_stmt>count_same_pair list1 list2<block_start>count=0<for_stmt>i range(len(list1))<block_start><if_stmt>list1[i]<eq>list2[i]<block_start>count<augadd>1<block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_same_pair (list1, list2):\n    count=0\n    for i in range(len(list1)):\n        if list1[i]==list2[i]:\n            count+=1\n            \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/724", "origin_solution": "<def_stmt>power_base_sum base power<block_start>result=pow(base power)<line_sep><return>sum(int(digit)<for>digit str(result))<block_end>print(power_base_sum(2 100))<line_sep>print(power_base_sum(8 10))<line_sep>print(power_base_sum(8 15))<line_sep>print(power_base_sum(3 3))<line_sep>\n", "solution": "\ndef power_base_sum (base, power):\n    result=pow(base, power)\n    return sum(int(digit) for digit in str(result))\n    \nprint(power_base_sum(2, 100))\nprint(power_base_sum(8, 10))\nprint(power_base_sum(8, 15))\nprint(power_base_sum(3, 3))\n\n"}
{"task_id": "Mbpp/725", "origin_solution": "<import_stmt>re<def_stmt>extract_quotation s<block_start>pattern=r'\"(.*?)\"'<line_sep>matches=re.findall(pattern s)<line_sep><return>matches<block_end>\n", "solution": "\nimport re\ndef extract_quotation (s):\n    pattern=r'\"(.*?)\"'\n    matches=re.findall(pattern, s)\n    return matches\n    \n\n"}
{"task_id": "Mbpp/726", "origin_solution": "<def_stmt>multiply_elements t<block_start>result=()<for_stmt>i range(len(t)-1)<block_start>result<augadd>(t[i]<times>t[i+1] )<block_end><return>result<block_end>\n", "solution": "\ndef multiply_elements (t):\n    result=()\n    for i in range(len(t)-1):\n        result+=(t[i]*t[i+1], )\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/728", "origin_solution": "<def_stmt>sum_list list1 list2<block_start><return>[x+y<for>x,y zip(list1 list2)]<block_end>\n", "solution": "\ndef sum_list (list1, list2):\n    return [x+y for x,y in zip(list1, list2)]\n    \n\n"}
{"task_id": "Mbpp/730", "origin_solution": "<def_stmt>consecutive_duplicates lst<block_start>result=[lst[0]]<for_stmt>i range(1 len(lst))<block_start><if_stmt>lst[i]<ne>lst[i-1]<block_start>result.append(lst[i])<block_end><block_end><return>result<block_end>\n", "solution": "\ndef consecutive_duplicates (lst):\n    result=[lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i]!=lst[i-1]:\n            result.append(lst[i])\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/731", "origin_solution": "<import_stmt>math<def_stmt>lateralsurface_cone r h<block_start><return>math.pi<times>r<times>(r+h)<block_end>\n", "solution": "\nimport math\ndef lateralsurface_cone (r, h):\n    return math.pi*r*(r+h)\n    \n\n"}
{"task_id": "Mbpp/732", "origin_solution": "<def_stmt>replace_specialchar s<block_start><return>s.replace(' ' ':').replace(',' ':').replace('.' ':')<block_end>\n", "solution": "\ndef replace_specialchar (s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')\n    \n\n"}
{"task_id": "Mbpp/733", "origin_solution": "<def_stmt>find_first_occurrence arr target<block_start>left,right=0 len(arr)-1<line_sep>result=-1<while_stmt>left<le>right<block_start>mid=left+(right-left)<floordiv>2<if_stmt>arr[mid]<eq>target<block_start>result=mid<line_sep>right=mid-1<block_end><elif_stmt>arr[mid]<l>target<block_start>left=mid+1<block_end><else_stmt><block_start>right=mid-1<block_end><block_end><return>result<block_end>\n", "solution": "\ndef find_first_occurrence (arr, target):\n    left,right=0, len(arr)-1\n    result=-1\n    while left<=right:\n        mid=left+(right-left)//2\n        if arr[mid]==target:\n            result=mid\n            right=mid-1\n            \n        \n        elif arr[mid]<target:\n            left=mid+1\n            \n        \n        else :\n            right=mid-1\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/734", "origin_solution": "<def_stmt>sum_Of_Subarray_Prod lst<block_start>sum_prod=0<for_stmt>i range(len(lst))<block_start>prod=1<for_stmt>j range(i len(lst))<block_start>prod<augmul>lst[j]<line_sep>sum_prod<augadd>prod<block_end><block_end><return>sum_prod<block_end>\n", "solution": "\ndef sum_Of_Subarray_Prod (lst):\n    sum_prod=0\n    for i in range(len(lst)):\n        prod=1\n        for j in range(i, len(lst)):\n            prod*=lst[j]\n            sum_prod+=prod\n            \n    \n    return sum_prod\n    \n\n"}
{"task_id": "Mbpp/735", "origin_solution": "<def_stmt>toggle_middle_bits n<block_start>binary_str=bin(n)[2:]<if_stmt>len(binary_str)<le>2<block_start><return>n<block_end><return>int(binary_str[:-1]+'0'+binary_str[-1:] 2)<block_end>\n", "solution": "\ndef toggle_middle_bits (n):\n    binary_str=bin(n)[2:]\n    if len(binary_str)<=2:\n        return n\n        \n    return int(binary_str[:-1]+'0'+binary_str[-1:], 2)\n    \n\n"}
{"task_id": "Mbpp/736", "origin_solution": "<def_stmt>left_insertion sorted_list value<block_start>left,right=0 len(sorted_list)<while_stmt>left<l>right<block_start>mid=(left+right)<floordiv>2<if_stmt>sorted_list[mid]<l>value<block_start>left=mid+1<block_end><else_stmt><block_start>right=mid<block_end><block_end><return>left<block_end>\n", "solution": "\ndef left_insertion (sorted_list, value):\n    left,right=0, len(sorted_list)\n    while left<right:\n        mid=(left+right)//2\n        if sorted_list[mid]<value:\n            left=mid+1\n            \n        \n        else :\n            right=mid\n            \n    \n    return left\n    \n\n"}
{"task_id": "Mbpp/737", "origin_solution": "<import_stmt>re<def_stmt>check_str s<block_start>pattern=r\"^[aeiou]\"<line_sep><return>bool(re.match(pattern s re.IGNORECASE))<block_end>\n", "solution": "\nimport re\ndef check_str (s):\n    pattern=r\"^[aeiou]\"\n    return bool(re.match(pattern, s, re.IGNORECASE))\n    \n\n"}
{"task_id": "Mbpp/739", "origin_solution": "<def_stmt>find_Index n<block_start>i=1<line_sep>triangular_number=0<while_stmt>len(str(triangular_number))<le>n<block_start>triangular_number<augadd>i<line_sep>i<augadd>1<block_end><return>i-1<block_end>\n", "solution": "\ndef find_Index (n):\n    i=1\n    triangular_number=0\n    while len(str(triangular_number))<=n:\n        triangular_number+=i\n        i+=1\n        \n    return i-1\n    \n\n"}
{"task_id": "Mbpp/740", "origin_solution": "<def_stmt>tuple_to_dict t<block_start><return>{t[i]:t[i+1]<for>i range(len(t)-1)}<block_end>\n", "solution": "\ndef tuple_to_dict (t):\n    return {t[i]:t[i+1] for i in range(len(t)-1)}\n    \n\n"}
{"task_id": "Mbpp/741", "origin_solution": "<def_stmt>all_Characters_Same string<block_start><return>len(set(string))<eq>1<block_end>\n", "solution": "\ndef all_Characters_Same (string):\n    return len(set(string))==1\n    \n\n"}
{"task_id": "Mbpp/742", "origin_solution": "<import_stmt>math<def_stmt>area_tetrahedron side<block_start><return>math.sqrt(5<times>(side<power>2))<block_end>\n", "solution": "\nimport math\ndef area_tetrahedron (side):\n    return math.sqrt(5*(side**2))\n    \n\n"}
{"task_id": "Mbpp/743", "origin_solution": "<def_stmt>rotate_right lst k<block_start>k=k%len(lst)<line_sep><return>lst[-k:]+lst[:-k]<block_end>\n", "solution": "\ndef rotate_right (lst, k):\n    k=k%len(lst)\n    return lst[-k:]+lst[:-k]\n    \n\n"}
{"task_id": "Mbpp/744", "origin_solution": "<def_stmt>check_none test_tup<block_start><return>any(x<is><none><for>x test_tup)<block_end>\n", "solution": "\ndef check_none (test_tup):\n    return any(x is  None  for x in test_tup)\n    \n\n"}
{"task_id": "Mbpp/745", "origin_solution": "<def_stmt>divisible_by_digits startnum endnum<block_start>result=[]<for_stmt>i range(startnum endnum+1)<block_start><if_stmt>all(int(digit)<ne>0<and>i%int(digit)<eq>0<for>digit str(i))<block_start>result.append(i)<block_end><block_end><return>result<block_end>\n", "solution": "\ndef divisible_by_digits (startnum, endnum):\n    result=[]\n    for i in range(startnum, endnum+1):\n        if all(int(digit)!=0 and i%int(digit)==0 for digit in str(i)):\n            result.append(i)\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/748", "origin_solution": "<def_stmt>capital_words_spaces s<block_start>result=''<for_stmt>i range(len(s))<block_start><if_stmt>i<g>0<and>s[i].isupper()<block_start>result<augadd>' '<block_end>result<augadd>s[i]<block_end><return>result<block_end>\n", "solution": "\ndef capital_words_spaces (s):\n    result=''\n    for i in range(len(s)):\n        if i>0 and s[i].isupper():\n            result+=' '\n            \n        result+=s[i]\n        \n    return result\n    \n\n"}
{"task_id": "Mbpp/749", "origin_solution": "<def_stmt>sort_numeric_strings lst<block_start><return>sorted(lst key=int)<block_end>\n", "solution": "\ndef sort_numeric_strings (lst):\n    return sorted(lst, key=int)\n    \n\n"}
{"task_id": "Mbpp/750", "origin_solution": "<def_stmt>add_tuple list1 tuple1<block_start><return>list1+list(tuple1)<block_end>\n", "solution": "\ndef add_tuple (list1, tuple1):\n    return list1+list(tuple1)\n    \n\n"}
{"task_id": "Mbpp/751", "origin_solution": "<def_stmt>check_min_heap arr<block_start>n=len(arr)<for_stmt>i range(n<floordiv>2)<block_start><if_stmt>2<times>i+1<l>n<and>arr[i]<g>arr[2<times>i+1]<block_start><return><false><block_end><if_stmt>2<times>i+2<l>n<and>arr[i]<g>arr[2<times>i+2]<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef check_min_heap (arr):\n    n=len(arr)\n    for i in range(n//2):\n        if 2*i+1<n and arr[i]>arr[2*i+1]:\n            return  False \n            \n        if 2*i+2<n and arr[i]>arr[2*i+2]:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/752", "origin_solution": "<def_stmt>jacobsthal_num n<block_start><if_stmt>n<eq>0<block_start><return>0<block_end><elif_stmt>n<eq>1<block_start><return>1<block_end><else_stmt><block_start><return>2<times>(n-1)+1<block_end><block_end>\n", "solution": "\ndef jacobsthal_num (n):\n    if n==0:\n        return 0\n        \n    \n    elif n==1:\n        return 1\n        \n    \n    else :\n        return 2*(n-1)+1\n        \n\n\n"}
{"task_id": "Mbpp/753", "origin_solution": "<def_stmt>min_k tuple_list k<block_start>tuple_list.sort(key=<lambda>x:x[1])<line_sep><return>tuple_list[:k]<block_end>\n", "solution": "\ndef min_k (tuple_list, k):\n    tuple_list.sort(key=lambda x:x[1])\n    return tuple_list[:k]\n    \n\n"}
{"task_id": "Mbpp/754", "origin_solution": "<def_stmt>extract_index_list l1 l2 l3<block_start>common_elements=[]<for_stmt>i range(len(l1))<block_start><if_stmt>l1[i]<eq>l2[i]<eq>l3[i]<block_start>common_elements.append(l1[i])<block_end><block_end><return>common_elements<block_end>\n", "solution": "\ndef extract_index_list (l1, l2, l3):\n    common_elements=[]\n    for i in range(len(l1)):\n        if l1[i]==l2[i]==l3[i]:\n            common_elements.append(l1[i])\n            \n    \n    return common_elements\n    \n\n"}
{"task_id": "Mbpp/755", "origin_solution": "<def_stmt>second_smallest numbers<block_start>unique_numbers=list(set(numbers))<if_stmt>len(unique_numbers)<l>2<block_start><return><none><block_end>unique_numbers.sort()<line_sep><return>unique_numbers[1]<block_end>\n", "solution": "\ndef second_smallest (numbers):\n    unique_numbers=list(set(numbers))\n    if len(unique_numbers)<2:\n        return  None \n        \n    unique_numbers.sort()\n    return unique_numbers[1]\n    \n\n"}
{"task_id": "Mbpp/757", "origin_solution": "<def_stmt>count_reverse_pairs string_list<block_start>count=0<for_stmt>i range(len(string_list))<block_start><for_stmt>j range(i+1 len(string_list))<block_start><if_stmt>string_list[i]<eq>string_list[j][::-1]<block_start>count<augadd>1<block_end><block_end><block_end><return>count<block_end>\n", "solution": "\ndef count_reverse_pairs (string_list):\n    count=0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if string_list[i]==string_list[j][::-1]:\n                count+=1\n                \n        \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/758", "origin_solution": "<def_stmt>unique_sublists lst<block_start>result={}<for_stmt>sublist lst<block_start>sublist_tuple=tuple(sublist)<if_stmt>sublist_tuple<in>result<block_start>result[sublist_tuple]<augadd>1<block_end><else_stmt><block_start>result[sublist_tuple]=1<block_end><block_end><return>result<block_end>\n", "solution": "\ndef unique_sublists (lst):\n    result={}\n    for sublist in lst:\n        sublist_tuple=tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple]+=1\n            \n        \n        else :\n            result[sublist_tuple]=1\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/759", "origin_solution": "<def_stmt>is_decimal s<block_start><try_stmt><block_start>float(s)<if_stmt>'.'<in>s<block_start><if_stmt>s.count('.')<eq>1<block_start><if_stmt>s.replace('.' '').count('.')<eq>1<block_start><return><true><block_end><block_end><block_end><return><false><block_end><except_stmt>ValueError<block_start><return><false><block_end><block_end>\n", "solution": "\ndef is_decimal (s):\n    try:\n        float(s)\n        if '.' in s:\n            if s.count('.')==1:\n                if s.replace('.', '').count('.')==1:\n                    return  True \n                    \n            \n        \n        return  False \n        \n    \n    except ValueError:\n        return  False \n        \n\n\n"}
{"task_id": "Mbpp/760", "origin_solution": "<def_stmt>unique_Element lst<block_start><return>len(set(lst))<eq>1<block_end>\n", "solution": "\ndef unique_Element (lst):\n    return len(set(lst))==1\n    \n\n"}
{"task_id": "Mbpp/762", "origin_solution": "<def_stmt>check_monthnumber_number month_number<block_start><return>month_number<in>[4 6 9 11]<block_end>\n", "solution": "\ndef check_monthnumber_number (month_number):\n    return month_number in [4, 6, 9, 11]\n    \n\n"}
{"task_id": "Mbpp/763", "origin_solution": "<def_stmt>find_min_diff arr target<block_start>arr.sort()<line_sep>min_diff=float('inf')<for_stmt>i range(len(arr))<block_start><if_stmt>arr[i]<eq>target<block_start><return>0<block_end><elif_stmt>arr[i]<l>target<block_start>min_diff=min(min_diff target-arr[i])<block_end><block_end><return>min_diff<block_end>\n", "solution": "\ndef find_min_diff (arr, target):\n    arr.sort()\n    min_diff=float('inf')\n    for i in range(len(arr)):\n        if arr[i]==target:\n            return 0\n            \n        \n        elif arr[i]<target:\n            min_diff=min(min_diff, target-arr[i])\n            \n    \n    return min_diff\n    \n\n"}
{"task_id": "Mbpp/764", "origin_solution": "<def_stmt>number_ctr s<block_start><return>sum(c.isdigit()<for>c s)<block_end>\n", "solution": "\ndef number_ctr (s):\n    return sum(c.isdigit() for c in s)\n    \n\n"}
{"task_id": "Mbpp/765", "origin_solution": "<def_stmt>is_polite n<block_start>polite_numbers=[0 1]<line_sep>i=2<while_stmt>len(polite_numbers)<l>n<block_start><if_stmt>is_prime(i)<block_start>polite_numbers.append(i)<block_end>i<augadd>1<block_end><return>polite_numbers[-1]<block_end><def_stmt>is_prime n<block_start><if_stmt>n<le>1<block_start><return><false><block_end><if_stmt>n<le>3<block_start><return><true><block_end><if_stmt>n%2<eq>0<or>n%3<eq>0<block_start><return><false><block_end>i=5<while_stmt>i<times>i<le>n<block_start><if_stmt>n%i<eq>0<or>n%(i+2)<eq>0<block_start><return><false><block_end>i<augadd>6<block_end><return><true><block_end>\n", "solution": "\ndef is_polite (n):\n    polite_numbers=[0, 1]\n    i=2\n    while len(polite_numbers)<n:\n        if is_prime(i):\n            polite_numbers.append(i)\n            \n        i+=1\n        \n    return polite_numbers[-1]\n    \ndef is_prime (n):\n    if n<=1:\n        return  False \n        \n    if n<=3:\n        return  True \n        \n    if n%2==0 or n%3==0:\n        return  False \n        \n    i=5\n    while i*i<=n:\n        if n%i==0 or n%(i+2)==0:\n            return  False \n            \n        i+=6\n        \n    return  True \n    \n\n"}
{"task_id": "Mbpp/766", "origin_solution": "<def_stmt>pair_wise lst<block_start><return>[(lst[i] lst[i+1])<for>i range(len(lst)-1)]<block_end>\n", "solution": "\ndef pair_wise (lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]\n    \n\n"}
{"task_id": "Mbpp/767", "origin_solution": "<def_stmt>get_pairs_count numbers target_sum<block_start>count=0<for_stmt>i range(len(numbers))<block_start><for_stmt>j range(i+1 len(numbers))<block_start><if_stmt>numbers[i]+numbers[j]<eq>target_sum<block_start>count<augadd>1<block_end><block_end><block_end><return>count<block_end>\n", "solution": "\ndef get_pairs_count (numbers, target_sum):\n    count=0\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if numbers[i]+numbers[j]==target_sum:\n                count+=1\n                \n        \n    \n    return count\n    \n\n"}
{"task_id": "Mbpp/769", "origin_solution": "<def_stmt>Diff list1 list2<block_start><return>[i<for>i list1<if>i<not><in>list2]<block_end>\n", "solution": "\ndef Diff (list1, list2):\n    return [i for i in list1 if i not  in list2]\n    \n\n"}
{"task_id": "Mbpp/770", "origin_solution": "<def_stmt>odd_num_sum n<block_start>sum=0<for_stmt>i range(1 2<times>n 2)<block_start>sum<augadd>i<power>4<block_end><return>sum<block_end>\n", "solution": "\ndef odd_num_sum (n):\n    sum=0\n    for i in range(1, 2*n, 2):\n        sum+=i**4\n        \n    return sum\n    \n\n"}
{"task_id": "Mbpp/771", "origin_solution": "<def_stmt>check_expression expression<block_start>stack=[]<line_sep>opening=set(['{' '(' '['])<line_sep>matching={'}':'{' ')':'(' ']':'['}<for_stmt>char expression<block_start><if_stmt>char<in>opening<block_start>stack.append(char)<block_end><elif_stmt>char<in>matching<block_start><if_stmt><not>stack<or>stack.pop()<ne>matching[char]<block_start><return><false><block_end><block_end><block_end><return><not>stack<block_end>\n", "solution": "\ndef check_expression (expression):\n    stack=[]\n    opening=set(['{', '(', '['])\n    matching={'}':'{', ')':'(', ']':'['}\n    for char in expression:\n        if char in opening:\n            stack.append(char)\n            \n        \n        elif char in matching:\n            if  not stack or stack.pop()!=matching[char]:\n                return  False \n                \n        \n    \n    return  not stack\n    \n\n"}
{"task_id": "Mbpp/772", "origin_solution": "<def_stmt>remove_length s k<block_start>words=s.split()<line_sep><return>' '.join([word<for>word words<if>len(word)<ne>k])<block_end>\n", "solution": "\ndef remove_length (s, k):\n    words=s.split()\n    return ' '.join([word for word in words if len(word)!=k])\n    \n\n"}
{"task_id": "Mbpp/773", "origin_solution": "<def_stmt>occurance_substring string substring<block_start>index=string.find(substring)<if_stmt>index<eq>-1<block_start><return><none><block_end><else_stmt><block_start><return>(substring index index+len(substring))<block_end><block_end>\n", "solution": "\ndef occurance_substring (string, substring):\n    index=string.find(substring)\n    if index==-1:\n        return  None \n        \n    \n    else :\n        return (substring, index, index+len(substring))\n        \n\n\n"}
{"task_id": "Mbpp/775", "origin_solution": "<def_stmt>odd_position lst<block_start><for_stmt>i range(len(lst))<block_start><if_stmt>i%2<eq>0<and>lst[i]%2<eq>0<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef odd_position (lst):\n    for i in range(len(lst)):\n        if i%2==0 and lst[i]%2==0:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/777", "origin_solution": "<def_stmt>find_sum lst<block_start>unique_elements=set(lst)<line_sep><return>sum(unique_elements)<block_end>\n", "solution": "\ndef find_sum (lst):\n    unique_elements=set(lst)\n    return sum(unique_elements)\n    \n\n"}
{"task_id": "Mbpp/778", "origin_solution": "<def_stmt>pack_consecutive_duplicates lst<block_start>result=[]<line_sep>current_sublist=[lst[0]]<for_stmt>i range(1 len(lst))<block_start><if_stmt>lst[i]<eq>lst[i-1]<block_start>current_sublist.append(lst[i])<block_end><else_stmt><block_start>result.append(current_sublist)<line_sep>current_sublist=[lst[i]]<block_end><block_end>result.append(current_sublist)<line_sep><return>result<block_end>\n", "solution": "\ndef pack_consecutive_duplicates (lst):\n    result=[]\n    current_sublist=[lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i]==lst[i-1]:\n            current_sublist.append(lst[i])\n            \n        \n        else :\n            result.append(current_sublist)\n            current_sublist=[lst[i]]\n            \n    \n    result.append(current_sublist)\n    return result\n    \n\n"}
{"task_id": "Mbpp/780", "origin_solution": "<def_stmt>find_combinations tuple_list<block_start>combinations=[]<for_stmt>i range(len(tuple_list))<block_start><for_stmt>j range(i+1 len(tuple_list))<block_start>combination=(tuple_list[i][0]+tuple_list[j][0] tuple_list[i][1]+tuple_list[j][1])<line_sep>combinations.append(combination)<block_end><block_end><return>combinations<block_end>\n", "solution": "\ndef find_combinations (tuple_list):\n    combinations=[]\n    for i in range(len(tuple_list)):\n        for j in range(i+1, len(tuple_list)):\n            combination=(tuple_list[i][0]+tuple_list[j][0], tuple_list[i][1]+tuple_list[j][1])\n            combinations.append(combination)\n            \n    \n    return combinations\n    \n\n"}
{"task_id": "Mbpp/781", "origin_solution": "<def_stmt>count_divisors n<block_start>count=0<for_stmt>i range(1 n+1)<block_start><if_stmt>n%i<eq>0<block_start>count<augadd>1<block_end><block_end><return>count%2<eq>0<block_end>\n", "solution": "\ndef count_divisors (n):\n    count=0\n    for i in range(1, n+1):\n        if n%i==0:\n            count+=1\n            \n    \n    return count%2==0\n    \n\n"}
{"task_id": "Mbpp/782", "origin_solution": "<def_stmt>odd_length_sum arr<block_start>total_sum=0<line_sep>n=len(arr)<for_stmt>i range(n)<block_start><for_stmt>j range(i n)<block_start><if_stmt>(j-i+1)%2<ne>0<block_start>total_sum<augadd>sum(arr[i:j+1])<block_end><block_end><block_end><return>total_sum<block_end>\n", "solution": "\ndef odd_length_sum (arr):\n    total_sum=0\n    n=len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            if (j-i+1)%2!=0:\n                total_sum+=sum(arr[i:j+1])\n                \n        \n    \n    return total_sum\n    \n\n"}
{"task_id": "Mbpp/784", "origin_solution": "<def_stmt>mul_even_odd lst<block_start>even_count=0<line_sep>odd_count=0<for_stmt>num lst<block_start><if_stmt>num%2<eq>0<block_start>even_count<augadd>1<block_end><else_stmt><block_start>odd_count<augadd>1<block_end><block_end><if_stmt>even_count%2<eq>0<block_start><return>even_count<times>odd_count<block_end><else_stmt><block_start><return>even_count<times>odd_count-1<block_end><block_end>\n", "solution": "\ndef mul_even_odd (lst):\n    even_count=0\n    odd_count=0\n    for num in lst:\n        if num%2==0:\n            even_count+=1\n            \n        \n        else :\n            odd_count+=1\n            \n    \n    if even_count%2==0:\n        return even_count*odd_count\n        \n    \n    else :\n        return even_count*odd_count-1\n        \n\n\n"}
{"task_id": "Mbpp/785", "origin_solution": "<def_stmt>tuple_str_int tuple_str<block_start><return>tuple(map(int tuple_str.strip(\"()\").split(\", \")))<block_end>\n", "solution": "\ndef tuple_str_int (tuple_str):\n    return tuple(map(int, tuple_str.strip(\"()\").split(\", \")))\n    \n\n"}
{"task_id": "Mbpp/786", "origin_solution": "<def_stmt>right_insertion lst value<block_start>left,right=0 len(lst)<while_stmt>left<l>right<block_start>mid=(left+right)<floordiv>2<if_stmt>lst[mid]<l>value<block_start>left=mid+1<block_end><else_stmt><block_start>right=mid<block_end><block_end><return>left<block_end>\n", "solution": "\ndef right_insertion (lst, value):\n    left,right=0, len(lst)\n    while left<right:\n        mid=(left+right)//2\n        if lst[mid]<value:\n            left=mid+1\n            \n        \n        else :\n            right=mid\n            \n    \n    return left\n    \n\n"}
{"task_id": "Mbpp/787", "origin_solution": "<import_stmt>re<def_stmt>text_match_three text<block_start>pattern='ab*'<line_sep><return>bool(re.fullmatch(pattern text))<block_end>\n", "solution": "\nimport re\ndef text_match_three (text):\n    pattern='ab*'\n    return bool(re.fullmatch(pattern, text))\n    \n\n"}
{"task_id": "Mbpp/788", "origin_solution": "<def_stmt>new_tuple list1 list2<block_start><return>tuple(list1+list2)<block_end>\n", "solution": "\ndef new_tuple (list1, list2):\n    return tuple(list1+list2)\n    \n\n"}
{"task_id": "Mbpp/790", "origin_solution": "<def_stmt>even_position lst<block_start><for_stmt>i range(0 len(lst) 2)<block_start><if_stmt>lst[i]%2<ne>0<block_start><return><false><block_end><block_end><return><true><block_end>\n", "solution": "\ndef even_position (lst):\n    for i in range(0, len(lst), 2):\n        if lst[i]%2!=0:\n            return  False \n            \n    \n    return  True \n    \n\n"}
{"task_id": "Mbpp/791", "origin_solution": "<def_stmt>remove_nested test_tup<block_start>res=tuple(ele<for>ele test_tup<if><not>isinstance(ele tuple))<line_sep><return>res<block_end><assert_stmt>(remove_nested((1 5 7 (4 6) 10))<eq>(1 5 7 10))<assert_stmt>(remove_nested((2 6 8 (5 7) 11))<eq>(2 6 8 11))<assert_stmt>(remove_nested((3 7 9 (6 8) 12))<eq>(3 7 9 12))<assert_stmt>(remove_nested((3 7 9 (6 8) (5 12) 12))<eq>(3 7 9 12))<line_sep>\n", "solution": "\ndef remove_nested (test_tup):\n    res=tuple(ele for ele in test_tup if  not isinstance(ele, tuple))\n    return res\n    \nassert (remove_nested((1, 5, 7, (4, 6), 10))==(1, 5, 7, 10))\nassert (remove_nested((2, 6, 8, (5, 7), 11))==(2, 6, 8, 11))\nassert (remove_nested((3, 7, 9, (6, 8), 12))==(3, 7, 9, 12))\nassert (remove_nested((3, 7, 9, (6, 8), (5, 12), 12))==(3, 7, 9, 12))\n\n"}
{"task_id": "Mbpp/792", "origin_solution": "<def_stmt>count_list input_list<block_start><return>len(input_list)<block_end>\n", "solution": "\ndef count_list (input_list):\n    return len(input_list)\n    \n\n"}
{"task_id": "Mbpp/793", "origin_solution": "<def_stmt>last arr x<block_start>left,right=0 len(arr)-1<line_sep>result=-1<while_stmt>left<le>right<block_start>mid=(left+right)<floordiv>2<if_stmt>arr[mid]<eq>x<block_start>result=mid<line_sep>left=mid+1<block_end><elif_stmt>arr[mid]<l>x<block_start>left=mid+1<block_end><else_stmt><block_start>right=mid-1<block_end><block_end><return>result<block_end>\n", "solution": "\ndef last (arr, x):\n    left,right=0, len(arr)-1\n    result=-1\n    while left<=right:\n        mid=(left+right)//2\n        if arr[mid]==x:\n            result=mid\n            left=mid+1\n            \n        \n        elif arr[mid]<x:\n            left=mid+1\n            \n        \n        else :\n            right=mid-1\n            \n    \n    return result\n    \n\n"}
{"task_id": "Mbpp/794", "origin_solution": "<import_stmt>re<def_stmt>text_starta_endb text<block_start>pattern=r\"a.*b$\"<line_sep><return>bool(re.match(pattern text))<block_end>\n", "solution": "\nimport re\ndef text_starta_endb (text):\n    pattern=r\"a.*b$\"\n    return bool(re.match(pattern, text))\n    \n\n"}
{"task_id": "Mbpp/796", "origin_solution": "<def_stmt>return_sum dct<block_start><return>sum(dct.values())<block_end>\n", "solution": "\ndef return_sum (dct):\n    return sum(dct.values())\n    \n\n"}
{"task_id": "Mbpp/797", "origin_solution": "<def_stmt>sum_in_range l r<block_start>sum=0<for_stmt>i range(l r+1)<block_start><if_stmt>i%2<ne>0<block_start>sum<augadd>i<block_end><block_end><return>sum<block_end>\n", "solution": "\ndef sum_in_range (l, r):\n    sum=0\n    for i in range(l, r+1):\n        if i%2!=0:\n            sum+=i\n            \n    \n    return sum\n    \n\n"}
{"task_id": "Mbpp/798", "origin_solution": "<def_stmt>_sum arr<block_start><return>sum(arr)<block_end>\n", "solution": "\ndef _sum (arr):\n    return sum(arr)\n    \n\n"}
{"task_id": "Mbpp/799", "origin_solution": "<def_stmt>left_rotate n d<block_start><return>(n<lshift>d)|(n<rshift>(32-d))&0xffffffff<block_end>\n", "solution": "\ndef left_rotate (n, d):\n    return (n<<d)|(n>>(32-d))&0xffffffff\n    \n\n"}
{"task_id": "Mbpp/800", "origin_solution": "<def_stmt>remove_all_spaces s<block_start><return>s.replace(\" \" \"\")<block_end>\n", "solution": "\ndef remove_all_spaces (s):\n    return s.replace(\" \", \"\")\n    \n\n"}
{"task_id": "Mbpp/801", "origin_solution": "<def_stmt>test_three_equal a b c<block_start><if_stmt>a<eq>b<eq>c<block_start><return>3<block_end><else_stmt><block_start><return>0<block_end><block_end>\n", "solution": "\ndef test_three_equal (a, b, c):\n    if a==b==c:\n        return 3\n        \n    \n    else :\n        return 0\n        \n\n\n"}
{"task_id": "Mbpp/803", "origin_solution": "<import_stmt>math<def_stmt>is_perfect_square n<block_start>sqrt=math.sqrt(n)<line_sep><return>sqrt.is_integer()<block_end>\n", "solution": "\nimport math\ndef is_perfect_square (n):\n    sqrt=math.sqrt(n)\n    return sqrt.is_integer()\n    \n\n"}
{"task_id": "Mbpp/804", "origin_solution": "<def_stmt>is_product_even lst<block_start><for_stmt>num lst<block_start><if_stmt>num%2<eq>0<block_start><return><true><block_end><block_end><return><false><block_end>\n", "solution": "\ndef is_product_even (lst):\n    for num in lst:\n        if num%2==0:\n            return  True \n            \n    \n    return  False \n    \n\n"}
{"task_id": "Mbpp/805", "origin_solution": "<def_stmt>max_sum_list lst<block_start><return>max(lst key=sum)<block_end>\n", "solution": "\ndef max_sum_list (lst):\n    return max(lst, key=sum)\n    \n\n"}
{"task_id": "Mbpp/806", "origin_solution": "<def_stmt>max_run_uppercase s<block_start>max_run=0<line_sep>current_run=0<for_stmt>char s<block_start><if_stmt>char.isupper()<block_start>current_run<augadd>1<line_sep>max_run=max(max_run current_run)<block_end><else_stmt><block_start>current_run=0<block_end><block_end><return>max_run<block_end>\n", "solution": "\ndef max_run_uppercase (s):\n    max_run=0\n    current_run=0\n    for char in s:\n        if char.isupper():\n            current_run+=1\n            max_run=max(max_run, current_run)\n            \n        \n        else :\n            current_run=0\n            \n    \n    return max_run\n    \n\n"}
{"task_id": "Mbpp/807", "origin_solution": "<def_stmt>first_odd lst<block_start><for_stmt>num lst<block_start><if_stmt>num%2<ne>0<block_start><return>num<block_end><block_end><return><none><block_end>\n", "solution": "\ndef first_odd (lst):\n    for num in lst:\n        if num%2!=0:\n            return num\n            \n    \n    return  None \n    \n\n"}
{"task_id": "Mbpp/808", "origin_solution": "<def_stmt>check_K tup k<block_start><return>k<in>tup<block_end>\n", "solution": "\ndef check_K (tup, k):\n    return k in tup\n    \n\n"}
{"task_id": "Mbpp/809", "origin_solution": "<def_stmt>check_smaller tuple1 tuple2<block_start><return>all(x<l>y<for>x,y zip(tuple1 tuple2))<block_end>\n", "solution": "\ndef check_smaller (tuple1, tuple2):\n    return all(x<y for x,y in zip(tuple1, tuple2))\n    \n\n"}
