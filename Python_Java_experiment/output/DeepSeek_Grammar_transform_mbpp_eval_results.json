{"date": "2025-06-05 02:28", "hash": "ee43ecabebf20deef4bb776a405ac5b1", "eval": {"Mbpp/2": [{"task_id": "Mbpp/2", "solution": "def similar_elements ( list1 , list2 ) : \n    set1 = set ( list1 ) \n    \n    set2 = set ( list2 ) \n    \n    shared_elements = set1 . intersection ( set2 ) \n    \n    return tuple ( shared_elements ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/6": [{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos ( a , b ) : \n    return ( a ^ b ) != 0 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[15, 8]], "plus_fail_tests": [[-10, 10]]}], "Mbpp/7": [{"task_id": "Mbpp/7", "solution": "def find_char_long ( s ) : \n    result = [ ] \n    \n    words = s . split ( ) \n    \n    for word in words : \n        if len ( word ) >= 4 : \n            result . append ( word ) \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["This is a very long string with no words that are at least 4 characters long."]]}], "Mbpp/8": [{"task_id": "Mbpp/8", "solution": "def square_nums ( nums ) : \n    result = [ ] \n    \n    for num in nums : \n        result . append ( num ** 2 ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/3": [{"task_id": "Mbpp/3", "solution": "def is_not_prime ( n ) : \n    if n < 2 : \n        return True \n    \n    for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : \n        if n % i == 0 : \n            return True \n        \n    \n    return False \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/4": [{"task_id": "Mbpp/4", "solution": "import heapq \ndef heap_queue_largest ( nums , n ) : \n    largest_nums = heapq . nlargest ( n , nums ) \n    \n    return largest_nums \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/17": [{"task_id": "Mbpp/17", "solution": "def square_perimeter ( side_length ) : \n    return 4 * side_length \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/9": [{"task_id": "Mbpp/9", "solution": "def find_Rotations ( s ) : \n    rotations = 1 \n    \n    s = s + s \n    \n    for i in range ( 1 , len ( s ) ) : \n        if s [ : i ] == s [ i : i + len ( s ) ] : \n            rotations = i \n            \n            break \n        \n    \n    return rotations \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["aaaa"]], "plus_fail_tests": [["aaaaaaaaaaa"]]}], "Mbpp/11": [{"task_id": "Mbpp/11", "solution": "def remove_Occ ( str , char ) : \n    first_occurrence = str . find ( char ) \n    \n    last_occurrence = str . rfind ( char ) \n    \n    if first_occurrence == - 1 or last_occurrence == - 1 : \n        return str \n    \n    return str [ : first_occurrence ] + str [ last_occurrence + 1 : ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["abcda", "a"]], "plus_fail_tests": [["aaa", "a"]]}], "Mbpp/16": [{"task_id": "Mbpp/16", "solution": "def text_lowercase_underscore ( text ) : \n    words = text . split ( \"_\" ) \n    \n    for word in words : \n        if not word . islower ( ) : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/57": [{"task_id": "Mbpp/57", "solution": "def find_Max_Num ( lst ) : \n    str_lst = [ str ( i ) for i in lst ] \n    \n    str_lst . sort ( key = lambda x : x * 10 , reverse = True ) \n    max_num = int ( '' . join ( str_lst ) ) \n    \n    return max_num \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/56": [{"task_id": "Mbpp/56", "solution": "def check ( num ) : \n    rev = str ( num ) [ : : - 1 ] \n    \n    rev = int ( rev ) \n    \n    return rev == num - ( num - rev ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[70]], "plus_fail_tests": [[0]]}], "Mbpp/88": [{"task_id": "Mbpp/88", "solution": "def freq_count ( lst ) : \n    freq = { } \n    \n    for i in lst : \n        if i in freq : \n            freq [ i ] += 1 \n        else : \n            freq [ i ] = 1 \n            \n        \n    \n    return freq \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/59": [{"task_id": "Mbpp/59", "solution": "def is_octagonal ( n ) : \n    return n * ( 7 * n - 5 ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[100]]}], "Mbpp/72": [{"task_id": "Mbpp/72", "solution": "import math \ndef dif_Square ( n ) : \n    a = 0 \n    \n    while a * a <= n : \n        b = math . sqrt ( n - a * a ) \n        \n        if b == int ( b ) : \n            return True \n        \n        a += 1 \n    \n    return False \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[991]]}], "Mbpp/75": [{"task_id": "Mbpp/75", "solution": "def find_tuples ( tuples , k ) : \n    result = [ ] \n    \n    for tup in tuples : \n        if all ( x % k == 0 for x in tup ) : \n            result . append ( tup ) \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/12": [{"task_id": "Mbpp/12", "solution": "def sort_matrix ( matrix ) : \n    row_sums = [ sum ( row ) for row in matrix ] \n    \n    sorted_indices = sorted ( range ( len ( row_sums ) ) , key = lambda i : row_sums [ i ] ) \n    \n    sorted_matrix = [ matrix [ i ] for i in sorted_indices ] \n    \n    return sorted_matrix \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/87": [{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three ( dict1 , dict2 , dict3 ) : \n    merged_dict = { } \n    \n    for d in [ dict1 , dict2 , dict3 ] : \n        for key , value in d . items ( ) : \n            merged_dict [ key ] = value \n            \n        \n    \n    return merged_dict \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/80": [{"task_id": "Mbpp/80", "solution": "def tetrahedral_number ( n ) : \n    return ( n * ( n + 1 ) * ( n + 2 ) ) // 6 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/63": [{"task_id": "Mbpp/63", "solution": "def max_difference ( test_list ) : \n    res = max ( j - i for i , j in test_list ) \n    \n    return ( res ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 5], [1, 7], [10, 3], [1, 2]]]], "plus_fail_tests": [[[[1000000, 999999], [10000000, 9999999], [100000000, 99999999], [1000000000, 999999999]]]]}], "Mbpp/65": [{"task_id": "Mbpp/65", "solution": "def recursive_list_sum ( lst ) : \n    total = 0 \n    \n    for element in lst : \n        if type ( element ) == list : \n            total += recursive_list_sum ( element ) \n        else : \n            total += element \n        \n    \n    return total \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/86": [{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number ( n ) : \n    return 7 * n * n - 7 * n \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[1000000]]}], "Mbpp/64": [{"task_id": "Mbpp/64", "solution": "def subject_marks ( lst ) : \n    return sorted ( lst , key = lambda x : x [ 1 ] ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/14": [{"task_id": "Mbpp/14", "solution": "def find_Volume ( a , b , c ) : \n    s = ( a + b + c ) / 2 \n    \n    volume = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 \n    \n    return volume \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10, 8, 6]], "plus_fail_tests": [[100, 50, 10]]}], "Mbpp/18": [{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars ( str1 , str2 ) : \n    result = \"\" \n    \n    for char in str1 : \n        if char not in str2 : \n            result += char \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/20": [{"task_id": "Mbpp/20", "solution": "def is_woodall ( number ) : \n    digits = [ int ( d ) for d in str ( number ) ] \n    \n    return 1 in digits \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[383]], "plus_fail_tests": [[123456789]]}], "Mbpp/68": [{"task_id": "Mbpp/68", "solution": "def is_Monotonic ( arr ) : \n    increasing = decreasing = True \n    \n    \n    for i in range ( len ( arr ) - 1 ) : \n        if arr [ i ] > arr [ i + 1 ] : \n            increasing = False \n            \n        \n        if arr [ i ] < arr [ i + 1 ] : \n            decreasing = False \n            \n        \n    \n    return increasing or decreasing \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/92": [{"task_id": "Mbpp/92", "solution": "def is_undulating ( number ) : \n    number_str = str ( number ) \n    \n    if len ( number_str ) < 3 : \n        return False \n    \n    for i in range ( len ( number_str ) - 2 ) : \n        if number_str [ i ] != number_str [ i + 2 ] : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[82]]}], "Mbpp/85": [{"task_id": "Mbpp/85", "solution": "import math \ndef surfacearea_sphere ( radius ) : \n    return 4 * math . pi * radius ** 2 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/19": [{"task_id": "Mbpp/19", "solution": "def test_duplicate ( arr ) : \n    seen = set ( ) \n    \n    for num in arr : \n        if num in seen : \n            return True \n        \n        seen . add ( num ) \n    \n    return False \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/77": [{"task_id": "Mbpp/77", "solution": "def is_Diff ( n ) : \n    return n % 11 == 0 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/61": [{"task_id": "Mbpp/61", "solution": "def count_Substrings ( s ) : \n    count = 0 \n    \n    for i in range ( len ( s ) ) : \n        sum = 0 \n        \n        for j in range ( i , len ( s ) ) : \n            sum += int ( s [ j ] ) \n            if sum == j - i + 1 : \n                count += 1 \n            \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/70": [{"task_id": "Mbpp/70", "solution": "def get_equal ( tuples ) : \n    length = len ( tuples [ 0 ] ) \n    \n    for t in tuples : \n        if len ( t ) != length : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/84": [{"task_id": "Mbpp/84", "solution": "def newman_conway ( n ) : \n    if n == 1 : \n        return 1 \n    elif n == 2 : \n        return 2 \n    else : \n        newman_list = [ 1 , 2 ] \n        \n        for i in range ( 2 , n ) : \n            newman_list . append ( sum ( newman_list [ - ( i - 1 ) : ] ) ) \n        \n        return newman_list [ - 1 ] \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/89": [{"task_id": "Mbpp/89", "solution": "def closest_num ( n ) : \n    return n - 1 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/94": [{"task_id": "Mbpp/94", "solution": "def index_minimum ( lst ) : \n    return min ( lst , key = lambda x : x [ 1 ] ) [ 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/138": [{"task_id": "Mbpp/138", "solution": "def is_Sum_Of_Powers_Of_Two ( n ) : \n    while n > 0 and n % 2 == 0 : \n        n = n // 2 \n        \n    \n    return n == 1 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[123456788]]}], "Mbpp/90": [{"task_id": "Mbpp/90", "solution": "def len_log ( words ) : \n    max_length = 0 \n    \n    for word in words : \n        if len ( word ) > max_length : \n            max_length = len ( word ) \n            \n        \n    \n    return max_length \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/98": [{"task_id": "Mbpp/98", "solution": "import math \ndef multiply_num ( nums ) : \n    product = 1 \n    \n    for num in nums : \n        product *= num \n    \n    return product / len ( nums ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/67": [{"task_id": "Mbpp/67", "solution": "def bell_number ( n ) : \n    bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] \n    \n    bell [ 0 ] [ 0 ] = 1 \n    \n    for i in range ( 1 , n + 1 ) : \n        bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] \n        \n        for j in range ( 1 , i + 1 ) : \n            bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] \n            \n        \n    \n    return bell [ n ] [ 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/66": [{"task_id": "Mbpp/66", "solution": "def pos_count ( lst ) : \n    count = 0 \n    \n    for num in lst : \n        if num > 0 : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/79": [{"task_id": "Mbpp/79", "solution": "def word_len ( word ) : \n    return len ( word ) % 2 != 0 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/129": [{"task_id": "Mbpp/129", "solution": "def magic_square_test ( matrix ) : \n    n = len ( matrix ) \n    \n    m = len ( matrix [ 0 ] ) \n    \n    if n != m : \n        return False \n    \n    magic_sum = sum ( matrix [ 0 ] ) \n    \n    for i in range ( n ) : \n        if sum ( matrix [ i ] ) != magic_sum : \n            return False \n        \n    \n    for i in range ( n ) : \n        col_sum = sum ( matrix [ j ] [ i ] for j in range ( n ) ) \n        \n        if col_sum != magic_sum : \n            return False \n        \n    \n    diag_sum1 = sum ( matrix [ i ] [ i ] for i in range ( n ) ) \n    \n    diag_sum2 = sum ( matrix [ i ] [ n - i - 1 ] for i in range ( n ) ) \n    \n    if diag_sum1 != magic_sum or diag_sum2 != magic_sum : \n        return False \n    \n    return True \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/74": [{"task_id": "Mbpp/74", "solution": "def is_samepatterns ( patterns , expected ) : \n    if len ( patterns ) != len ( expected ) : \n        return False \n    \n    for i in range ( len ( patterns ) ) : \n        if patterns [ i ] != expected [ i ] : \n            return False \n        \n    \n    return True \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["red", "green", "green"], ["a", "b", "b"]]], "plus_fail_tests": [[["red", "green", "blue"], ["a", "b", "c"]]]}], "Mbpp/97": [{"task_id": "Mbpp/97", "solution": "def frequency_lists ( list_of_lists ) : \n    frequency_dict = { } \n    \n    for sublist in list_of_lists : \n        for item in sublist : \n            if item in frequency_dict : \n                frequency_dict [ item ] += 1 \n            else : \n                frequency_dict [ item ] = 1 \n                \n            \n        \n    \n    return frequency_dict \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/139": [{"task_id": "Mbpp/139", "solution": "import math \ndef circle_circumference ( radius ) : \n    return 2 * math . pi * radius \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/105": [{"task_id": "Mbpp/105", "solution": "def count ( lst ) : \n    count = 0 \n    \n    for item in lst : \n        if item : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/62": [{"task_id": "Mbpp/62", "solution": "def smallest_num ( lst ) : \n    smallest = lst [ 0 ] \n    \n    for num in lst : \n        if num < smallest : \n            smallest = num \n            \n        \n    \n    return smallest \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/82": [{"task_id": "Mbpp/82", "solution": "import math \ndef volume_sphere ( radius ) : \n    volume = ( 4 / 3 ) * math . pi * ( radius ** 3 ) \n    \n    return volume \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/91": [{"task_id": "Mbpp/91", "solution": "def find_substring ( string_list , substring ) : \n    for string in string_list : \n        if substring in string : \n            return True \n        \n    \n    return False \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/126": [{"task_id": "Mbpp/126", "solution": "def sum_common_divisors ( a , b ) : \n    divisors_a = [ ] \n    \n    divisors_b = [ ] \n    \n    for i in range ( 1 , a + 1 ) : \n        if a % i == 0 : \n            divisors_a . append ( i ) \n        \n    \n    for i in range ( 1 , b + 1 ) : \n        if b % i == 0 : \n            divisors_b . append ( i ) \n        \n    \n    common_divisors = set ( divisors_a ) & set ( divisors_b ) \n    \n    return sum ( common_divisors ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/116": [{"task_id": "Mbpp/116", "solution": "def tuple_to_int ( t ) : \n    result = 0 \n    \n    for i in t : \n        result = result * 10 + i \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[123, 456, 789]]]}], "Mbpp/58": [{"task_id": "Mbpp/58", "solution": "def opposite_Signs ( a , b ) : \n    return a * b < 0 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/69": [{"task_id": "Mbpp/69", "solution": "def is_sublist ( l , s ) : \n    n = len ( l ) \n    \n    m = len ( s ) \n    \n    for i in range ( n - m + 1 ) : \n        if l [ i : i + m ] == s : \n            return True \n        \n    \n    return False \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/99": [{"task_id": "Mbpp/99", "solution": "def decimal_to_binary ( decimal ) : \n    binary = \"\" \n    \n    while decimal > 0 : \n        binary = str ( decimal % 2 ) + binary \n        \n        decimal = decimal // 2 \n        \n    \n    return binary \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0]]}], "Mbpp/71": [{"task_id": "Mbpp/71", "solution": "def comb_sort ( arr ) : \n    gap = len ( arr ) \n    \n    swapped = True \n    \n    while gap > 1 or swapped is True : \n        gap = max ( 1 , gap // 2 ) \n        \n        swapped = False \n        \n        for i in range ( len ( arr ) - gap ) : \n            if arr [ i ] > arr [ i + gap ] : \n                arr [ i ] , arr [ i + gap ] = arr [ i + gap ] , arr [ i ] \n                \n                swapped = True \n                \n            \n        \n    \n    return arr \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/131": [{"task_id": "Mbpp/131", "solution": "def reverse_vowels ( s ) : \n    vowels = set ( \"aeiouAEIOU\" ) \n    \n    s = list ( s ) \n    \n    i , j = 0 , len ( s ) - 1 \n    \n    while i < j : \n        if s [ i ] not in vowels : \n            i += 1 \n        elif s [ j ] not in vowels : \n            j -= 1 \n        else : \n            s [ i ] , s [ j ] = s [ j ] , s [ i ] \n            \n            i += 1 \n            j -= 1 \n        \n    \n    return \"\" . join ( s ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/100": [{"task_id": "Mbpp/100", "solution": "def next_smallest_palindrome ( n ) : \n    def is_palindrome ( n ) : \n        return str ( n ) == str ( n ) [ : : - 1 ] \n    \n    def next_palindrome ( n ) : \n        while True : \n            n += 1 \n            if is_palindrome ( n ) : \n                return n \n            \n        \n    \n    return next_palindrome ( n ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/109": [{"task_id": "Mbpp/109", "solution": "def odd_Equivalent ( s , n ) : \n    t = s \n    \n    for i in range ( n ) : \n        t = t [ : : - 1 ] + t [ len ( t ) // 2 : ] \n        \n    \n    odd_count = sum ( int ( c ) for c in t if int ( c ) % 2 != 0 ) \n    \n    return odd_count \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["011001", 6]], "plus_fail_tests": [["1100110011", 5]]}], "Mbpp/111": [{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists ( lists ) : \n    common_elements = set ( lists [ 0 ] ) \n    \n    for lst in lists [ 1 : ] : \n        common_elements = common_elements . intersection ( set ( lst ) ) \n        \n    \n    return common_elements \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/171": [{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon ( side ) : \n    return side * 7 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[-10]]}], "Mbpp/161": [{"task_id": "Mbpp/161", "solution": "def remove_elements ( list1 , list2 ) : \n    result = [ i for i in list1 if i not in list2 ] \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/120": [{"task_id": "Mbpp/120", "solution": "def max_product_tuple ( lst ) : \n    max_product = float ( '-inf' ) \n    \n    for tup in lst : \n        product = tup [ 0 ] * tup [ 1 ] \n        \n        if product > max_product : \n            max_product = product \n            \n        \n    \n    return max_product \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[-10, 20], [15, -2], [-5, 10]]]]}], "Mbpp/106": [{"task_id": "Mbpp/106", "solution": "def add_lists ( list1 , tup ) : \n    return tup + tuple ( list1 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/119": [{"task_id": "Mbpp/119", "solution": "def search ( arr ) : \n    low = 0 \n    \n    high = len ( arr ) - 1 \n    \n    while low < high : \n        mid = ( low + high ) // 2 \n        \n        if mid % 2 == 0 : \n            if arr [ mid ] == arr [ mid + 1 ] : \n                low = mid + 2 \n                \n            else : \n                high = mid - 1 \n                \n            \n        else : \n            if arr [ mid ] == arr [ mid - 1 ] : \n                low = mid + 1 \n                \n            else : \n                high = mid - 2 \n                \n            \n        \n    \n    return arr [ low ] \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/251": [{"task_id": "Mbpp/251", "solution": "def insert_element ( lst , element ) : \n    new_list = [ ] \n    \n    for item in lst : \n        new_list . append ( element ) \n        new_list . append ( item ) \n    \n    return new_list \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/124": [{"task_id": "Mbpp/124", "solution": "import math \ndef angle_complex ( real , imag ) : \n    return math . atan2 ( imag , real ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["0.0", "1j"]], "plus_fail_tests": [["0.0", "0j"]]}], "Mbpp/137": [{"task_id": "Mbpp/137", "solution": "def zero_count ( arr ) : \n    zero_count = 0 \n    \n    non_zero_count = 0 \n    \n    for i in arr : \n        if i == 0 : \n            zero_count += 1 \n        else : \n            non_zero_count += 1 \n        \n    \n    return zero_count / non_zero_count \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}], "Mbpp/102": [{"task_id": "Mbpp/102", "solution": "def snake_to_camel ( snake_str ) : \n    components = snake_str . split ( '_' ) \n    \n    return '' . join ( x . title ( ) for x in components ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["___python_program"]]}], "Mbpp/166": [{"task_id": "Mbpp/166", "solution": "def find_even_pair ( lst ) : \n    count = 0 \n    \n    for i in range ( len ( lst ) ) : \n        for j in range ( i + 1 , len ( lst ) ) : \n            if ( lst [ i ] ^ lst [ j ] ) % 2 == 0 : \n                count += 1 \n            \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/233": [{"task_id": "Mbpp/233", "solution": "import math \ndef lateralsuface_cylinder ( radius , height ) : \n    return 2 * math . pi * radius * ( radius + height ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10, 5]], "plus_fail_tests": [[0.5, 5]]}], "Mbpp/160": [{"task_id": "Mbpp/160", "solution": "def find_solution ( a , b , n ) : \n    for x in range ( 1 , n // a + 1 ) : \n        y = ( n - a * x ) / b \n        \n        if y . is_integer ( ) and y > 0 : \n            return ( x , int ( y ) ) \n        \n    \n    return None \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[100, 50, 4000]]}], "Mbpp/113": [{"task_id": "Mbpp/113", "solution": "def check_integer ( s ) : \n    try : \n        int ( s ) \n        return True \n    except ValueError : \n        return False \n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/95": [{"task_id": "Mbpp/95", "solution": "def Find_Min_Length ( list_of_lists ) : \n    min_length = float ( 'inf' ) \n    \n    for lst in list_of_lists : \n        if len ( lst ) < min_length : \n            min_length = len ( lst ) \n            \n        \n    \n    return min_length \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/118": [{"task_id": "Mbpp/118", "solution": "def string_to_list ( s ) : \n    return s . split ( \" \" ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/130": [{"task_id": "Mbpp/130", "solution": "def max_occurrences ( lst ) : \n    count_dict = { } \n    \n    for item in lst : \n        if item in count_dict : \n            count_dict [ item ] += 1 \n        else : \n            count_dict [ item ] = 1 \n            \n        \n    \n    max_item = max ( count_dict , key = count_dict . get ) \n    \n    return max_item \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/104": [{"task_id": "Mbpp/104", "solution": "def sort_sublists ( lst ) : \n    return [ sorted ( sublist ) for sublist in lst ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/108": [{"task_id": "Mbpp/108", "solution": "def merge_sorted_list ( list1 , list2 , list3 ) : \n    merged_list = list1 + list2 + list3 \n    \n    merged_list . sort ( ) \n    return merged_list \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/141": [{"task_id": "Mbpp/141", "solution": "def pancake_sort ( arr ) : \n    def flip ( arr , k ) : \n        arr [ : k ] = arr [ : k ] [ : : - 1 ] \n        \n    \n    def find_max ( arr , n ) : \n        max_index = 0 \n        \n        for i in range ( 1 , n ) : \n            if arr [ i ] > arr [ max_index ] : \n                max_index = i \n                \n            \n        \n        return max_index \n    \n    n = len ( arr ) \n    \n    for i in range ( n - 1 , - 1 , - 1 ) : \n        max_index = find_max ( arr , i + 1 ) \n        \n        if max_index != i : \n            flip ( arr , max_index + 1 ) \n            flip ( arr , i + 1 ) \n        \n    \n    return arr \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/135": [{"task_id": "Mbpp/135", "solution": "def hexagonal_num ( n ) : \n    return n * ( 2 * n - 1 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/226": [{"task_id": "Mbpp/226", "solution": "def odd_values_string ( s ) : \n    result = '' \n    \n    for i in range ( len ( s ) ) : \n        if i % 2 == 0 : \n            result += s [ i ] \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/170": [{"task_id": "Mbpp/170", "solution": "def sum_range_list ( l , i , j ) : \n    sum = 0 \n    \n    for num in l [ i : j + 1 ] : \n        sum += num \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/127": [{"task_id": "Mbpp/127", "solution": "def multiply_int ( a , b ) : \n    return a * b \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/133": [{"task_id": "Mbpp/133", "solution": "def sum_negativenum ( lst ) : \n    sum = 0 \n    \n    for num in lst : \n        if num < 0 : \n            sum += num \n        \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/125": [{"task_id": "Mbpp/125", "solution": "def find_length ( binary_string ) : \n    max_length = 0 \n    \n    current_length = 0 \n    \n    for char in binary_string : \n        if char == '0' : \n            current_length += 1 \n        else : \n            current_length -= 1 \n        \n        max_length = max ( max_length , current_length ) \n        \n    \n    return max_length \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["11000010001"]], "plus_fail_tests": [["100000011100000000111111111000000011111101"]]}], "Mbpp/232": [{"task_id": "Mbpp/232", "solution": "def larg_nnum ( lst , n ) : \n    lst . sort ( reverse = True ) \n    return lst [ : n ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/168": [{"task_id": "Mbpp/168", "solution": "def frequency ( lst , num ) : \n    count = 0 \n    \n    for i in lst : \n        if i == num : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/103": [{"task_id": "Mbpp/103", "solution": "def eulerian_num ( n , m ) : \n    result = 0 \n    \n    for i in range ( n , n - m , - 1 ) : \n        result += i \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 1]], "plus_fail_tests": [[1, 1]]}], "Mbpp/93": [{"task_id": "Mbpp/93", "solution": "def power ( a , b ) : \n    return a ** b \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/101": [{"task_id": "Mbpp/101", "solution": "def kth_element ( arr , k ) : \n    return arr [ k - 1 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/140": [{"task_id": "Mbpp/140", "solution": "def extract_singly ( list_of_lists ) : \n    result = [ ] \n    \n    for sublist in list_of_lists : \n        for item in sublist : \n            result . append ( item ) \n        \n    \n    return set ( result ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/222": [{"task_id": "Mbpp/222", "solution": "def check_type ( t ) : \n    types = set ( ) \n    \n    for i in t : \n        types . add ( type ( i ) ) \n    \n    return len ( types ) == 1 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/253": [{"task_id": "Mbpp/253", "solution": "def count_integer ( lst ) : \n    count = 0 \n    \n    for item in lst : \n        if isinstance ( item , int ) : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/230": [{"task_id": "Mbpp/230", "solution": "def replace_blank ( string , char ) : \n    return string . replace ( \" \" , char ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/172": [{"task_id": "Mbpp/172", "solution": "def count_occurance ( s ) : \n    count = 0 \n    \n    start = 0 \n    \n    while True : \n        index = s . find ( 'std' , start ) \n        \n        if index == - 1 : \n            break \n        \n        count += 1 \n        start = index + 3 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/244": [{"task_id": "Mbpp/244", "solution": "import math \ndef next_Perfect_Square ( n ) : \n    root = math . sqrt ( n ) \n    \n    if root . is_integer ( ) : \n        return int ( root ) + 1 \n    else : \n        return int ( math . ceil ( root ) ) \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[35]], "plus_fail_tests": [[-5]]}], "Mbpp/167": [{"task_id": "Mbpp/167", "solution": "def next_power_of_2 ( n ) : \n    if n == 0 : \n        return 1 \n    elif n & ( n - 1 ) == 0 : \n        return n \n    else : \n        return 1 << ( n - 1 ) . bit_length ( ) \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/237": [{"task_id": "Mbpp/237", "solution": "def check_occurences ( list_of_tuples ) : \n    result = { } \n    \n    for tup in list_of_tuples : \n        if tup in result : \n            result [ tup ] += 1 \n        else : \n            result [ tup ] = 1 \n            \n        \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 1], [1, 3], [2, 5], [5, 2], [6, 3]]]], "plus_fail_tests": [[[[2, 2], [1, 3], [2, 2], [3, 1], [1, 3]]]]}], "Mbpp/145": [{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff ( arr ) : \n    max_diff = max ( arr ) - min ( arr ) \n    \n    return max_diff \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/235": [{"task_id": "Mbpp/235", "solution": "def even_bit_set_number ( n ) : \n    binary_str = bin ( n ) [ 2 : ] \n    \n    binary_str = list ( binary_str ) \n    \n    for i in range ( len ( binary_str ) ) : \n        if i % 2 == 0 : \n            binary_str [ i ] = '1' \n            \n        \n    \n    result = int ( '' . join ( binary_str ) , 2 ) \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[20]], "plus_fail_tests": [[false]]}], "Mbpp/239": [{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences ( m , n ) : \n    if n == 1 : \n        return m \n    \n    dp = [ [ 0 for _ in range ( n + 1 ) ] for _ in range ( m + 1 ) ] \n    \n    for i in range ( 1 , m + 1 ) : \n        dp [ i ] [ 1 ] = 1 \n        \n    \n    for i in range ( 2 , n + 1 ) : \n        for j in range ( 1 , m + 1 ) : \n            dp [ j ] [ i ] = dp [ j ] [ i - 1 ] + sum ( dp [ k ] [ i - 1 ] for k in range ( j , m + 1 ) ) \n            \n        \n    \n    return sum ( dp [ i ] [ n ] for i in range ( 1 , m + 1 ) ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10, 4]], "plus_fail_tests": [[100, 10]]}], "Mbpp/227": [{"task_id": "Mbpp/227", "solution": "def min_of_three ( a , b , c ) : \n    if a < b : \n        min_ab = a \n        \n    else : \n        min_ab = b \n        \n    \n    if min_ab < c : \n        return min_ab \n    else : \n        return c \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/142": [{"task_id": "Mbpp/142", "solution": "def count_samepair ( list1 , list2 , list3 ) : \n    count = 0 \n    \n    for i in range ( len ( list1 ) ) : \n        if list1 [ i ] == list2 [ i ] == list3 [ i ] : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8]]]}], "Mbpp/238": [{"task_id": "Mbpp/238", "solution": "def number_of_substrings ( s ) : \n    count = 0 \n    \n    for i in range ( len ( s ) ) : \n        for j in range ( i + 1 , len ( s ) + 1 ) : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/96": [{"task_id": "Mbpp/96", "solution": "def divisor ( n ) : \n    count = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        if n % i == 0 : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/242": [{"task_id": "Mbpp/242", "solution": "def count_charac ( str ) : \n    count = 0 \n    \n    for char in str : \n        count += 1 \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/234": [{"task_id": "Mbpp/234", "solution": "def volume_cube ( side_length ) : \n    return side_length ** 3 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/252": [{"task_id": "Mbpp/252", "solution": "import math \ndef convert ( real_part ) : \n    radius = math . sqrt ( real_part ** 2 + 1 ) \n    \n    angle = math . atan ( real_part ) \n    \n    return ( radius , angle ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["(1+0j)"]], "plus_fail_tests": [["(1+2j)"]]}], "Mbpp/128": [{"task_id": "Mbpp/128", "solution": "def long_words ( n , text ) : \n    words = text . split ( ) \n    \n    result = [ word for word in words if len ( word ) > n ] \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/240": [{"task_id": "Mbpp/240", "solution": "def replace_list ( list1 , list2 ) : \n    list1 [ - 1 ] = list2 [ - 1 ] \n    \n    return list1 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, 5, 7, 9, 10], [2, 4, 6, 8]]], "plus_fail_tests": [[[1, 2, 3, 4], []]]}], "Mbpp/245": [{"task_id": "Mbpp/245", "solution": "def max_sum ( arr ) : \n    n = len ( arr ) \n    \n    i = 0 \n    \n    sum = 0 \n    \n    while i < n : \n        high = low = i \n        \n        \n        while i + 1 < n and arr [ i ] < arr [ i + 1 ] : \n            i += 1 \n            high = i \n            \n        \n        while i + 1 < n and arr [ i ] > arr [ i + 1 ] : \n            i += 1 \n            low = i \n            \n        \n        sum += sum ( arr [ low : high + 1 ] ) \n        i = high \n        \n    \n    return sum \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 15, 51, 45, 33, 100, 12, 18, 9]]], "plus_fail_tests": [[[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]]]}], "Mbpp/250": [{"task_id": "Mbpp/250", "solution": "def count_X ( tup , X ) : \n    count = 0 \n    \n    for i in tup : \n        if i == X : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/224": [{"task_id": "Mbpp/224", "solution": "def count_Set_Bits ( n ) : \n    count = 0 \n    \n    while n : \n        count += n & 1 \n        n >>= 1 \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/132": [{"task_id": "Mbpp/132", "solution": "def tup_string ( tup ) : \n    return '' . join ( tup ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/165": [{"task_id": "Mbpp/165", "solution": "def count_char_position ( str1 ) : \n    count = 0 \n    \n    for i in range ( len ( str1 ) ) : \n        if str1 [ i ] . lower ( ) == chr ( i + 97 ) : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/223": [{"task_id": "Mbpp/223", "solution": "def is_majority ( arr , n , x ) : \n    count = 0 \n    \n    for i in range ( n ) : \n        if arr [ i ] == x : \n            count += 1 \n        \n    \n    if count > n // 2 : \n        return True \n    else : \n        return False \n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 1, 0]]}], "Mbpp/247": [{"task_id": "Mbpp/247", "solution": "def lps ( s ) : \n    n = len ( s ) \n    \n    L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] \n    \n    for i in range ( n ) : \n        L [ i ] [ i ] = 1 \n        \n    \n    for cl in range ( 2 , n + 1 ) : \n        for i in range ( n - cl + 1 ) : \n            j = i + cl - 1 \n            \n            if s [ i ] == s [ j ] and cl == 2 : \n                L [ i ] [ j ] = 2 \n                \n            elif s [ i ] == s [ j ] : \n                L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 \n                \n            else : \n                L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) \n                \n              \n        \n    \n    return L [ 0 ] [ n - 1 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/162": [{"task_id": "Mbpp/162", "solution": "def sum_series ( n ) : \n    sum = 0 \n    \n    for i in range ( 0 , n // 2 + 1 ) : \n        sum += ( n - 2 * i ) \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/123": [{"task_id": "Mbpp/123", "solution": "def amicable_numbers_sum ( n ) : \n    sum_ = 0 \n    \n    for i in range ( 1 , n ) : \n        sum1 = 0 \n        \n        for j in range ( 1 , i ) : \n            if i % j == 0 : \n                sum1 += j \n            \n        \n        if sum1 != i and sum1 < n : \n            sum_ += i \n        \n    \n    return sum_ \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[999]], "plus_fail_tests": [[10000]]}], "Mbpp/268": [{"task_id": "Mbpp/268", "solution": "def find_star_num ( n ) : \n    star_num = n * ( n + 1 ) * ( 2 * n + 1 ) // 6 \n    \n    return star_num \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/266": [{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube ( side_length ) : \n    return 6 * side_length ** 2 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[100]]}], "Mbpp/267": [{"task_id": "Mbpp/267", "solution": "def square_Sum ( n ) : \n    sum = 0 \n    \n    for i in range ( 1 , 2 * n , 2 ) : \n        sum += i * i \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000.0]]}], "Mbpp/264": [{"task_id": "Mbpp/264", "solution": "def dog_age ( human_years ) : \n    dog_years = human_years - 2 \n    \n    dog_years *= 10 \n    dog_years -= 11 \n    return dog_years \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[12]], "plus_fail_tests": [[100]]}], "Mbpp/279": [{"task_id": "Mbpp/279", "solution": "def is_num_decagonal ( n ) : \n    return n * ( 7 * n - 5 ) // 2 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/391": [{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary ( lst1 , lst2 , lst3 ) : \n    result = [ ] \n    \n    for i in range ( len ( lst1 ) ) : \n        dictionary = { lst1 [ i ] : { lst2 [ i ] : lst3 [ i ] } } \n        \n        result . append ( dictionary ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["S001", "S002", "S003", "S004"], ["Adina Park", "Leyton Marsh", "Duncan Boyle", "Saim Richards"], [[1, 2, 3], [4, 5, 6], {"a": "x", "b": "y", "c": "z"}]]]}], "Mbpp/270": [{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index ( lst ) : \n    sum = 0 \n    \n    for i in range ( len ( lst ) ) : \n        if i % 2 == 0 and lst [ i ] % 2 == 0 : \n            sum += lst [ i ] \n        \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/281": [{"task_id": "Mbpp/281", "solution": "def all_unique ( lst ) : \n    unique_elements = set ( lst ) \n    \n    return len ( lst ) == len ( unique_elements ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/293": [{"task_id": "Mbpp/293", "solution": "import math \ndef otherside_rightangle ( a , b ) : \n    return math . sqrt ( a ** 2 + b ** 2 ) * 0.5 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7, 8]], "plus_fail_tests": [[2.5, 3.5]]}], "Mbpp/305": [{"task_id": "Mbpp/305", "solution": "def start_withp ( words ) : \n    p_words = [ word for word in words if word . startswith ( 'p' ) ] \n    \n    if len ( p_words ) >= 1 : \n        first_p_word = p_words [ 0 ] \n        \n        second_p_word = p_words [ 1 ] \n        \n        return first_p_word . split ( ) [ 0 ] , first_p_word . split ( ) [ 1 ] \n    elif len ( p_words ) == 0 : \n        return \"\" , \"\" \n    else : \n        return \"\" , \"\" \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python PHP", "Java JavaScript", "c c++"]]], "plus_fail_tests": [[["Python Programming", "Java Programming", "Perl Programming", "Ruby Programming", "PHP Programming", "C Programming"]]]}], "Mbpp/259": [{"task_id": "Mbpp/259", "solution": "def maximize_elements ( tuples_list ) : \n    max_tuples = [ ] \n    \n    for tup in tuples_list : \n        max_tup = max ( tup , key = lambda x : x [ 0 ] ) \n        \n        max_tuples . append ( max_tup ) \n    \n    return tuple ( max_tuples ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]]], "plus_fail_tests": [[[[1, 2], [3, 4], [5, 6], [7, 8]], [[8, 7], [6, 5], [4, 3], [2, 1]]]]}], "Mbpp/294": [{"task_id": "Mbpp/294", "solution": "def max_val ( listval ) : \n    max_val = max ( listval ) \n    \n    return max_val \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python", 3, 2, 4, 5, "version"]]], "plus_fail_tests": [[[1, "2", true, 3.14, ["a", "b"], [5, 6, 7], {"8": "eight", "9": "nine"}, "Python", 10, 11, 12]]]}], "Mbpp/277": [{"task_id": "Mbpp/277", "solution": "def dict_filter ( dict , n ) : \n    filtered_dict = { } \n    \n    for key , value in dict . items ( ) : \n        if value >= n : \n            filtered_dict [ key ] = value \n            \n        \n    \n    return filtered_dict \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/265": [{"task_id": "Mbpp/265", "solution": "def list_split ( input_list , n ) : \n    result = [ ] \n    \n    temp_list = [ ] \n    \n    for i in range ( len ( input_list ) ) : \n        temp_list . append ( input_list [ i ] ) \n        if ( i + 1 ) % n == 0 : \n            result . append ( temp_list ) \n            temp_list = [ ] \n            \n        \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n"], 3]], "plus_fail_tests": [[[], 1]]}], "Mbpp/276": [{"task_id": "Mbpp/276", "solution": "import math \ndef volume_cylinder ( radius , height ) : \n    volume = math . pi * radius ** 2 * height \n    \n    return volume \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/290": [{"task_id": "Mbpp/290", "solution": "def max_length ( list_of_lists ) : \n    max_length = max ( len ( sublist ) for sublist in list_of_lists ) \n    \n    max_sublists = [ sublist for sublist in list_of_lists if len ( sublist ) == max_length ] \n    \n    return max_length , max_sublists \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]]], "plus_fail_tests": [[[[1, 3, 5, 7, 9, 11], [2, 4, 6], [10, 12, 14, 16, 18, 20], [13, 15, 17, 19, 21]]]]}], "Mbpp/262": [{"task_id": "Mbpp/262", "solution": "def split_two_parts ( lst , L ) : \n    return lst [ : L ] , lst [ L : ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/257": [{"task_id": "Mbpp/257", "solution": "def swap_numbers ( a , b ) : \n    return b , a \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/274": [{"task_id": "Mbpp/274", "solution": "def even_binomial_Coeff_Sum ( n ) : \n    sum = 0 \n    \n    for i in range ( 0 , n , 2 ) : \n        a = 1 \n        \n        b = 1 \n        \n        for j in range ( 1 , n // 2 + 1 ) : \n            a = a * ( n - j + 1 ) \n            \n            b = b * j \n            \n        \n        sum += a / b \n    \n    return int ( sum ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[4]], "plus_fail_tests": [[10]]}], "Mbpp/256": [{"task_id": "Mbpp/256", "solution": "def count_Primes_nums ( num ) : \n    def is_prime ( n ) : \n        if n < 2 : \n            return False \n        \n        for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : \n            if n % i == 0 : \n                return False \n            \n        \n        return True \n    \n    count = 0 \n    \n    for i in range ( 2 , num ) : \n        if is_prime ( i ) : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/260": [{"task_id": "Mbpp/260", "solution": "def newman_prime ( n ) : \n    primes = [ 2 , 3 ] \n    \n    num = 5 \n    \n    while len ( primes ) < n : \n        is_prime = True \n        \n        for prime in primes : \n            if num % prime == 0 : \n                is_prime = False \n                \n                break \n            \n        \n        if is_prime : \n            primes . append ( num ) \n        \n        num += 1 \n    \n    return primes [ - 1 ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[100]]}], "Mbpp/269": [{"task_id": "Mbpp/269", "solution": "def ascii_value ( char ) : \n    return ord ( char ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/273": [{"task_id": "Mbpp/273", "solution": "def substract_elements ( tup1 , tup2 ) : \n    res = tuple ( a - b for a , b in zip ( tup1 , tup2 ) ) \n    \n    return res \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/282": [{"task_id": "Mbpp/282", "solution": "def sub_list ( lst1 , lst2 ) : \n    return [ a - b for a , b in zip ( lst1 , lst2 ) ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/300": [{"task_id": "Mbpp/300", "solution": "def count_binary_seq ( n ) : \n    return 2 ** n \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[4]]}], "Mbpp/278": [{"task_id": "Mbpp/278", "solution": "def count_first_elements ( t ) : \n    count = 0 \n    \n    for i in t : \n        if isinstance ( i , tuple ) : \n            break \n        \n        count += 1 \n    \n    return count \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6]]]}], "Mbpp/272": [{"task_id": "Mbpp/272", "solution": "def rear_extract ( lst ) : \n    return [ t [ - 1 ] for t in lst ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/280": [{"task_id": "Mbpp/280", "solution": "def sequential_search ( array , element ) : \n    for i in range ( len ( array ) ) : \n        if array [ i ] == element : \n            return ( True , i ) \n        \n    \n    return ( False , - 1 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/285": [{"task_id": "Mbpp/285", "solution": "import re \ndef text_match_two_three ( text ) : \n    patterns = 'ab{2,3}' \n    \n    if re . search ( patterns , text ) : \n        return True \n    else : \n        return False \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/283": [{"task_id": "Mbpp/283", "solution": "def validate ( n ) : \n    digits = [ int ( d ) for d in str ( n ) ] \n    \n    for digit in digits : \n        if digits . count ( digit ) > digit : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/261": [{"task_id": "Mbpp/261", "solution": "def division_elements ( tup1 , tup2 ) : \n    result = tuple ( a / b for a , b in zip ( tup1 , tup2 ) ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/299": [{"task_id": "Mbpp/299", "solution": "def max_aggregate ( lst ) : \n    max_value = max ( lst , key = lambda x : x [ 1 ] ) \n    \n    return max_value \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[["Juan Whelan", 90], ["Sabah Colley", 88], ["Peter Nichols", 7], ["Juan Whelan", 122], ["Sabah Colley", 84]]]], "plus_fail_tests": [[[["Alice", 80], ["Bob", 90], ["Charlie", 70], ["Alice", 60], ["Bob", 50], ["Charlie", 40]]]]}], "Mbpp/296": [{"task_id": "Mbpp/296", "solution": "def get_Inv_Count ( arr ) : \n    inv_count = 0 \n    \n    for i in range ( len ( arr ) ) : \n        for j in range ( i + 1 , len ( arr ) ) : \n            if arr [ i ] > arr [ j ] : \n                inv_count += 1 \n            \n        \n    \n    return inv_count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/395": [{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character ( string ) : \n    char_count = { } \n    \n    for char in string : \n        if char in char_count : \n            char_count [ char ] += 1 \n        else : \n            char_count [ char ] = 1 \n            \n        \n    \n    for char in string : \n        if char_count [ char ] == 1 : \n            return char \n        \n    \n    return None \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/394": [{"task_id": "Mbpp/394", "solution": "def check_distinct ( t ) : \n    return len ( t ) == len ( set ( t ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/430": [{"task_id": "Mbpp/430", "solution": "def parabola_directrix ( a , b , c ) : \n    discriminant = b ** 2 - 4 * a * c \n    \n    if discriminant < 0 : \n        return - 1 \n    else : \n        return - b / ( 2 * a ) \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 3, 2]], "plus_fail_tests": [[0, 0, 0]]}], "Mbpp/311": [{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit ( n ) : \n    bit_position = 0 \n    \n    while n > 0 : \n        if n & 1 == 0 : \n            break \n        \n        n >>= 1 \n        bit_position += 1 \n    \n    return n | ( 1 << bit_position ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[125]]}], "Mbpp/292": [{"task_id": "Mbpp/292", "solution": "def find ( a , b ) : \n    return a // b \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/287": [{"task_id": "Mbpp/287", "solution": "def square_Sum ( n ) : \n    sum = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        sum = sum + ( 2 * ( i * i ) ) \n        \n    \n    return sum \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[100]]}], "Mbpp/389": [{"task_id": "Mbpp/389", "solution": "def find_lucas ( n ) : \n    if n == 0 : \n        return 2 \n    elif n == 1 : \n        return 1 \n    else : \n        a , b = 2 , 1 \n        \n        for _ in range ( 2 , n + 1 ) : \n            a , b = b , a + b \n            \n        \n        return b \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/312": [{"task_id": "Mbpp/312", "solution": "import math \ndef volume_cone ( radius , height ) : \n    volume = ( 1 / 3 ) * math . pi * radius * height \n    \n    return volume \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 12]], "plus_fail_tests": [[3.5, 8.2]]}], "Mbpp/388": [{"task_id": "Mbpp/388", "solution": "def highest_Power_of_2 ( n ) : \n    power = 0 \n    \n    while 2 ** power <= n : \n        power += 1 \n    \n    return 2 ** ( power - 1 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/414": [{"task_id": "Mbpp/414", "solution": "def overlapping ( sequence1 , sequence2 ) : \n    set1 = set ( sequence1 ) \n    \n    set2 = set ( sequence2 ) \n    \n    return bool ( set1 & set2 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/404": [{"task_id": "Mbpp/404", "solution": "def minimum ( a , b ) : \n    if a < b : \n        return a \n    else : \n        return b \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/310": [{"task_id": "Mbpp/310", "solution": "def string_to_tuple ( s ) : \n    return tuple ( s ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python 3.0"]], "plus_fail_tests": [["hello   world"]]}], "Mbpp/301": [{"task_id": "Mbpp/301", "solution": "def dict_depth ( d ) : \n    if not isinstance ( d , dict ) or not d : \n        return 0 \n    \n    return 1 + max ( dict_depth ( v ) for v in d . values ( ) ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"a": 1, "b": {"c": {"d": {}}}}]], "plus_fail_tests": [[{}]]}], "Mbpp/308": [{"task_id": "Mbpp/308", "solution": "def large_product ( list1 , list2 , n ) : \n    result = [ ] \n    \n    for i in list1 : \n        for j in list2 : \n            result . append ( i * j ) \n        \n    \n    result . sort ( reverse = True ) \n    return result [ : n ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/392": [{"task_id": "Mbpp/392", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/435": [{"task_id": "Mbpp/435", "solution": "def last_Digit ( n ) : \n    return abs ( n ) % 10 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/421": [{"task_id": "Mbpp/421", "solution": "def concatenate_tuple ( tup , delimiter = '-' ) : \n    return delimiter . join ( tup ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["ID", "is", 4, "UTS"]]], "plus_fail_tests": [[[42]]]}], "Mbpp/286": [{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated ( arr , n , k ) : \n    max_k_times = sum ( arr ) * k \n    \n    max_sum = kadane ( arr ) \n    \n    current_sum = 0 \n    \n    for i in range ( n ) : \n        current_sum += arr [ i ] \n        if current_sum > max_k_times : \n            current_sum = max_k_times \n            \n        \n        max_sum = max ( max_sum , current_sum ) \n        \n    \n    return max_sum \n\ndef kadane ( arr ) : \n    max_end_here = max_so_far = arr [ 0 ] \n    \n    \n    for x in arr [ 1 : ] : \n        max_end_here = max ( x , max_end_here + x ) \n        \n        max_so_far = max ( max_so_far , max_end_here ) \n        \n    \n    return max_so_far \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, 10, 20], 3, 2]], "plus_fail_tests": [[[5, -2, 10, 4, -7, 3], 6, 5]]}], "Mbpp/413": [{"task_id": "Mbpp/413", "solution": "def extract_nth_element ( lst , n ) : \n    result = [ t [ n ] for t in lst ] \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/306": [{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq ( arr , n , i , k ) : \n    max_sum = 0 \n    \n    for j in range ( i ) : \n        if arr [ j ] < arr [ i ] and arr [ j ] > arr [ k ] : \n            max_sum = max ( max_sum , max_sum_increasing_subseq ( arr , n , j , k ) ) \n            \n        \n    \n    max_sum = max ( max_sum , arr [ i ] + ( arr [ k ] if k < n else 0 ) + ( arr [ j ] if j < n else 0 ) ) \n    \n    return max_sum \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 101, 2, 3, 100, 4, 5], 7, 4, 6]], "plus_fail_tests": [[[5, 2, 4, 1, 3, 6], 6, 1, 3]]}], "Mbpp/451": [{"task_id": "Mbpp/451", "solution": "def remove_whitespaces ( s ) : \n    return s . replace ( \" \" , \"\" ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/284": [{"task_id": "Mbpp/284", "solution": "def check_element ( lst , element ) : \n    for item in lst : \n        if item != element : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/297": [{"task_id": "Mbpp/297", "solution": "def flatten_list ( nested_list ) : \n    flat_list = [ ] \n    \n    for item in nested_list : \n        if isinstance ( item , list ) : \n            flat_list . extend ( flatten_list ( item ) ) \n        else : \n            flat_list . append ( item ) \n        \n    \n    return flat_list \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/309": [{"task_id": "Mbpp/309", "solution": "def maximum ( a , b ) : \n    if a > b : \n        return a \n    else : \n        return b \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/406": [{"task_id": "Mbpp/406", "solution": "def find_Parity ( n ) : \n    return n % 2 != 0 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/455": [{"task_id": "Mbpp/455", "solution": "def check_monthnumb_number ( month_number ) : \n    thirty_one_days_months = [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] \n    \n    return month_number in thirty_one_days_months \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/409": [{"task_id": "Mbpp/409", "solution": "def min_product_tuple ( list1 ) : \n    min_product = float ( 'inf' ) \n    \n    for tup in list1 : \n        product = tup [ 0 ] * tup [ 1 ] \n        \n        if product < min_product : \n            min_product = product \n            \n        \n    \n    return min_product \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/419": [{"task_id": "Mbpp/419", "solution": "def round_and_sum ( numbers ) : \n    rounded_numbers = [ round ( num ) for num in numbers ] \n    \n    total_sum = sum ( rounded_numbers ) \n    \n    result = total_sum * len ( numbers ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/390": [{"task_id": "Mbpp/390", "solution": "def add_string ( lst , str ) : \n    return [ str . format ( i ) for i in lst ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/440": [{"task_id": "Mbpp/440", "solution": "def find_adverb_position ( sentence ) : \n    adverb_list = [ 'clearly' , 'seriously' , 'unfortunately' ] \n    \n    positions = [ ] \n    \n    for i in range ( len ( adverb_list ) ) : \n        start_index = sentence . find ( adverb_list [ i ] ) \n        \n        end_index = start_index + len ( adverb_list [ i ] ) \n        \n        positions . append ( ( start_index , end_index , adverb_list [ i ] ) ) \n    \n    return positions \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["clearly!! we can see the sky"]], "plus_fail_tests": [["heavily and quickly we ran down the steep hill"]]}], "Mbpp/415": [{"task_id": "Mbpp/415", "solution": "def max_Product ( nums ) : \n    max_product = float ( '-inf' ) \n    \n    second_max = float ( '-inf' ) \n    \n    max_val = float ( '-inf' ) \n    \n    for num in nums : \n        if num > max_val : \n            second_max = max_val \n            \n            max_val = num \n            \n        elif num > second_max : \n            second_max = num \n            \n        \n    \n    return ( second_max , max_val ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[0, -1, -2, -4, 5, 0, -6]]], "plus_fail_tests": [[[10, -20, 30, -40, 50, -60, 70, -80, 90, -100]]]}], "Mbpp/397": [{"task_id": "Mbpp/397", "solution": "def median_numbers ( a , b , c ) : \n    if a <= b <= c or c <= b <= a : \n        median = b \n        \n    elif b <= a <= c or c <= a <= b : \n        median = a \n        \n    else : \n        median = c \n        \n    \n    return median \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/432": [{"task_id": "Mbpp/432", "solution": "def median_trapezium ( a , b , c ) : \n    trapezium_area = ( a + b + c ) / 2 \n    \n    median_length = ( a + b + c - trapezium_area ) / 2 \n    \n    return median_length \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[15, 25, 35]], "plus_fail_tests": [[2.3, 4.7, 3.9]]}], "Mbpp/424": [{"task_id": "Mbpp/424", "solution": "def extract_rear ( string_tuple ) : \n    result = [ ] \n    \n    for word in string_tuple : \n        result . append ( word [ - 1 ] ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/426": [{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers ( input_list ) : \n    output_list = [ num for num in input_list if num % 2 == 0 ] \n    \n    return output_list \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]], "plus_fail_tests": [[[-5, 0, 5, -10, 15, 20, -25, 30]]]}], "Mbpp/425": [{"task_id": "Mbpp/425", "solution": "def count_element_in_list ( list_of_lists , element ) : \n    count = 0 \n    \n    for sublist in list_of_lists : \n        if element in sublist : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/418": [{"task_id": "Mbpp/418", "solution": "def Find_Max ( lst ) : \n    max_len = max ( len ( i ) for i in lst ) \n    \n    return [ j for i in lst for j in i if len ( i ) == max_len ] \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], []]]]}], "Mbpp/410": [{"task_id": "Mbpp/410", "solution": "def min_val ( list ) : \n    min_val = list [ 0 ] \n    \n    for i in list : \n        if type ( i ) == str : \n            continue \n        \n        if i < min_val : \n            min_val = i \n            \n        \n    \n    return min_val \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python", 3, 2, 4, 5, "version"]]], "plus_fail_tests": [[["Python", 10, 5, 2.5, 2.5, "version"]]]}], "Mbpp/412": [{"task_id": "Mbpp/412", "solution": "def remove_odd ( lst ) : \n    return [ num for num in lst if num % 2 == 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/441": [{"task_id": "Mbpp/441", "solution": "def surfacearea_cube ( size ) : \n    surfacearea = 6 * ( size ** 2 ) \n    \n    return surfacearea \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/420": [{"task_id": "Mbpp/420", "solution": "def cube_Sum ( n ) : \n    sum = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        sum = sum + ( 2 * i ) \n        \n    \n    sum = sum * sum \n    \n    return sum \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[100]]}], "Mbpp/398": [{"task_id": "Mbpp/398", "solution": "def sum_of_digits ( lst ) : \n    total = 0 \n    \n    for i in lst : \n        if isinstance ( i , list ) : \n            total += sum_of_digits ( i ) \n        else : \n            total += sum ( int ( digit ) for digit in str ( i ) ) \n        \n    \n    return total \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 20, 4, 5, "b", 70, "a"]]]], "plus_fail_tests": [[[-10, 15, 0, -5, 2]]]}], "Mbpp/405": [{"task_id": "Mbpp/405", "solution": "def check_tuplex ( tuplex , element ) : \n    return element in tuplex \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/473": [{"task_id": "Mbpp/473", "solution": "def tuple_intersection ( test_list1 , test_list2 ) : \n    res = dict ( ) \n    \n    for ele in test_list1 : \n        res [ ele ] = True \n        \n    \n    for ele in test_list2 : \n        if ele in res : \n            res [ ele ] = True \n            \n        \n    \n    res = { key : val for key , val in res . items ( ) if val } \n    \n    return res \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 4], [5, 6], [9, 10], [4, 5]], [[5, 4], [3, 4], [6, 5], [9, 11]]]], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[1, 2, 3], [7, 8, 9], [10, 11, 12]]]]}], "Mbpp/422": [{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube ( n ) : \n    sum = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        sum += i ** 3 \n    \n    return sum / n \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/463": [{"task_id": "Mbpp/463", "solution": "def max_subarray_product ( nums ) : \n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\" \n    max_product = min_product = result = nums [ 0 ] \n    \n    \n    \n    for i in range ( 1 , len ( nums ) ) : \n        if nums [ i ] < 0 : \n            max_product , min_product = min_product , max_product \n            \n        \n        max_product = max ( nums [ i ] , max_product * nums [ i ] ) \n        \n        min_product = min ( nums [ i ] , min_product * nums [ i ] ) \n        \n        result = max ( result , max_product ) \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/428": [{"task_id": "Mbpp/428", "solution": "def shell_sort ( arr ) : \n    gap = len ( arr ) // 2 \n    \n    while gap > 0 : \n        for i in range ( gap , len ( arr ) ) : \n            temp = arr [ i ] \n            \n            j = i \n            \n            while j >= gap and arr [ j - gap ] > temp : \n                arr [ j ] = arr [ j - gap ] \n                \n                j -= gap \n            \n            arr [ j ] = temp \n            \n        \n        gap //= 2 \n    \n    return arr \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/437": [{"task_id": "Mbpp/437", "solution": "def remove_odd ( s ) : \n    result = \"\" \n    \n    for i in s : \n        if ord ( i ) % 2 == 0 : \n            result += i \n        \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python"]], "plus_fail_tests": [["Hello, world!"]]}], "Mbpp/460": [{"task_id": "Mbpp/460", "solution": "def Extract ( lst ) : \n    result = [ ] \n    \n    for sublist in lst : \n        result . append ( sublist [ 0 ] ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/456": [{"task_id": "Mbpp/456", "solution": "def reverse_string_list ( string_list ) : \n    reversed_list = [ ] \n    \n    for string in string_list : \n        reversed_list . append ( string [ : : - 1 ] ) \n    \n    return reversed_list \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/429": [{"task_id": "Mbpp/429", "solution": "def and_tuples ( t1 , t2 ) : \n    result = tuple ( a - b for a , b in zip ( t1 , t2 ) ) \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[10, 4, 6, 9], [5, 2, 3, 3]]], "plus_fail_tests": [[[123, 456, 789, 10], [987, 654, 321, 10]]]}], "Mbpp/447": [{"task_id": "Mbpp/447", "solution": "def cube_nums ( nums ) : \n    result = [ num ** 3 for num in nums ] \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/433": [{"task_id": "Mbpp/433", "solution": "def check_greater ( arr , num ) : \n    for i in arr : \n        if i > num : \n            return True \n        \n    \n    return False \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5], 4]], "plus_fail_tests": [[[], 10]]}], "Mbpp/439": [{"task_id": "Mbpp/439", "solution": "def multiple_to_single ( num_list ) : \n    result = 0 \n    \n    for num in num_list : \n        result = result * 10 + num \n        \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[11, 33, 50]]], "plus_fail_tests": [[[1000000, 999999, 100000, 99999]]]}], "Mbpp/450": [{"task_id": "Mbpp/450", "solution": "def extract_string ( input_list , size ) : \n    result = [ ] \n    \n    for string in input_list : \n        if len ( string ) == size : \n            result . append ( string ) \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/454": [{"task_id": "Mbpp/454", "solution": "import re \ndef text_match_wordz ( text ) : \n    pattern = 'z.*' \n    \n    if re . search ( pattern , text ) : \n        return True \n    else : \n        return False \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/471": [{"task_id": "Mbpp/471", "solution": "def find_remainder ( arr , n ) : \n    product = 1 \n    \n    for num in arr : \n        product = ( product * num ) % n \n        \n    \n    return product \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/445": [{"task_id": "Mbpp/445", "solution": "def index_multiplication ( test_tup1 , test_tup2 ) : \n    res = [ ] \n    \n    for tup1 , tup2 in zip ( test_tup1 , test_tup2 ) : \n        res_tup = ( ) \n        \n        for num1 , num2 in zip ( tup1 , tup2 ) : \n            res_tup += ( num1 * num2 , ) \n        \n        res . append ( res_tup ) \n    \n    return tuple ( res ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/475": [{"task_id": "Mbpp/475", "solution": "def sort_counter ( counter ) : \n    return sorted ( counter . items ( ) , key = lambda x : x [ 1 ] ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"Math": 81, "Physics": 83, "Chemistry": 87}]], "plus_fail_tests": [[{"A": -10, "B": 20, "C": -5, "D": 15, "E": 0}]]}], "Mbpp/478": [{"task_id": "Mbpp/478", "solution": "def remove_lowercase ( s ) : \n    i = 0 \n    \n    result = \"\" \n    \n    while i < len ( s ) : \n        if s [ i ] . isupper ( ) : \n            result += s [ i ] \n        \n        i += 1 \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/470": [{"task_id": "Mbpp/470", "solution": "def add_pairwise ( tup ) : \n    res = tuple ( a + b for a , b in zip ( tup [ : - 1 ] , tup [ 1 : ] ) ) \n    \n    return res \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/459": [{"task_id": "Mbpp/459", "solution": "def remove_uppercase ( s ) : \n    result = '' \n    \n    uppercase_start = False \n    \n    for char in s : \n        if char . isupper ( ) : \n            uppercase_start = True \n            \n        \n        if not uppercase_start : \n            result += char \n        \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["cAstyoUrFavoRitETVshoWs"]], "plus_fail_tests": [["ThiS%^%!s&a(mY)TesTStR%i*ng"]]}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "def extract_values ( s ) : \n    s = s [ 1 : - 1 ] \n    \n    values = [ ] \n    \n    current_value = \"\" \n    \n    in_quotes = False \n    \n    for char in s : \n        if char == '\"' : \n            if in_quotes : \n                values . append ( current_value ) \n                current_value = \"\" \n                \n            \n            in_quotes = not in_quotes \n            \n        elif in_quotes : \n            current_value += char \n        \n    \n    return values \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["\"Python\", \"PHP\", \"Java\""]], "plus_fail_tests": [["\"red\" \"blue\" \"green\" \"yellow\" \"red\" \"blue\" \"green\" \"yellow\""]]}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "def two_unique_nums ( nums ) : \n    num_set = set ( ) \n    \n    unique_nums = [ ] \n    \n    for num in nums : \n        if num not in num_set : \n            num_set . add ( num ) \n            unique_nums . append ( num ) \n        \n    \n    return unique_nums \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 2, 3, 4, 5]]], "plus_fail_tests": [[[1, 2, 3, 2, 4, 5, 3, 6, 4, 7, 8, 9, 5, 6]]]}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "def toggle_string ( s ) : \n    result = \"\" \n    \n    for char in s : \n        if char . isupper ( ) : \n            result += char . lower ( ) \n        else : \n            result += char . upper ( ) \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/446": [{"task_id": "Mbpp/446", "solution": "def count_Occurrence ( lst , sub_lst ) : \n    count = 0 \n    \n    for i in lst : \n        if i in sub_lst : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 1, 1, 2, 2, 2, 3, 3, 3], [1, 1, 2, 2, 3, 3]]]}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "def Split ( lst ) : \n    return [ i for i in lst if i % 2 != 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/436": [{"task_id": "Mbpp/436", "solution": "def neg_nos ( lst ) : \n    return [ num for num in lst if num < 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "def split ( string ) : \n    return list ( string ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/477": [{"task_id": "Mbpp/477", "solution": "def is_lower ( s ) : \n    return s . lower ( ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "def issort_list ( lst ) : \n    return lst == sorted ( lst ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/474": [{"task_id": "Mbpp/474", "solution": "def replace_char ( s , old_char , new_char ) : \n    result = \"\" \n    \n    for char in s : \n        if char == old_char : \n            result += new_char \n        else : \n            result += char \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/448": [{"task_id": "Mbpp/448", "solution": "def cal_sum ( n ) : \n    sum = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        sum += i \n    \n    return sum \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9]], "plus_fail_tests": [[-5]]}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "def empty_list ( n ) : \n    return [ { } for _ in range ( n ) ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/468": [{"task_id": "Mbpp/468", "solution": "def max_product ( nums ) : \n    max_product = nums [ 0 ] \n    \n    min_product = nums [ 0 ] \n    \n    result = nums [ 0 ] \n    \n    for i in range ( 1 , len ( nums ) ) : \n        temp = max_product \n        \n        max_product = max ( nums [ i ] , max_product * nums [ i ] , min_product * nums [ i ] ) \n        \n        min_product = min ( nums [ i ] , temp * nums [ i ] , min_product * nums [ i ] ) \n        \n        result = max ( result , max_product ) \n        \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 100, 4, 5, 150, 6]]], "plus_fail_tests": [[[-3, -100, -4, -5, -150, -6]]]}], "Mbpp/472": [{"task_id": "Mbpp/472", "solution": "def check_Consecutive ( lst ) : \n    lst . sort ( ) \n    for i in range ( len ( lst ) - 1 ) : \n        if lst [ i + 1 ] - lst [ i ] != 1 : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/457": [{"task_id": "Mbpp/457", "solution": "def Find_Min ( lst ) : \n    min_length = float ( 'inf' ) \n    \n    result = [ ] \n    \n    for sublist in lst : \n        if len ( sublist ) < min_length : \n            min_length = len ( sublist ) \n            \n            result = sublist \n            \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "def Find_Max_Length ( lst ) : \n    max_length = 0 \n    \n    for sublist in lst : \n        if len ( sublist ) > max_length : \n            max_length = len ( sublist ) \n            \n        \n    \n    return max_length \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "def union_elements ( t1 , t2 ) : \n    union_set = set ( t1 ) \n    \n    union_set . update ( t2 ) \n    sorted_union = sorted ( union_set ) \n    \n    return tuple ( sorted_union ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "def digit_distance_nums ( num1 , num2 ) : \n    distance = 0 \n    \n    while num1 > 0 or num2 > 0 : \n        digit1 = num1 % 10 \n        \n        digit2 = num2 % 10 \n        \n        distance += abs ( digit1 - digit2 ) \n        num1 //= 10 \n        num2 //= 10 \n    \n    return distance \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/479": [{"task_id": "Mbpp/479", "solution": "def first_Digit ( n ) : \n    return int ( str ( n ) [ 0 ] ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/476": [{"task_id": "Mbpp/476", "solution": "def big_sum ( arr ) : \n    min_val = min ( arr ) \n    \n    max_val = max ( arr ) \n    \n    return min_val + max_val \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "def sort_sublists ( lst ) : \n    return [ sorted ( sublist ) for sublist in lst ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/465": [{"task_id": "Mbpp/465", "solution": "def drop_empty ( d ) : \n    return { k : v for k , v in d . items ( ) if v is not None } \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/458": [{"task_id": "Mbpp/458", "solution": "def rectangle_area ( length , width ) : \n    return length * width \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "def difference ( n ) : \n    sum_of_cubes = sum ( [ i ** 3 for i in range ( 1 , n + 1 ) ] ) \n    \n    sum_of_numbers = sum ( range ( 1 , n + 1 ) ) \n    \n    return sum_of_cubes - sum_of_numbers \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair ( arr , x ) : \n    odd_count = 0 \n    \n    even_count = 0 \n    \n    for i in arr : \n        if i % 2 == 0 : \n            even_count += 1 \n        else : \n            odd_count += 1 \n        \n    \n    return odd_count * even_count \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 2], 10]]}], "Mbpp/427": [{"task_id": "Mbpp/427", "solution": "def change_date_format ( date ) : \n    date_list = date . split ( '-' ) \n    \n    new_date = '-' . join ( date_list [ : : - 1 ] ) \n    \n    return new_date \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["2021-1-026"]]}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum ( arr , n ) : \n    max_sum = 0 \n    \n    current_sum = 0 \n    \n    for i in range ( 0 , n ) : \n        current_sum = 0 \n        \n        for j in range ( i , n ) : \n            current_sum += arr [ j ] \n            if current_sum > max_sum : \n                max_sum = current_sum \n                \n            \n        \n    \n    return max_sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "def sum_digits ( n ) : \n    sum = 0 \n    \n    while n > 0 : \n        sum += n % 10 \n        n = n // 10 \n        \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "def count_Pairs ( lst , n ) : \n    count = 0 \n    \n    for i in range ( n - 1 ) : \n        for j in range ( i + 1 , n ) : \n            if lst [ i ] != lst [ j ] : \n                count += 1 \n            \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "def extract_even ( tup ) : \n    result = [ ] \n    \n    for item in tup : \n        if isinstance ( item , tuple ) : \n            result = tuple ( filter ( lambda x : x % 2 == 0 , extract_even ( item ) ) ) \n            \n        elif item % 2 == 0 : \n            result . append ( item ) \n        \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4, 5, [7, 6, [2, 4]], 6, 8]]], "plus_fail_tests": [[[1, 2, 3, [4, 5, [6, 7, [8, 9, [10, 11, [12, 13, [14, 15, [16, 17, [18, 19, [20]]]]]]]]]]]]}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "def surface_area ( base_edge , height ) : \n    base_area = base_edge ** 2 \n    \n    lateral_area = 2 * base_edge * height \n    \n    surface_area = base_area + lateral_area \n    \n    return surface_area \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "import math \ndef polar_rect ( r , theta ) : \n    x = r * math . cos ( theta ) \n    \n    y = r * math . sin ( theta ) \n    \n    return ( x , y ) , - 2 + 2 * math . pi ** 2 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4]], "plus_fail_tests": [[0, 0]]}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "def find_dissimilar ( t1 , t2 ) : \n    set1 = set ( t1 ) \n    \n    set2 = set ( t2 ) \n    \n    dissimilar_elements = set1 . symmetric_difference ( set2 ) \n    \n    return tuple ( dissimilar_elements ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "def last_Digit_Factorial ( n ) : \n    if n < 0 : \n        return None \n    \n    factorial = 1 \n    \n    for i in range ( 1 , n + 1 ) : \n        factorial *= i \n        factorial %= 10 \n    \n    return factorial \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2.5]]}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "def catalan_number ( n ) : \n    if n <= 1 : \n        return 1 \n    \n    catalan = [ 0 for i in range ( n + 1 ) ] \n    \n    catalan [ 0 ] = 1 \n    \n    catalan [ 1 ] = 1 \n    \n    for i in range ( 2 , n + 1 ) : \n        for j in range ( i ) : \n            catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] \n        \n    \n    return catalan [ n ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "def perfect_squares ( start , end ) : \n    squares = [ ] \n    \n    for i in range ( int ( start ** 0.5 ) , int ( end ** 0.5 ) + 1 ) : \n        square = i * i \n        \n        if square >= start : \n            squares . append ( square ) \n        \n    \n    return squares \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-10, -1]]}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "def big_diff ( nums ) : \n    max_val = max ( nums ) \n    \n    min_val = min ( nums ) \n    \n    return max_val - min_val \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/615": [{"task_id": "Mbpp/615", "solution": "def average_tuple ( tuples ) : \n    result = [ ] \n    \n    for t in tuples : \n        average = sum ( t ) / len ( t ) \n        \n        result . append ( average ) \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]]], "plus_fail_tests": [[[[7, 8, 9], [-2, -4, -6], [0, 20, 30]]]]}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "def unique_product ( lst ) : \n    unique_nums = set ( lst ) \n    \n    product = 1 \n    \n    for num in unique_nums : \n        product *= num \n    \n    return product \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "def armstrong_number ( num ) : \n    num_str = str ( num ) \n    \n    num_len = len ( num_str ) \n    \n    sum = 0 \n    \n    for digit in num_str : \n        sum += int ( digit ) ** num_len \n    \n    return sum == num \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "def swap_List ( lst ) : \n    if len ( lst ) > 1 : \n        lst [ 0 ] , lst [ - 1 ] = lst [ - 1 ] , lst [ 0 ] \n        \n    \n    return lst \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/603": [{"task_id": "Mbpp/603", "solution": "def get_ludic ( n ) : \n    ludic_numbers = [ ] \n    \n    for i in range ( 1 , n + 1 ) : \n        is_ludic = True \n        \n        for j in range ( 2 , int ( i ** 0.5 ) + 1 ) : \n            if i % j == 0 : \n                is_ludic = False \n                \n                break \n            \n        \n        if is_ludic : \n            ludic_numbers . append ( i ) \n        \n    \n    return ludic_numbers \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[25]], "plus_fail_tests": [[100]]}], "Mbpp/619": [{"task_id": "Mbpp/619", "solution": "def move_num ( s ) : \n    letters = list ( s ) \n    \n    num_list = [ ] \n    \n    result = [ ] \n    \n    for letter in letters : \n        if letter . isdigit ( ) : \n            num_list . append ( letter ) \n        else : \n            result . append ( letter ) \n        \n    \n    return '' . join ( result + num_list ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "def is_Even ( n ) : \n    return n % 2 == 0 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/606": [{"task_id": "Mbpp/606", "solution": "import math \ndef radian_degree ( degree ) : \n    radian = degree * ( math . pi / 180 ) \n    \n    return radian \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "def split_Arr ( arr , n ) : \n    return arr [ n : ] + arr [ : n ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/614": [{"task_id": "Mbpp/614", "solution": "def cummulative_sum ( lst ) : \n    total = 0 \n    \n    for tup in lst : \n        total += sum ( tup ) \n    \n    return total \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "def diff_even_odd ( lst ) : \n    even = None \n    \n    odd = None \n    \n    for num in lst : \n        if num % 2 == 0 and even is None : \n            even = num \n            \n        elif num % 2 != 0 and odd is None : \n            odd = num \n            \n        \n    \n    return even - odd if even is not None and odd is not None else None \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "def interleave_lists ( list1 , list2 , list3 ) : \n    result = [ ] \n    \n    for i in range ( len ( list1 ) ) : \n        result . append ( list1 [ i ] ) \n        result . append ( list2 [ i ] ) \n        result . append ( list3 [ i ] ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "def sum_Of_product ( n ) : \n    sum = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        sum += ( 2 * i - 1 ) * ( 2 * i - 2 ) // 2 \n    \n    return sum \n\nprint ( sum_Of_product ( 3 ) ) \nprint ( sum_Of_product ( 4 ) ) \nprint ( sum_Of_product ( 1 ) ) \n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[10]]}], "Mbpp/610": [{"task_id": "Mbpp/610", "solution": "def remove_kth_element ( lst , k ) : \n    return lst [ : k ] + lst [ k + 1 : ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, 2, 3, 4, 4, 5, 1], 3]], "plus_fail_tests": [[[1, 2, 3, 4, 5], 1]]}], "Mbpp/624": [{"task_id": "Mbpp/624", "solution": "def is_upper ( s ) : \n    return s . upper ( ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/616": [{"task_id": "Mbpp/616", "solution": "def tuple_modulo ( t1 , t2 ) : \n    return tuple ( a % b for a , b in zip ( t1 , t2 ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/607": [{"task_id": "Mbpp/607", "solution": "import re \ndef find_literals ( string , pattern ) : \n    match = re . search ( pattern , string ) \n    \n    if match : \n        return match . group ( ) , match . start ( ) , match . end ( ) \n    else : \n        return None \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "def expensive_items ( items , n ) : \n    sorted_items = sorted ( items , key = lambda x : x [ 'price' ] , reverse = True ) \n    \n    return sorted_items [ : n ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/602": [{"task_id": "Mbpp/602", "solution": "def first_repeated_char ( s ) : \n    char_set = set ( ) \n    \n    for char in s : \n        if char in char_set : \n            return char \n        \n        char_set . add ( char ) \n    \n    return None \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/628": [{"task_id": "Mbpp/628", "solution": "def replace_spaces ( s ) : \n    return s . replace ( ' ' , '%20' ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/611": [{"task_id": "Mbpp/611", "solution": "def max_of_nth ( matrix , n ) : \n    max_value = matrix [ 0 ] [ n ] \n    \n    for row in matrix : \n        if row [ n ] > max_value : \n            max_value = row [ n ] \n            \n        \n    \n    return max_value \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "def find_kth ( A , B , k ) : \n    lenA = len ( A ) \n    \n    lenB = len ( B ) \n    \n    if lenA < k : \n        return - 1 \n    \n    if lenB < k : \n        return - 1 \n    \n    a = A [ k - 1 ] \n    \n    b = B [ k - 1 ] \n    \n    if a > b : \n        return find_kth ( A , B [ : k - 1 ] , k - lenB - 1 ) \n    elif a < b : \n        return find_kth ( A [ 1 : k - 1 ] , B , k - lenA - 1 ) \n    else : \n        return a \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 3, 6, 7, 9], [1, 4, 8, 10], 5]], "plus_fail_tests": [[[1, 2, 3], [], 1]]}], "Mbpp/629": [{"task_id": "Mbpp/629", "solution": "def Split ( lst ) : \n    return [ i for i in lst if i % 2 == 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "import sys \ndef tuple_size ( t ) : \n    return sys . getsizeof ( t ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/626": [{"task_id": "Mbpp/626", "solution": "import math \ndef triangle_area ( r ) : \n    if r < 0 : \n        return None \n    else : \n        return r * r \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/620": [{"task_id": "Mbpp/620", "solution": "def largest_subset ( nums ) : \n    n = len ( nums ) \n    \n    nums . sort ( ) \n    dp = [ 1 ] * n \n    \n    for i in range ( 1 , n ) : \n        for j in range ( i ) : \n            if nums [ i ] % nums [ j ] == 0 : \n                dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) \n                \n            \n        \n    \n    return max ( dp ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[9, 3, 12, 7, 16, 3, 11, 8, 4, 13, 13]]]}], "Mbpp/622": [{"task_id": "Mbpp/622", "solution": "def get_median ( list1 , list2 , size ) : \n    merged_list = sorted ( list1 + list2 ) \n    \n    median_index = size // 2 \n    \n    median = merged_list [ median_index ] \n    \n    return median \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5]], "plus_fail_tests": [[[1, 4, 7, 10, 13, 16, 19, 22, 25, 28], [2, 5, 8, 11, 14, 17, 20, 23, 26, 29], 10]]}], "Mbpp/623": [{"task_id": "Mbpp/623", "solution": "def nth_nums ( nums , n ) : \n    result = [ num ** n for num in nums ] \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/453": [{"task_id": "Mbpp/453", "solution": "def sumofFactors ( n ) : \n    sum = 0 \n    \n    for i in range ( 2 , n + 1 , 2 ) : \n        if n % i == 0 : \n            sum += i \n        \n    \n    return sum \n\nprint ( sumofFactors ( 18 ) ) \nprint ( sumofFactors ( 30 ) ) \nprint ( sumofFactors ( 6 ) ) \n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "def removezero_ip ( ip ) : \n    ip_parts = ip . split ( '.' ) \n    \n    ip_parts = [ str ( int ( part ) ) for part in ip_parts ] \n    \n    return '.' . join ( ip_parts ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["0.0.0.0"]]}], "Mbpp/612": [{"task_id": "Mbpp/612", "solution": "def merge ( lst ) : \n    first_elements = [ ] \n    \n    second_elements = [ ] \n    \n    for sublist in lst : \n        first_elements . append ( sublist [ 0 ] ) \n        second_elements . append ( sublist [ 1 ] ) \n    \n    return [ first_elements , second_elements ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/618": [{"task_id": "Mbpp/618", "solution": "def div_list ( list1 , list2 ) : \n    result = [ ] \n    \n    for i in range ( len ( list1 ) ) : \n        result . append ( list1 [ i ] / list2 [ i ] ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/604": [{"task_id": "Mbpp/604", "solution": "def reverse_words ( s ) : \n    words = s . split ( ' ' ) \n    \n    reversed_words = ' ' . join ( reversed ( words ) ) \n    \n    return reversed_words \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[" "]]}], "Mbpp/608": [{"task_id": "Mbpp/608", "solution": "def bell_Number ( n ) : \n    bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] \n    \n    bell [ 0 ] [ 0 ] = 1 \n    \n    for i in range ( 1 , n + 1 ) : \n        bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] \n        \n        for j in range ( 1 , i + 1 ) : \n            bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] \n            \n        \n    \n    return bell [ n ] [ 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "def list_tuple ( input_list ) : \n    return tuple ( input_list ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/637": [{"task_id": "Mbpp/637", "solution": "def noprofit_noloss ( amount1 , amount2 ) : \n    if amount1 == amount2 : \n        return True \n    elif amount1 > amount2 : \n        return False \n    else : \n        return True \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2000, 5000]], "plus_fail_tests": [[-1500, -1200]]}], "Mbpp/638": [{"task_id": "Mbpp/638", "solution": "def wind_chill ( velocity , temperature ) : \n    wci = 13.12 + 0.6215 * temperature - 11.37 * ( velocity ** 0.16 ) + 0.3965 * temperature * ( velocity ** 0.16 ) \n    \n    return round ( wci ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/632": [{"task_id": "Mbpp/632", "solution": "def move_zero ( nums ) : \n    i = 0 \n    \n    for j in range ( len ( nums ) ) : \n        if nums [ j ] != 0 : \n            nums [ i ] , nums [ j ] = nums [ j ] , nums [ i ] \n            \n            i += 1 \n        \n    \n    return nums \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/723": [{"task_id": "Mbpp/723", "solution": "def count_same_pair ( list1 , list2 ) : \n    count = 0 \n    \n    for i in range ( len ( list1 ) ) : \n        if list1 [ i ] == list2 [ i ] : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/740": [{"task_id": "Mbpp/740", "solution": "def tuple_to_dict ( tup ) : \n    return { tup [ i ] : tup [ i + 1 ] for i in range ( 0 , len ( tup ) - 1 , 2 ) } \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/722": [{"task_id": "Mbpp/722", "solution": "def filter_data ( data , min_height , min_weight ) : \n    filtered_data = { } \n    \n    for student , dimensions in data . items ( ) : \n        height , weight = dimensions \n        \n        if height > min_height and weight > min_weight : \n            filtered_data [ student ] = dimensions \n            \n        \n    \n    return filtered_data \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"Cierra Vega": [6.2, 70], "Alden Cantrell": [5.9, 65], "Kierra Gentry": [6.0, 68], "Pierre Cox": [5.8, 66]}, 6.0, 70]], "plus_fail_tests": [[{"Alice": [5.6, 60], "Bob": [6.1, 70], "Charlie": [5.9, 65], "Dave": [5.11, 72], "Eve": [6.0, 68], "Frank": [5.7, 63]}, 5.8, 65]]}], "Mbpp/639": [{"task_id": "Mbpp/639", "solution": "def sample_nam ( names ) : \n    total = 0 \n    \n    for name in names : \n        if name [ 0 ] . isupper ( ) : \n            total += len ( name ) \n        \n    \n    return total \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["AbCdE", "fGH", "IJKLMnOp", "qrs", "TUVW", "xyz"]]]}], "Mbpp/633": [{"task_id": "Mbpp/633", "solution": "def pair_xor_Sum ( nums , k ) : \n    xor_sum = 0 \n    \n    for i in range ( len ( nums ) ) : \n        for j in range ( i + 1 , len ( nums ) ) : \n            if nums [ i ] ^ nums [ j ] == k : \n                xor_sum += nums [ i ] ^ nums [ j ] \n            \n        \n    \n    return xor_sum \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[5, 9, 7, 6], 4]], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10]]}], "Mbpp/725": [{"task_id": "Mbpp/725", "solution": "import re \ndef extract_quotation ( s ) : \n    return re . findall ( r'\"(.*?)\"' , s ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/742": [{"task_id": "Mbpp/742", "solution": "import math \ndef area_tetrahedron ( side ) : \n    \"\"\"\n    Calculate the area of a tetrahedron with a given side length.\n    \"\"\" \n    area = ( math . sqrt ( 3 ) / 4 ) * side ** 2 \n    \n    return area \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/641": [{"task_id": "Mbpp/641", "solution": "def is_nonagonal ( n ) : \n    return n * ( 7 * n - 5 ) // 2 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/743": [{"task_id": "Mbpp/743", "solution": "def rotate_right ( lst , n ) : \n    n = n % len ( lst ) \n    \n    return lst [ - n : ] + lst [ : - n ] \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 0]]}], "Mbpp/741": [{"task_id": "Mbpp/741", "solution": "def all_Characters_Same ( s ) : \n    return len ( set ( s ) ) == 1 \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/724": [{"task_id": "Mbpp/724", "solution": "def power_base_sum ( base , power ) : \n    num_str = str ( base ** power ) \n    \n    total = 0 \n    \n    for digit in num_str : \n        total += int ( digit ) \n    \n    return total \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/732": [{"task_id": "Mbpp/732", "solution": "def replace_specialchar ( s ) : \n    special_chars = [ ' ' , ',' , '.' ] \n    \n    for char in special_chars : \n        s = s . replace ( char , ':' ) \n        \n    \n    return s \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/631": [{"task_id": "Mbpp/631", "solution": "def replace_spaces ( s ) : \n    return s . replace ( ' ' , '_' ) \n\n", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [["The_Avengers"]], "plus_fail_tests": []}], "Mbpp/721": [{"task_id": "Mbpp/721", "solution": "def maxAverageOfPath ( matrix ) : \n    N = len ( matrix ) \n    \n    dp = [ [ [ - 1 for _ in range ( N + 1 ) ] for _ in range ( N + 1 ) ] for _ in range ( N + 1 ) ] \n    \n    def maxAverage ( i , j , k ) : \n        if i == N or j == N or k == N * N : \n            return 0 \n        \n        if dp [ i ] [ j ] [ k ] != - 1 : \n            return dp [ i ] [ j ] [ k ] \n        \n        ans = 0 \n        \n        if k > 0 : \n            ans = max ( ans , maxAverage ( i , j , k - 1 ) ) \n            \n        \n        if i > 0 and j > 0 : \n            ans = max ( ans , maxAverage ( i - 1 , j - 1 , k - 1 ) ) \n            \n        \n        if i > 0 and k > 0 : \n            ans = max ( ans , maxAverage ( i - 1 , j<|argument_list_py -> \n            \n        \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/644": [{"task_id": "Mbpp/644", "solution": "def reverse_Array_Upto_K ( lst , k ) : \n    return lst [ : k ] [ : : - 1 ] + lst [ k : ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/731": [{"task_id": "Mbpp/731", "solution": "import math \ndef lateralsurface_cone ( r , h ) : \n    sl = math . pi * r * r * ( r + h ) \n    \n    return sl \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 12]], "plus_fail_tests": [[2.5, 8.3]]}], "Mbpp/735": [{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits ( n ) : \n    binary = bin ( n ) [ 2 : ] \n    \n    if len ( binary ) <= 2 : \n        return n \n    \n    binary = binary [ 0 ] + \"\" . join ( \"1\" if bit == \"0\" else \"0\" for bit in binary [ 1 : - 1 ] ) + binary [ - 1 ] \n    \n    return int ( binary , 2 ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[true]]}], "Mbpp/720": [{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple ( t , d ) : \n    return t + d \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4, 5, 6], {"MSAM": 1, "is": 2, "best": 3}]], "plus_fail_tests": [[[], {}]]}], "Mbpp/726": [{"task_id": "Mbpp/726", "solution": "def multiply_elements ( t ) : \n    result = [ ] \n    \n    for i in range ( len ( t ) - 1 ) : \n        result . append ( t [ i ] * t [ i + 1 ] ) \n    \n    return tuple ( result ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/753": [{"task_id": "Mbpp/753", "solution": "def min_k ( list_of_tuples , k ) : \n    list_of_tuples . sort ( key = lambda x : x [ 1 ] ) \n    return list_of_tuples [ : k ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/745": [{"task_id": "Mbpp/745", "solution": "def divisible_by_digits ( startnum , endnum ) : \n    result = [ ] \n    \n    for num in range ( startnum , endnum + 1 ) : \n        digits = [ int ( d ) for d in str ( num ) ] \n        \n        if all ( num % d == 0 for d in digits ) : \n            result . append ( num ) \n        \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 22]], "plus_fail_tests": [[100, 200]]}], "Mbpp/728": [{"task_id": "Mbpp/728", "solution": "def sum_list ( list1 , list2 ) : \n    result = [ ] \n    \n    for i in range ( len ( list1 ) ) : \n        result . append ( list1 [ i ] + list2 [ i ] ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/730": [{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates ( lst ) : \n    if not lst : \n        return [ ] \n    \n    result = [ lst [ 0 ] ] \n    \n    for i in range ( 1 , len ( lst ) ) : \n        if lst [ i ] != lst [ i - 1 ] : \n            result . append ( lst [ i ] ) \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/757": [{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs ( lst ) : \n    count = 0 \n    \n    for i in range ( len ( lst ) ) : \n        for j in range ( i + 1 , len ( lst ) ) : \n            if lst [ i ] == lst [ j ] [ : : - 1 ] : \n                count += 1 \n            \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/767": [{"task_id": "Mbpp/767", "solution": "def get_pairs_count ( nums , sum ) : \n    count = 0 \n    \n    for i in range ( len ( nums ) ) : \n        for j in range ( i + 1 , len ( nums ) ) : \n            if nums [ i ] + nums [ j ] == sum : \n                count += 1 \n            \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/748": [{"task_id": "Mbpp/748", "solution": "def capital_words_spaces ( s ) : \n    result = [ ] \n    \n    for i in range ( len ( s ) ) : \n        if s [ i ] . isupper ( ) and i != 0 : \n            result . append ( ' ' ) \n        \n        result . append ( s [ i ] ) \n    \n    return '' . join ( result ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["MyNameIsAIAndIAmHereToHelpYou"]]}], "Mbpp/758": [{"task_id": "Mbpp/758", "solution": "def unique_sublists ( lst ) : \n    sublist_dict = { } \n    \n    for sublist in lst : \n        sublist_tuple = tuple ( sublist ) \n        \n        if sublist_tuple in sublist_dict : \n            sublist_dict [ sublist_tuple ] += 1 \n        else : \n            sublist_dict [ sublist_tuple ] = 1 \n            \n        \n    \n    return sublist_dict \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/643": [{"task_id": "Mbpp/643", "solution": "def text_match_wordz_middle ( text ) : \n    words = text . split ( ) \n    \n    for word in words : \n        if 'z' in word [ 1 : - 1 ] : \n            return True \n        \n    \n    return False \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/733": [{"task_id": "Mbpp/733", "solution": "def find_first_occurrence ( arr , target ) : \n    left = 0 \n    \n    right = len ( arr ) - 1 \n    \n    result = - 1 \n    \n    while left <= right : \n        mid = left + ( right - left ) // 2 \n        \n        if arr [ mid ] == target : \n            result = mid \n            \n            right = mid - 1 \n            \n        elif arr [ mid ] < target : \n            left = mid + 1 \n            \n        else : \n            right = mid - 1 \n            \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/737": [{"task_id": "Mbpp/737", "solution": "import re \ndef check_str ( str ) : \n    return bool ( re . match ( \"^[aeiouAEIOU]\" , str ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/736": [{"task_id": "Mbpp/736", "solution": "def left_insertion ( arr , target ) : \n    left = 0 \n    \n    right = len ( arr ) - 1 \n    \n    while left <= right : \n        mid = ( left + right ) // 2 \n        \n        if arr [ mid ] < target : \n            left = mid + 1 \n            \n        else : \n            right = mid - 1 \n            \n        \n    \n    return left \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/734": [{"task_id": "Mbpp/734", "solution": "def sum_Of_Subarray_Prod ( arr ) : \n    n = len ( arr ) \n    \n    sum_prod = 0 \n    \n    for i in range ( n ) : \n        product = 1 \n        \n        for j in range ( i , n ) : \n            product *= arr [ j ] \n            sum_prod += product \n        \n    \n    return sum_prod \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/760": [{"task_id": "Mbpp/760", "solution": "def unique_Element ( lst ) : \n    return len ( set ( lst ) ) == 1 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/744": [{"task_id": "Mbpp/744", "solution": "def check_none ( tup ) : \n    return None in tup \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/791": [{"task_id": "Mbpp/791", "solution": "def remove_nested ( tup ) : \n    return tuple ( x for x in tup if not isinstance ( x , tuple ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/759": [{"task_id": "Mbpp/759", "solution": "def is_decimal ( s ) : \n    try : \n        float ( s ) \n        if len ( s . split ( '.' ) [ - 1 ] ) == 2 : \n            return True \n        else : \n            return False \n        \n    except ValueError : \n        return False \n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["-123.11"]]}], "Mbpp/769": [{"task_id": "Mbpp/769", "solution": "def Diff ( list1 , list2 ) : \n    diff = [ ] \n    \n    for i in list1 : \n        if i not in list2 : \n            diff . append ( i ) \n        \n    \n    for i in list2 : \n        if i not in list1 : \n            diff . append ( i ) \n        \n    \n    return diff \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/792": [{"task_id": "Mbpp/792", "solution": "def count_list ( input_list ) : \n    count = 0 \n    \n    for i in input_list : \n        if isinstance ( i , list ) : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/778": [{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates ( lst ) : \n    if not lst : \n        return [ ] \n    \n    result = [ [ lst [ 0 ] ] ] \n    \n    for i in range ( 1 , len ( lst ) ) : \n        if lst [ i ] == lst [ i - 1 ] : \n            result [ - 1 ] . append ( lst [ i ] ) \n        else : \n            result . append ( [ lst [ i ] ] ) \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/750": [{"task_id": "Mbpp/750", "solution": "def add_tuple ( lst , tpl ) : \n    return lst + list ( tpl ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/782": [{"task_id": "Mbpp/782", "solution": "def odd_length_sum ( arr ) : \n    total_sum = 0 \n    \n    for i in range ( len ( arr ) ) : \n        subarray_sum = 0 \n        \n        for j in range ( i , len ( arr ) ) : \n            subarray_sum += arr [ j ] \n            if ( j - i + 1 ) % 2 != 0 : \n                total_sum += subarray_sum \n            \n        \n    \n    return total_sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/752": [{"task_id": "Mbpp/752", "solution": "def jacobsthal_num ( n ) : \n    if n == 0 : \n        return 0 \n    elif n == 1 : \n        return 1 \n    else : \n        a = [ 0 , 1 ] \n        \n        for i in range ( 2 , n + 1 ) : \n            a . append ( 2 * a [ i - 1 ] + a [ i - 2 ] ) \n        \n        return a [ n ] \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[100]]}], "Mbpp/754": [{"task_id": "Mbpp/754", "solution": "def extract_index_list ( l1 , l2 , l3 ) : \n    common_elements = [ ] \n    \n    for i in range ( len ( l1 ) ) : \n        if l1 [ i ] == l2 [ i ] == l3 [ i ] and l1 [ i ] not in common_elements and l2 [ i ] not in common_elements : \n            common_elements . append ( l1 [ i ] ) \n        \n    \n    return common_elements \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 4, 6, 8, 10, 12, 14], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]]]}], "Mbpp/784": [{"task_id": "Mbpp/784", "solution": "def mul_even_odd ( lst ) : \n    even_product = 1 \n    \n    odd_product = 1 \n    \n    even_count = 0 \n    \n    odd_count = 0 \n    \n    for num in lst : \n        if num % 2 == 0 : \n            even_count += 1 \n            even_product *= num \n        else : \n            odd_count += 1 \n            odd_product *= num \n        \n    \n    if even_count == 0 : \n        even_product = 0 \n        \n    \n    if odd_count == 0 : \n        odd_product = 0 \n        \n    \n    return even_product * odd_product \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, 5, 7, 4, 1, 6, 8]]], "plus_fail_tests": [[[-10, -5, 0, 5, 10]]]}], "Mbpp/808": [{"task_id": "Mbpp/808", "solution": "def check_K ( tup , k ) : \n    return k in tup \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/775": [{"task_id": "Mbpp/775", "solution": "def odd_position ( lst ) : \n    for i in range ( 1 , len ( lst ) , 2 ) : \n        if lst [ i ] % 2 == 0 : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/762": [{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number ( month_number ) : \n    if month_number == 6 or month_number == 12 : \n        return False \n    else : \n        return True \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[6]], "plus_fail_tests": [[1]]}], "Mbpp/780": [{"task_id": "Mbpp/780", "solution": "from itertools import combinations \ndef find_combinations ( tuples ) : \n    result = [ ] \n    \n    for r in range ( 1 , len ( tuples ) + 1 ) : \n        for combo in combinations ( tuples , r ) : \n            total = sum ( combo ) \n            \n            result . append ( ( total , ) ) \n        \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [3, 4, 5]]]], "plus_fail_tests": [[[[100, 200], [300, 400], [500, 600], [700, 800]]]]}], "Mbpp/749": [{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings ( lst ) : \n    int_lst = list ( map ( int , lst ) ) \n    \n    int_lst . sort ( ) \n    return int_lst \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/772": [{"task_id": "Mbpp/772", "solution": "def remove_length ( s , k ) : \n    words = s . split ( ) \n    \n    words = [ word for word in words if len ( word ) != k ] \n    \n    return ' ' . join ( words ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/755": [{"task_id": "Mbpp/755", "solution": "def second_smallest ( numbers ) : \n    smallest = second_smallest = float ( 'inf' ) \n    \n    \n    for num in numbers : \n        if num < smallest : \n            second_smallest = smallest \n            \n            smallest = num \n            \n        elif num < second_smallest and num != smallest : \n            second_smallest = num \n            \n        \n    \n    return second_smallest if second_smallest != float ( 'inf' ) else None \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/785": [{"task_id": "Mbpp/785", "solution": "def tuple_str_int ( s ) : \n    t = eval ( s ) \n    \n    return tuple ( t ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["((7, 8, 9)"]]}], "Mbpp/770": [{"task_id": "Mbpp/770", "solution": "def odd_num_sum ( n ) : \n    sum = 0 \n    \n    for i in range ( 1 , 2 * n , 2 ) : \n        sum += i ** 4 \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/793": [{"task_id": "Mbpp/793", "solution": "def last ( arr , x ) : \n    last_pos = - 1 \n    \n    for i in range ( len ( arr ) ) : \n        if arr [ i ] == x : \n            last_pos = i \n            \n        \n    \n    return last_pos \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/803": [{"task_id": "Mbpp/803", "solution": "import math \ndef is_perfect_square ( n ) : \n    sqrt = math . sqrt ( n ) \n    \n    return sqrt . is_integer ( ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-9]]}], "Mbpp/773": [{"task_id": "Mbpp/773", "solution": "def occurance_substring ( string , substring ) : \n    index = string . find ( substring ) \n    \n    if index == - 1 : \n        return None \n    \n    start_index = index \n    \n    end_index = index + len ( substring ) \n    \n    return substring , start_index , end_index \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/763": [{"task_id": "Mbpp/763", "solution": "def find_min_diff ( arr , n ) : \n    arr . sort ( ) \n    min_diff = float ( 'inf' ) \n    \n    for i in range ( 1 , n ) : \n        diff = arr [ i ] - arr [ i - 1 ] \n        \n        if diff < min_diff : \n            min_diff = diff \n            \n        \n    \n    return min_diff \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 5, 3, 19, 18, 25], 6]], "plus_fail_tests": [[[15, 12, 20, 30, 8, 4, 19, 37, 22, 28, 11, 25], 12]]}], "Mbpp/786": [{"task_id": "Mbpp/786", "solution": "def right_insertion ( arr , val ) : \n    left = 0 \n    \n    right = len ( arr ) - 1 \n    \n    while left <= right : \n        mid = ( left + right ) // 2 \n        \n        if arr [ mid ] < val : \n            left = mid + 1 \n            \n        else : \n            right = mid - 1 \n            \n        \n    \n    return left \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[50.64327388212607, -72.16612625583227, 95.25630303581863, -75.73998556144497, 11.857449640680656, -90.20293226837086, -12.02758648076636, -35.964731488229475], false]]}], "Mbpp/794": [{"task_id": "Mbpp/794", "solution": "import re \ndef text_starta_endb ( text ) : \n    pattern = r'a.*b$' \n    \n    return bool ( re . match ( pattern , text ) ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["xaabbyz1323ababb"]]}], "Mbpp/787": [{"task_id": "Mbpp/787", "solution": "import re \ndef text_match_three ( text ) : \n    return bool ( re . search ( r'ab{3}' , text ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/764": [{"task_id": "Mbpp/764", "solution": "def number_ctr ( str ) : \n    count = 0 \n    \n    for char in str : \n        if char . isdigit ( ) : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/801": [{"task_id": "Mbpp/801", "solution": "def test_three_equal ( a , b , c ) : \n    if a == b == c : \n        return 3 \n    else : \n        return 0 \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 2, 2]], "plus_fail_tests": [[10, 10, 20]]}], "Mbpp/807": [{"task_id": "Mbpp/807", "solution": "def first_odd ( nums ) : \n    for num in nums : \n        if num % 2 != 0 : \n            return num \n        \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/630": [{"task_id": "Mbpp/630", "solution": "def get_coordinates ( coordinate ) : \n    x = coordinate [ 0 ] \n    \n    y = coordinate [ 1 ] \n    \n    coordinates = [ ] \n    \n    for i in range ( x - 1 , x + 2 ) : \n        for j in range ( y - 1 , y + 2 ) : \n            coordinates . append ( [ i , j ] ) \n        \n    \n    return coordinates \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 1, 1]]]}], "Mbpp/798": [{"task_id": "Mbpp/798", "solution": "def _sum ( arr ) : \n    total = 0 \n    \n    for num in arr : \n        total += num \n    \n    return total \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/777": [{"task_id": "Mbpp/777", "solution": "def find_sum ( lst ) : \n    sum = 0 \n    \n    for i in lst : \n        if lst . count ( i ) == 1 : \n            sum += i \n        \n    \n    return sum \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 1, 1, 4, 5, 6]]], "plus_fail_tests": [[[-1, -2, -3, -1, -1, -4, -5, -6]]]}], "Mbpp/771": [{"task_id": "Mbpp/771", "solution": "def check_expression ( expression ) : \n    stack = [ ] \n    \n    opening_brackets = [ \"(\" , \"[\" , \"{\" ] \n    \n    closing_brackets = [ \")\" , \"]\" , \"}\" ] \n    \n    bracket_pairs = { \")\" : \"(\" , \"]\" : \"[\" , \"}\" : \"{\" } \n    \n    for char in expression : \n        if char in opening_brackets : \n            stack . append ( char ) \n        elif char in closing_brackets : \n            if not stack or bracket_pairs [ char ] != stack . pop ( ) : \n                return False \n            \n        \n    \n    return not stack \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/790": [{"task_id": "Mbpp/790", "solution": "def even_position ( lst ) : \n    for i in range ( 0 , len ( lst ) , 2 ) : \n        if lst [ i ] % 2 != 0 : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 1, 4, 2, 6, 1, 8, 2, 10, 1, 12]]]}], "Mbpp/751": [{"task_id": "Mbpp/751", "solution": "def check_min_heap ( arr ) : \n    n = len ( arr ) \n    \n    for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) : \n        if arr [ i ] > arr [ 2 * i + 1 ] or ( 2 * i + 2 < n and arr [ i ] > arr [ 2 * i + 2 ] ) : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/809": [{"task_id": "Mbpp/809", "solution": "def check_smaller ( t1 , t2 ) : \n    return all ( x < y for x , y in zip ( t1 , t2 ) ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3], [2, 3, 4]]], "plus_fail_tests": [[[3, 7, 11, 15, 19], [2, 6, 10, 14, 18]]]}], "Mbpp/806": [{"task_id": "Mbpp/806", "solution": "def max_run_uppercase ( s ) : \n    max_run = 0 \n    \n    current_run = 0 \n    \n    for char in s : \n        if char . isupper ( ) : \n            current_run += 1 \n            max_run = max ( max_run , current_run ) \n            \n        else : \n            current_run = 0 \n            \n        \n    \n    return max_run \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Aaa"]]}], "Mbpp/800": [{"task_id": "Mbpp/800", "solution": "def remove_all_spaces ( s ) : \n    return s . replace ( \" \" , \"\" ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/799": [{"task_id": "Mbpp/799", "solution": "def left_rotate ( number , d ) : \n    binary_str = bin ( number ) [ 2 : ] \n    \n    binary_str = binary_str . zfill ( 32 ) \n    \n    rotated_str = binary_str [ d : ] + binary_str [ : d ] \n    \n    return int ( rotated_str , 2 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/796": [{"task_id": "Mbpp/796", "solution": "def return_sum ( d ) : \n    sum = 0 \n    \n    for key in d : \n        sum += d [ key ] \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/804": [{"task_id": "Mbpp/804", "solution": "def is_product_even ( lst ) : \n    product = 1 \n    \n    for num in lst : \n        product *= num \n    \n    return product % 2 == 0 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/788": [{"task_id": "Mbpp/788", "solution": "def new_tuple ( lst1 , str1 ) : \n    new_tuple = tuple ( lst1 ) + ( str1 , ) \n    \n    return new_tuple \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/797": [{"task_id": "Mbpp/797", "solution": "def sum_in_range ( l , r ) : \n    sum = 0 \n    \n    for i in range ( l , r + 1 ) : \n        if i % 2 != 0 : \n            sum += i \n        \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/805": [{"task_id": "Mbpp/805", "solution": "def max_sum_list ( lists ) : \n    max_sum = float ( '-inf' ) \n    \n    max_list = [ ] \n    \n    for lst in lists : \n        if sum ( lst ) > max_sum : \n            max_sum = sum ( lst ) \n            \n            max_list = lst \n            \n        \n    \n    return max_list \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/766": [{"task_id": "Mbpp/766", "solution": "def pair_wise ( lst ) : \n    result = [ ] \n    \n    for i in range ( len ( lst ) - 1 ) : \n        result . append ( ( lst [ i ] , lst [ i + 1 ] ) ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "def is_Sub_Array ( list1 , list2 ) : \n    n = len ( list1 ) \n    \n    m = len ( list2 ) \n    \n    if n < m : \n        return False \n    \n    i = 0 \n    \n    j = 0 \n    \n    while ( i < n ) : \n        if list1 [ i ] == list2 [ j ] : \n            i += 1 \n            j += 1 \n            if j == m : \n                return True \n            \n        else : \n            i = i - j \n            \n            j = 0 \n            \n        \n    \n    return False \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 4, 3, 5], [1, 2]]], "plus_fail_tests": [[[], []]]}], "Mbpp/605": [{"task_id": "Mbpp/605", "solution": "def prime_num ( n ) : \n    if n <= 1 : \n        return False \n    \n    for i in range ( 2 , n ) : \n        if n % i == 0 : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[999999999989]]}], "Mbpp/462": [{"task_id": "Mbpp/462", "solution": "def combinations_list ( lst ) : \n    if len ( lst ) == 0 : \n        return [ [ ] ] \n    \n    ans = [ ] \n    \n    for ele in combinations_list ( lst [ 1 : ] ) : \n        size = len ( ele ) \n        \n        for i in range ( size + 1 ) : \n            ans . append ( ele [ : i ] + [ lst [ 0 ] ] + ele [ i : ] ) \n        \n    \n    return ans \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["orange", "red", "green", "blue"]]], "plus_fail_tests": [[["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]]]}], "Mbpp/635": [{"task_id": "Mbpp/635", "solution": "def heap_sort ( lst ) : \n    first = len ( lst ) // 2 - 1 \n    \n    for start in range ( first , - 1 , - 1 ) : \n        big_heap ( lst , start , len ( lst ) - 1 ) \n    \n    for end in range ( len ( lst ) - 1 , 0 , - 1 ) : \n        lst [ 0 ] , lst [ end ] = lst [ end ] , lst [ 0 ] \n        \n        big_heap ( lst , 0 , end - 1 ) \n    \n    return lst \n\ndef big_heap ( lst , start , end ) : \n    root = start \n    \n    child = root * 2 + 1 \n    \n    while child <= end : \n        if child + 1 <= end and lst [ child ] < lst [ child + 1 ] : \n            child += 1 \n        \n        if lst [ root ] < lst [ child ] : \n            lst [ root ] , lst [ child ] = lst [ child ] , lst [ root ] \n            \n            root = child \n            \n            child = root * 2 + intege \n            \n        \n    \n\n", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [[[1, 3, 5, 7, 9, 2, 4, 6, 8, 0]]], "plus_fail_tests": []}], "Mbpp/739": [{"task_id": "Mbpp/739", "solution": "def find_Index ( n ) : \n    i = 1 \n    \n    while True : \n        triangular = i * ( i + 1 ) // 2 \n        \n        if len ( str ( triangular ) ) == n : \n            return i \n        \n        i += 1 \n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[100]]}], "Mbpp/765": [{"task_id": "Mbpp/765", "solution": "def is_polite ( n ) : \n    polite_numbers = [ ] \n    \n    i = 1 \n    \n    while len ( polite_numbers ) < n : \n        if all ( i % j != 0 for j in range ( 2 , int ( i ** 0.5 ) + 1 ) ) : \n            polite_numbers . append ( i ) \n        \n        i += 1 \n    \n    return polite_numbers [ - 1 ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7]], "plus_fail_tests": [[10000000]]}], "Mbpp/781": [{"task_id": "Mbpp/781", "solution": "def count_divisors ( n ) : \n    count = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        if n % i == 0 : \n            count += 1 \n        \n    \n    return count % 2 == 0 \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[987654321]]}], "Mbpp/271": [{"task_id": "Mbpp/271", "solution": "def even_Power_Sum ( n ) : \n    sum = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        even = 2 * i \n        \n        sum += even ** 5 \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/255": [{"task_id": "Mbpp/255", "solution": "from itertools import combinations_with_replacement \ndef combinations_colors ( colors , n ) : \n    return [ tuple ( c ) for c in combinations_with_replacement ( colors , n ) ] \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["Dog", "Cat", "CatBird", "Bird", "Fish"], 77]]}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "def sum_average ( n ) : \n    sum_of_numbers = 0 \n    \n    average = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        sum_of_numbers += i \n    \n    average = sum_of_numbers / n \n    \n    return sum_of_numbers , average \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}}