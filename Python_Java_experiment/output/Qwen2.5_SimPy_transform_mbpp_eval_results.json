{"date": "2025-06-05 03:26", "hash": "ee43ecabebf20deef4bb776a405ac5b1", "eval": {"Mbpp/2": [{"task_id": "Mbpp/2", "solution": "\ndef similar_elements (list1, list2):\n    return set(list1)&set(list2)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/4": [{"task_id": "Mbpp/4", "solution": "\nimport heapq\ndef heap_queue_largest (nums, n):\n    largest_nums=heapq.nlargest(n, nums)\n    return largest_nums\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/3": [{"task_id": "Mbpp/3", "solution": "\ndef is_not_prime (n):\n    if n<=1:\n        return  True \n        \n    for i in range(2, int(n**0.5)+1):\n        if n%i==0:\n            return  True \n            \n    \n    return  False \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/6": [{"task_id": "Mbpp/6", "solution": "\ndef differ_At_One_Bit_Pos (x, y):\n    x_bin=bin(x)[2:]\n    y_bin=bin(y)[2:]\n    max_len=max(len(x_bin), len(y_bin))\n    x_bin=x_bin.zfill(max_len)\n    y_bin=y_bin.zfill(max_len)\n    differ_at_one_bit= False \n    for i in range(max_len):\n        if x_bin[i]!=y_bin[i]:\n            differ_at_one_bit= True \n            break \n            \n    \n    return differ_at_one_bit\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[15, 8]], "plus_fail_tests": [[-10, 10]]}], "Mbpp/7": [{"task_id": "Mbpp/7", "solution": "\ndef find_char_long (s:str)->list:\n    words=s.split()\n    result=[word for word in words if len(word)>=4]\n    return result\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["This is a very long string with no words that are at least 4 characters long."]]}], "Mbpp/56": [{"task_id": "Mbpp/56", "solution": "\ndef check (num):\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n    \"\"\"\n    reverse_num=int(str(num)[::-1])\n    return num==2*reverse_num-1\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/8": [{"task_id": "Mbpp/8", "solution": "\ndef square_nums (nums):\n    return [num**2 for num in nums]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/12": [{"task_id": "Mbpp/12", "solution": "\ndef sort_matrix (matrix):\n    row_sums=[(sum(row), row) for row in matrix]\n    sorted_row_sums=sorted(row_sums, key=lambda x:x[0])\n    sorted_matrix=[row for _,row in sorted_row_sums]\n    return sorted_matrix\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/11": [{"task_id": "Mbpp/11", "solution": "\ndef remove_Occ (s, char):\n    index1=s.find(char)\n    index2=s.rfind(char)\n    if index1==-1 or index2==-1:\n        return s\n        \n    return s[:index1]+s[index1+1:][:index2]+s[index2+1:]\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["hello", "l"]], "plus_fail_tests": [["aaa", "a"]]}], "Mbpp/109": [{"task_id": "Mbpp/109", "solution": "\ndef odd_Equivalent (str, n):\n    cnt=0\n    for i in range(len(str)):\n        if int(str[i])%2==1:\n            cnt+=1\n            \n        if n%2==1 and i!=len(str)-1:\n            n=n-1\n            \n        if n%2==0 and i!=0:\n            n=n-1\n            \n    \n    return cnt\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["1100110011", 5]]}], "Mbpp/65": [{"task_id": "Mbpp/65", "solution": "\ndef recursive_list_sum (lst):\n    total=0\n    for element in lst:\n        if isinstance(element, list):\n            total+=recursive_list_sum(element)\n            \n        \n        else :\n            total+=element\n            \n    \n    return total\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/68": [{"task_id": "Mbpp/68", "solution": "\ndef is_Monotonic (nums):\n    increasing=decreasing= True \n    for i in range(1, len(nums)):\n        if nums[i]>nums[i-1]:\n            decreasing= False \n            \n        if nums[i]<nums[i-1]:\n            increasing= False \n            \n    \n    return increasing or decreasing\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/111": [{"task_id": "Mbpp/111", "solution": "\ndef common_in_nested_lists (nested_lists):\n    common_elements=set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n    return common_elements\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/58": [{"task_id": "Mbpp/58", "solution": "\ndef opposite_Signs (a, b):\n    return a*b<0\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/20": [{"task_id": "Mbpp/20", "solution": "\ndef is_woodall (n):\n    return n%29==0\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[383]], "plus_fail_tests": [[true]]}], "Mbpp/66": [{"task_id": "Mbpp/66", "solution": "\ndef pos_count (nums):\n    count=0\n    for num in nums:\n        if num>0:\n            count+=1\n            \n    \n    return count\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/19": [{"task_id": "Mbpp/19", "solution": "\ndef test_duplicate (arr):\n    seen=set()\n    for num in arr:\n        if num in seen:\n            return  True \n            \n        seen.add(num)\n        \n    return  False \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/57": [{"task_id": "Mbpp/57", "solution": "\ndef find_Max_Num (digits):\n    digits=list(map(str, digits))\n    digits.sort(reverse= True )\n    return int(''.join(digits))\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/145": [{"task_id": "Mbpp/145", "solution": "\ndef max_Abs_Diff (arr):\n    max_val=max(arr)\n    min_val=min(arr)\n    return abs(max_val-min_val)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/142": [{"task_id": "Mbpp/142", "solution": "\ndef count_samepair (list1, list2, list3):\n    count=0\n    for i in range(len(list1)):\n        if list1[i]==list2[i]==list3[i]:\n            count+=1\n            \n    \n    return count\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8]]]}], "Mbpp/80": [{"task_id": "Mbpp/80", "solution": "\ndef tetrahedral_number (n):\n    return n*(n+1)*(n+2)//6\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/71": [{"task_id": "Mbpp/71", "solution": "\ndef comb_sort (arr):\n    gap=len(arr)\n    swapped= True \n    while gap>1 or swapped is  True :\n        gap=max(1, int(gap/1.3))\n        swapped= False \n        for i in range(len(arr)-gap):\n            if arr[i]>arr[i+gap]:\n                arr[i],arr[i+gap]=arr[i+gap], arr[i]\n                swapped= True \n                \n        \n    \n    return arr\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/77": [{"task_id": "Mbpp/77", "solution": "\ndef is_Diff (n):\n    return n%11==0\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/85": [{"task_id": "Mbpp/85", "solution": "\nimport math\ndef surfacearea_sphere (r):\n    surface_area=4*math.pi*r**2\n    return surface_area\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/135": [{"task_id": "Mbpp/135", "solution": "\ndef hexagonal_num (n):\n    return n*(2*n-1)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/119": [{"task_id": "Mbpp/119", "solution": "\ndef search (nums):\n    if len(nums)==1:\n        return nums[0]\n        \n    left,right=0, len(nums)-1\n    while left<right:\n        mid=left+(right-left)//2\n        if nums[mid]==nums[mid+1]:\n            left=mid+2\n            \n        \n        else :\n            right=mid\n            \n    \n    return nums[left]\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]]], "plus_fail_tests": [[[]]]}], "Mbpp/14": [{"task_id": "Mbpp/14", "solution": "\ndef find_Volume (base, height, length):\n    volume=(1/2)*base*height*length\n    return volume\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/102": [{"task_id": "Mbpp/102", "solution": "\ndef snake_to_camel (snake_str):\n    components=snake_str.split('_')\n    return ''.join(x.title() for x in components)\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["___python_program"]]}], "Mbpp/16": [{"task_id": "Mbpp/16", "solution": "\nimport re\ndef text_lowercase_underscore (text):\n    return bool(re.search(r'^[a-z]+_[a-z]+$', text))\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z"]]}], "Mbpp/232": [{"task_id": "Mbpp/232", "solution": "\ndef larg_nnum (lst, n):\n    return sorted(lst, reverse= True )[:n]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/84": [{"task_id": "Mbpp/84", "solution": "\ndef sequence (n):\n    \"\"\"\n    Calculate the nth number in the newman conway sequence.\n    \n    Args:\n    n (int): The position in the sequence to calculate.\n    \n    Returns:\n    int: The nth number in the newman conway sequence.\n    \"\"\"\n    if n==1:\n        return 1\n        \n    \n    elif n==2:\n        return 2\n        \n    \n    else :\n        a,b=1, 2\n        for _ in range(3, n+1):\n            a,b=b, a+b\n            \n        return b\n        \n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[100]]}], "Mbpp/130": [{"task_id": "Mbpp/130", "solution": "\nfrom collections import Counter\ndef max_occurrences (arr):\n    counter=Counter(arr)\n    max_val=max(list(counter.values()))\n    for key,val in counter.items():\n        if val==max_val:\n            return key\n            \n    \n\n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/74": [{"task_id": "Mbpp/74", "solution": "\ndef is_samepatterns (patterns:list, strings:list)->bool:\n    if len(patterns)!=len(strings):\n        return  False \n        \n    for i in range(len(patterns)):\n        if patterns[i] not  in strings[i]:\n            return  False \n            \n    \n    return  True \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["red", "green", "green"], ["a", "b", "b"]]], "plus_fail_tests": [[["red", "green", "blue"], ["a", "b", "c"]]]}], "Mbpp/64": [{"task_id": "Mbpp/64", "solution": "\ndef subject_marks (test_list):\n    return sorted(test_list, key=lambda x:x[1])\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/108": [{"task_id": "Mbpp/108", "solution": "\ndef merge_sorted_list (list1, list2, list3):\n    return sorted(list1+list2+list3)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/82": [{"task_id": "Mbpp/82", "solution": "\nimport math\ndef volume_sphere (radius):\n    volume=(4/3)*math.pi*(radius**3)\n    return volume\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/86": [{"task_id": "Mbpp/86", "solution": "\ndef centered_hexagonal_number (n):\n    return 3*n*(n-1)+1\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/99": [{"task_id": "Mbpp/99", "solution": "\ndef decimal_to_binary (decimal_num):\n    if decimal_num==0:\n        return '0'\n        \n    binary_str=''\n    while decimal_num>0:\n        binary_str=str(decimal_num%2)+binary_str\n        decimal_num=decimal_num//2\n        \n    return binary_str.lstrip('0') or '0'\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/138": [{"task_id": "Mbpp/138", "solution": "\ndef is_Sum_Of_Powers_Of_Two (n):\n    if n==1:\n        return  False \n        \n    while n!=0:\n        if n%2==1:\n            return  False \n            \n        n=n//2\n        \n    return  True \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[123456788]]}], "Mbpp/69": [{"task_id": "Mbpp/69", "solution": "\ndef is_sublist (lst, sublst):\n    sub_len=len(sublst)\n    for i in range(len(lst)-sub_len+1):\n        if lst[i:i+sub_len]==sublst:\n            return  True \n            \n    \n    return  False \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/161": [{"task_id": "Mbpp/161", "solution": "\ndef remove_elements (main_list, remove_list):\n    return [i for i in main_list if i not  in remove_list]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/160": [{"task_id": "Mbpp/160", "solution": "\ndef find_solution (m, b, n):\n    for x in range(n//m+1):\n        y=(n-m*x)//b\n        if y>=0 and m*x+y==n:\n            return x, y\n            \n    \n    return  None \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2, 3, 7]], "plus_fail_tests": [[100, 50, 4000]]}], "Mbpp/234": [{"task_id": "Mbpp/234", "solution": "\ndef volume_cube (side_length):\n    return side_length**3\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/125": [{"task_id": "Mbpp/125", "solution": "\ndef find_length (s:str)->int:\n    max_len=0\n    count_0=0\n    count_1=0\n    for char in s:\n        if char=='0':\n            count_0+=1\n            \n        \n        else :\n            count_1+=1\n            \n        if count_0-count_1>max_len:\n            max_len=count_0-count_1\n            \n        if count_1==0:\n            count_1+=1\n            \n    \n    return max_len\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["11000010001"]], "plus_fail_tests": [["0000000011111111"]]}], "Mbpp/75": [{"task_id": "Mbpp/75", "solution": "\ndef find_tuples (tuples_list, k):\n    result=[]\n    for tup in tuples_list:\n        if all(i%k==0 for i in tup):\n            result.append(tup)\n            \n    \n    return result\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/62": [{"task_id": "Mbpp/62", "solution": "\ndef smallest_num (lst):\n    return min(lst)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/100": [{"task_id": "Mbpp/100", "solution": "\ndef next_smallest_palindrome (n):\n    n+=1\n    while str(n)!=str(n)[::-1]:\n        n+=1\n        \n    return n\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/97": [{"task_id": "Mbpp/97", "solution": "\ndef frequency_lists (lists):\n    flattened_list=[item for sublist in lists for item in sublist]\n    frequency_dict={}\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item]+=1\n            \n        \n        else :\n            frequency_dict[item]=1\n            \n    \n    return frequency_dict\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/116": [{"task_id": "Mbpp/116", "solution": "\ndef tuple_to_int (t):\n    result=0\n    for i in range(len(t)):\n        result=result*10+t[i]\n        \n    return result\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[123, 456, 789]]]}], "Mbpp/9": [{"task_id": "Mbpp/9", "solution": "\ndef find_Rotations (s):\n    n=len(s)\n    for i in range(1, n):\n        rotated=s[i:]+s[:i]\n        if rotated==s:\n            return i\n            \n    \n    return n\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/240": [{"task_id": "Mbpp/240", "solution": "\ndef replace_list (list1, list2):\n    list1[-1:]=list2\n    return list1\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/230": [{"task_id": "Mbpp/230", "solution": "\ndef replace_blank (s, char):\n    return s.replace(' ', char)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/94": [{"task_id": "Mbpp/94", "solution": "\ndef index_minimum (list_of_tuples):\n    min_tuple=min(list_of_tuples, key=lambda x:x[1])\n    return min_tuple[0]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/239": [{"task_id": "Mbpp/239", "solution": "\ndef get_total_number_of_sequences (m, n):\n    dp=[[0]*(m+1) for _ in range(n+1)]\n    for i in range(1, m+1):\n        dp[1][i]=1\n        \n    for i in range(2, n+1):\n        for j in range(1, m+1):\n            dp[i][j]=sum(dp[i-1][j//2:j+1])%(10**9+7)\n            \n    \n    return dp[n][m]\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10, 4]], "plus_fail_tests": [[100, 10]]}], "Mbpp/67": [{"task_id": "Mbpp/67", "solution": "\ndef bell_number (n):\n    bell=[[0 for i in range(n+1)] for j in range(n+1)], bell[0][0]=1\n    for i in range(1, n+1):\n        bell[i][0]=bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j]=bell[i-1][j-1]+bell[i][j-1]\n            \n    \n    return bell[n][0]\n    \nprint(bell_number(2))\nprint(bell_number(10))\nprint(bell_number(56))\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/93": [{"task_id": "Mbpp/93", "solution": "\ndef power (a, b):\n    return a**b\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/131": [{"task_id": "Mbpp/131", "solution": "\ndef reverse_vowels (s:str)->str:\n    vowels=set('aeiouAEIOU')\n    s=list(s)\n    left,right=0, len(s)-1\n    while left<right:\n        while left<right and s[left] not  in vowels:\n            left+=1\n            \n        while left<right and s[right] not  in vowels:\n            right-=1\n            \n        s[left],s[right]=s[right], s[left]\n        left,right=left+1, right-1\n        \n    return ''.join(s)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/124": [{"task_id": "Mbpp/124", "solution": "\nimport cmath\ndef angle_complex (z):\n    return cmath.phase(z)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["0.0", "1j"]], "plus_fail_tests": [["0.0", "0j"]]}], "Mbpp/137": [{"task_id": "Mbpp/137", "solution": "\ndef zero_count (arr):\n    zero_count=0\n    non_zero_count=0\n    for num in arr:\n        if num==0:\n            zero_count+=1\n            \n        \n        else :\n            non_zero_count+=1\n            \n    \n    if non_zero_count==0:\n        return 0.00\n        \n    \n    else :\n        return zero_count/non_zero_count\n        \n\n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}], "Mbpp/120": [{"task_id": "Mbpp/120", "solution": "\nimport math\ndef max_product_tuple (tuples_list):\n    max_product=float('-inf')\n    for pair in tuples_list:\n        product=pair[0]*pair[1]\n        if product>max_product:\n            max_product=product\n            \n    \n    return max_product\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[-10, 20], [15, -2], [-5, 10]]]]}], "Mbpp/128": [{"task_id": "Mbpp/128", "solution": "\ndef long_words (n, string):\n    words=string.split()\n    long_words=[word for word in words if len(word)>n]\n    return long_words\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/222": [{"task_id": "Mbpp/222", "solution": "\ndef check_type (test_tup):\n    first_element_type=type(test_tup[0])\n    for element in test_tup:\n        if type(element)!=first_element_type:\n            return  False \n            \n    \n    return  True \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/252": [{"task_id": "Mbpp/252", "solution": "\ndef convert (num):\n    if num==1:\n        return (1.0, 0.0)\n        \n    \n    else :\n        real=(num/abs(num))*2.0\n        angle=0.0\n        return (real, angle)\n        \n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["(4+0j)"]], "plus_fail_tests": [["(1+2j)"]]}], "Mbpp/250": [{"task_id": "Mbpp/250", "solution": "\ndef count_X (t, element):\n    return t.count(element)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/96": [{"task_id": "Mbpp/96", "solution": "\ndef divisor (n):\n    count=0\n    for i in range(1, n+1):\n        if n%i==0:\n            count+=1\n            \n    \n    return count\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/132": [{"task_id": "Mbpp/132", "solution": "\ndef tup_string (tup):\n    return ''.join(tup)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/104": [{"task_id": "Mbpp/104", "solution": "\ndef sort_sublists (list_of_lists):\n    return [[sorted(sublist) for sublist in sublist] for sublist in list_of_lists]\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[["green", "orange"], ["black", "white"], ["white", "black", "orange"]]]], "plus_fail_tests": [[[["apple", "banana", "cherry"], ["banana", "cherry", "apple"], ["cherry", "apple", "banana"]]]]}], "Mbpp/171": [{"task_id": "Mbpp/171", "solution": "\ndef perimeter_pentagon (side_length, n=5):\n    return n*side_length\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/139": [{"task_id": "Mbpp/139", "solution": "\nimport math\ndef circle_circumference (radius:float)->float:\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n    \n    Args:\n    radius (float): The radius of the circle.\n    \n    Returns:\n    float: The circumference of the circle.\n    \"\"\"\n    return 2, * math.pi, * radius\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[1000000]]}], "Mbpp/113": [{"task_id": "Mbpp/113", "solution": "\ndef check_integer (s):\n    try:\n        int(s)\n        return  True \n        \n    \n    except ValueError:\n        return  False \n        \n\n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/98": [{"task_id": "Mbpp/98", "solution": "\ndef multiply_num (nums):\n    product=1\n    for num in nums:\n        product*=num\n        \n    return product/len(nums)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/126": [{"task_id": "Mbpp/126", "solution": "\ndef sum_divisors (a, b):\n    def divisors (n):\n        result=set()\n        for i in range(1, int(n**0.5)+1):\n            if n%i==0:\n                result.add(i)\n                if i!=n//i:\n                    result.add(n//i)\n                    \n            \n        \n        return result\n        \n    divisors_a=divisors(a)\n    divisors_b=divisors(b)\n    common_divisors=divisors_a&divisors_b\n    return sum(common_divisors)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/79": [{"task_id": "Mbpp/79", "solution": "\ndef word_len (word):\n    return len(word)%2!=0\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/61": [{"task_id": "Mbpp/61", "solution": "\ndef count_Substrings (s:str)->int:\n    count=0\n    for i in range(len(s)):\n        sum_digits=sum(int(digit) for digit in s[i:])\n        if i+1==sum_digits:\n            count+=1\n            \n    \n    return count\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["112112"]], "plus_fail_tests": [["12233445566778899"]]}], "Mbpp/223": [{"task_id": "Mbpp/223", "solution": "\ndef is_majority (nums, n, target):\n    count=0\n    for num in nums:\n        if num==target:\n            count+=1\n            if count>n//2:\n                return  True \n                \n        \n    \n    return  False \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/253": [{"task_id": "Mbpp/253", "solution": "\ndef count_integer (lst):\n    return len([i for i in lst if isinstance(i, int)])\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/127": [{"task_id": "Mbpp/127", "solution": "\ndef multiply_int (a, b):\n    return a*b\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/87": [{"task_id": "Mbpp/87", "solution": "\ndef merge_dictionaries_three (dict1, dict2, dict3):\n    merged_dict=dict1.copy()\n    merged_dict.update(dict2)\n    merged_dict.update(dict3)\n    return merged_dict\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/103": [{"task_id": "Mbpp/103", "solution": "\ndef eulerian_num (a, b):\n    if a<2 or b<0:\n        return 0\n        \n    if a==2:\n        return 1 if b==0 else 0\n        \n    if a==3:\n        return 1 if b==1 else 0\n        \n    if a==4:\n        return 1 if b==0 or b==1 else 0\n        \n    if a==5:\n        return 1 if b==2 else 0\n        \n    return eulerian_num(a-1, b-1)+eulerian_num(a-1, b)+eulerian_num(a-1, b+1)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 1]], "plus_fail_tests": [[1, 0]]}], "Mbpp/129": [{"task_id": "Mbpp/129", "solution": "\ndef magic_square_test (square):\n    n=len(square)\n    if n==0:\n        return  False \n        \n    flat_list=[item for sublist in square for item in sublist]\n    if len(set(flat_list))!=n*n:\n        return  False \n        \n    magic_constant=sum(square[0])\n    for i in range(n):\n        if sum(square[i])!=magic_constant or sum([square[j][i] for j in range(n)])!=magic_constant:\n            return  False \n            \n    \n    if sum([square[i][i] for i in range(n)])!=magic_constant or sum([square[i][n-i-1] for i in range(n)])!=magic_constant:\n        return  False \n        \n    return  True \n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[7, 7], [7, 7]]]]}], "Mbpp/59": [{"task_id": "Mbpp/59", "solution": "\ndef is_octagonal (n):\n    return n*(7*n-5)//2\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[100]]}], "Mbpp/91": [{"task_id": "Mbpp/91", "solution": "\ndef find_substring (string_list, substring):\n    return any(substring in s for s in string_list)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/224": [{"task_id": "Mbpp/224", "solution": "\ndef count_Set_Bits (n):\n    count=0\n    while n:\n        count+=n&1\n        n>>=1\n        \n    return count\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/235": [{"task_id": "Mbpp/235", "solution": "\ndef even_bit_set_number (n):\n    return n|((n&-n).bit_length()-1)*2\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[20]], "plus_fail_tests": [[999999999]]}], "Mbpp/101": [{"task_id": "Mbpp/101", "solution": "\ndef kth_element (arr, k):\n    return arr[k-1]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/168": [{"task_id": "Mbpp/168", "solution": "\ndef frequency (lst, num):\n    return lst.count(num)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/165": [{"task_id": "Mbpp/165", "solution": "\ndef count_char_position (s):\n    count=0\n    for char in s:\n        if char.isalpha():\n            position=ord(char.lower())-ord('a')\n            if position<26 and s[position]==char:\n                count+=1\n                \n        \n    \n    return count\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["xbcefg"]], "plus_fail_tests": [["xyzXYZ"]]}], "Mbpp/92": [{"task_id": "Mbpp/92", "solution": "\ndef is_undulating (number):\n    str_num=str(number)\n    for i in range(len(str_num)-2):\n        if str_num[i]!=str_num[i+1] or str_num[i+1]!=str_num[i+2]:\n            return  False \n            \n    \n    return  True \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1212121]], "plus_fail_tests": [[2121212121212121]]}], "Mbpp/17": [{"task_id": "Mbpp/17", "solution": "\ndef square_perimeter (side_length):\n    return 4*side_length\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/106": [{"task_id": "Mbpp/106", "solution": "\ndef add_lists (list1, tuple1):\n    return tuple1+tuple(list1)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/70": [{"task_id": "Mbpp/70", "solution": "\ndef get_equal (tuples):\n    length=len(tuples[0])\n    for t in tuples:\n        if len(t)!=length:\n            return  False \n            \n    \n    return  True \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/245": [{"task_id": "Mbpp/245", "solution": "\ndef max_sum (arr):\n    n=len(arr)\n    inc=[arr[0]]*n\n    dec=[arr[-1]]*n\n    for i in range(1, n):\n        inc[i]=max(inc[i-1]+arr[i], arr[i])\n        \n    for i in range(n-2, -1, -1):\n        dec[i]=max(dec[i+1]+arr[i], arr[i])\n        \n    max_sum=0\n    for i in range(n):\n        max_sum=max(max_sum, inc[i]+dec[i]-arr[i])\n        \n    return max_sum\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 15, 51, 45, 33, 100, 12, 18, 9]]], "plus_fail_tests": [[[10, 9, 8, 7, 6, 5, 4, 4, 3, 2, 1]]]}], "Mbpp/226": [{"task_id": "Mbpp/226", "solution": "\ndef odd_values_string (s):\n    return ''.join([s[i] for i in range(len(s)) if i%2==0])\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/63": [{"task_id": "Mbpp/63", "solution": "\ndef max_difference (lst):\n    lst.sort(key=lambda x:x[1])\n    max_diff=0\n    for i in range(len(lst)-1):\n        diff=lst[i+1][0]-lst[i][0]\n        if diff>max_diff:\n            max_diff=diff\n            \n    \n    return max_diff\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 5], [1, 7], [10, 3], [1, 2]]]], "plus_fail_tests": [[[[1000000, 999999], [10000000, 9999999], [100000000, 99999999], [1000000000, 999999999]]]]}], "Mbpp/166": [{"task_id": "Mbpp/166", "solution": "\ndef find_even_pair (arr):\n    even_count=0\n    for num in arr:\n        if num%2==0:\n            even_count+=1\n            \n    \n    return even_count*(even_count-1)//2+sum([num%2==0 for num in arr])*(even_count-1)//2\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[5, 4, 7, 2, 1]]], "plus_fail_tests": [[[-3, -2, -1, 0, 1, 2, 3]]]}], "Mbpp/172": [{"task_id": "Mbpp/172", "solution": "\ndef count_occurance (s:str)->int:\n    count=0\n    for i in range(len(s)-2):\n        if s[i:i+3]==\"std\":\n            count+=1\n            \n    \n    return count\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/233": [{"task_id": "Mbpp/233", "solution": "\nimport math\ndef lateralsuface_cylinder (radius, height):\n    lateral_surface_area=2*math.pi*radius*height\n    return lateral_surface_area\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/88": [{"task_id": "Mbpp/88", "solution": "\ndef freq_count (lst):\n    freq={}\n    for item in lst:\n        if item in freq:\n            freq[item]+=1\n            \n        \n        else :\n            freq[item]=1\n            \n    \n    return freq\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/118": [{"task_id": "Mbpp/118", "solution": "\ndef string_to_list (s):\n    return s.split()\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/133": [{"task_id": "Mbpp/133", "solution": "\ndef sum_negativenum (numbers):\n    sum=0\n    for num in numbers:\n        if num<0:\n            sum+=num\n            \n    \n    return sum\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/140": [{"task_id": "Mbpp/140", "solution": "\ndef extract_singly (lists):\n    result=[]\n    for sublist in lists:\n        for item in sublist:\n            result.append(item)\n            \n    \n    return set(result)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/170": [{"task_id": "Mbpp/170", "solution": "\ndef sum_range_list (lst, start, end):\n    return sum(lst[start:end+1])\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/242": [{"task_id": "Mbpp/242", "solution": "\ndef count_charac (s):\n    return len(s)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/105": [{"task_id": "Mbpp/105", "solution": "\ndef count (lst):\n    return sum(1 for x in lst if x)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/227": [{"task_id": "Mbpp/227", "solution": "\ndef min_of_three (a, b, c):\n    return min(a, b, c)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/167": [{"task_id": "Mbpp/167", "solution": "\ndef next_power_of_2 (n):\n    if n==0:\n        return 1\n        \n    \n    elif n&(n-1)==0:\n        return n\n        \n    \n    else :\n        return 1<<(n-1).bit_length()\n        \n\n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/237": [{"task_id": "Mbpp/237", "solution": "\ndef check_occurences (tuples_list):\n    occurrences={}\n    for tup in tuples_list:\n        if tup in occurrences:\n            occurrences[tup]+=1\n            \n        \n        else :\n            occurrences[tup]=1\n            \n    \n    return occurrences\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 1], [1, 3], [2, 5], [5, 2], [6, 3]]]], "plus_fail_tests": [[[[2, 2], [1, 3], [2, 2], [3, 1], [1, 3]]]]}], "Mbpp/244": [{"task_id": "Mbpp/244", "solution": "\ndef next_Perfect_Square (n):\n    i=int(n**0.5)\n    if i**2>n:\n        return (i+1)**2\n        \n    \n    else :\n        return (i+1)**2\n        \n\n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/141": [{"task_id": "Mbpp/141", "solution": "\ndef pancake_sort (arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \"\"\"\n    for i in range(len(arr), 1, -1):\n        max_index=arr.index(max(arr[:i]))\n        if max_index==i-1:\n            continue \n            \n        arr[:max_index+1]=arr[:max_index+1][::-1]\n        arr[:i]=arr[:i][::-1]\n        \n    return arr\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/95": [{"task_id": "Mbpp/95", "solution": "\ndef Find_Min_Length (list_of_lists):\n    return min(len(sublist) for sublist in list_of_lists)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/90": [{"task_id": "Mbpp/90", "solution": "\ndef len_log (lst):\n    return max(len(word) for word in lst)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/251": [{"task_id": "Mbpp/251", "solution": "\ndef insert_element (lst, element):\n    result=[]\n    for item in lst:\n        result.insert(0, item)\n        result.insert(0, element)\n        \n    return result\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Red", "Green", "Black"], "c"]], "plus_fail_tests": [[[-94.19039842971628, -3.4031380684866406, -22.045351968568852, -94.19039842971628], "a"]]}], "Mbpp/238": [{"task_id": "Mbpp/238", "solution": "\ndef number_of_substrings (s:str)->int:\n    n=len(s)\n    return n*(n+1)//2\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/18": [{"task_id": "Mbpp/18", "solution": "\ndef remove_dirty_chars (s:str, t:str)->str:\n    \"\"\"\n    Removes characters from the first string which are present in the second string.\n    \n    :param s: The original string.\n    :param t: The string containing characters to be removed from s.\n    :return: The resulting string after removing characters found in t from s.\n    \"\"\"\n    chars_to_remove=set(t)\n    result=[char for char in s if char not  in chars_to_remove]\n    return ''.join(result)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/72": [{"task_id": "Mbpp/72", "solution": "\ndef dif_Square (n):\n    for i in range(int(n**0.5)+1):\n        j=n-(i**2)\n        if int(j**0.5)**2==j:\n            return  True \n            \n    \n    return  False \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[991]]}], "Mbpp/89": [{"task_id": "Mbpp/89", "solution": "\ndef closest_num (n):\n    i=int(n)\n    if i>0:\n        i-=1\n        \n    return i\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/247": [{"task_id": "Mbpp/247", "solution": "\ndef lps (s):\n    n=len(s)\n    dp=[[0]*n for _ in range(n)]\n    for i in range(n-1, -1, -1):\n        dp[i][i]=1\n        for j in range(i+1, n):\n            if s[i]==s[j]:\n                dp[i][j]=dp[i+1][j-1]+2\n                \n            \n            else :\n                dp[i][j]=max(dp[i+1][j], dp[i][j-1])\n                \n        \n    \n    return dp[0][n-1]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/162": [{"task_id": "Mbpp/162", "solution": "\ndef sum_series (n):\n    total=0\n    for i in range(0, n//2+1):\n        total+=(n-2*i)\n        \n    return total\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/123": [{"task_id": "Mbpp/123", "solution": "\ndef amicable_numbers_sum (n):\n    amicable_numbers=set()\n    for i in range(2, n):\n        sum_divisors=1\n        for j in range(i+1, n):\n            if i%j==0:\n                sum_divisors+=j\n                \n        \n        if sum_divisors!=i and sum_divisors<n and sum_divisors not  in amicable_numbers:\n            amicable_numbers.add(sum_divisors)\n            if sum_divisors!=i:\n                amicable_numbers.add(i)\n                \n        \n    \n    return sum(set(amicable_numbers))\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[999]], "plus_fail_tests": [[10000]]}], "Mbpp/259": [{"task_id": "Mbpp/259", "solution": "\ndef maximize_elements (tuple1, tuple2):\n    maximized=[]\n    for t1,t2 in zip(tuple1, tuple2):\n        max_t1=max(t1[0], t1[1]) if isinstance(t1, tuple) else t1\n        max_t2=max(t2[0], t2[1]) if isinstance(t2, tuple) else t2\n        maximized.append((max_t1, max_t2))\n        \n    return tuple(maximized)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]]], "plus_fail_tests": [[[[1, 2], [3, 4], [5, 6], [7, 8]], [[8, 7], [6, 5], [4, 3], [2, 1]]]]}], "Mbpp/268": [{"task_id": "Mbpp/268", "solution": "\ndef find_star_num (n):\n    \"\"\"\n    Calculate the n'th star number.\n    \n    :param n: An integer representing the position of the star number to find.\n    :return: The n'th star number.\n    \"\"\"\n    if n==1:\n        return 1\n        \n    \n    else :\n        return find_star_num(n-1)+6*(n-1)*(n-2)//2+4*(n-1)*(n-2)*(n-3)//6+find_star_num(n-4)*2048//256\n        \n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/256": [{"task_id": "Mbpp/256", "solution": "\ndef count_Primes_nums (n):\n    def is_prime (num):\n        if num<2:\n            return  False \n            \n        for i in range(2, int(num**0.5)+1):\n            if num%i==0:\n                return  False \n                \n        \n        return  True \n        \n    count=0\n    for i in range(2, n):\n        if is_prime(i):\n            count+=1\n            \n    \n    return count\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/266": [{"task_id": "Mbpp/266", "solution": "\ndef lateralsurface_cube (side_length):\n    return 6*side_length**2\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[100]]}], "Mbpp/276": [{"task_id": "Mbpp/276", "solution": "\nimport math\ndef volume_cylinder (radius, height):\n    volume=math.pi*radius**2*height\n    return volume\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/274": [{"task_id": "Mbpp/274", "solution": "\nfrom math import factorial\ndef even_binomial_Coeff_Sum (n):\n    sum=0\n    for i in range(0, n+1, 2):\n        binomial_coeff=factorial(n)//(factorial(i)*factorial(n-i))\n        if binomial_coeff%2==0:\n            sum+=binomial_coeff\n            \n    \n    return sum\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[4]], "plus_fail_tests": [[10]]}], "Mbpp/280": [{"task_id": "Mbpp/280", "solution": "\ndef sequential_search (arr, target):\n    for i in range(len(arr)):\n        if arr[i]==target:\n            return ( True , i)\n            \n    \n    return ( False , -1)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/286": [{"task_id": "Mbpp/286", "solution": "\ndef max_sub_array_sum_repeated (arr, k, arr_size):\n    max_sum=float('-inf')\n    current_sum=0\n    for i in range(len(arr)):\n        current_sum+=arr[i]\n        if current_sum>max_sum:\n            max_sum=current_sum\n            \n        if current_sum<0:\n            current_sum=0\n            \n    \n    if k==1:\n        return max_sum\n        \n    extended_arr=arr*k\n    new_arr=extended_arr+extended_arr[:arr_size]\n    max_sum=float('-inf')\n    current_sum=0\n    for i in range(len(new_arr)):\n        current_sum+=new_arr[i]\n        if current_sum>max_sum:\n            max_sum=current_sum\n            \n        if current_sum<0:\n            current_sum=0\n            \n    \n    return max_sum\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, 10, 20], 3, 2]], "plus_fail_tests": [[[5, -2, 10, 4, -7, 3], 6, 5]]}], "Mbpp/269": [{"task_id": "Mbpp/269", "solution": "\ndef ascii_value (char):\n    return ord(char)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/296": [{"task_id": "Mbpp/296", "solution": "\ndef get_Inv_Count (arr):\n    inv_count=0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i]>arr[j]:\n                inv_count+=1\n                \n        \n    \n    return inv_count\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/281": [{"task_id": "Mbpp/281", "solution": "\ndef all_unique (lst):\n    return len(lst)==len(set(lst))\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/257": [{"task_id": "Mbpp/257", "solution": "\ndef swap_numbers (num1, num2):\n    return (num2, num1)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/267": [{"task_id": "Mbpp/267", "solution": "\ndef square_Sum (n):\n    sum_of_squares=0\n    for i in range(1, 2*n, 2):\n        sum_of_squares+=i**2\n        \n    return sum_of_squares\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000.0]]}], "Mbpp/283": [{"task_id": "Mbpp/283", "solution": "\ndef validate (num):\n    freq={}\n    for digit in str(num):\n        if digit in freq:\n            freq[digit]+=1\n            \n        \n        else :\n            freq[digit]=1\n            \n    \n    for digit,frequency in freq.items():\n        if frequency>int(digit):\n            return  False \n            \n    \n    return  True \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/270": [{"task_id": "Mbpp/270", "solution": "\ndef sum_even_and_even_index (lst):\n    sum=0\n    for i in range(0, len(lst), 2):\n        if lst[i]%2==0:\n            sum+=lst[i]\n            \n    \n    return sum\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/282": [{"task_id": "Mbpp/282", "solution": "\ndef sub_list (list1, list2):\n    return [x-y for x,y in zip(list1, list2)]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/262": [{"task_id": "Mbpp/262", "solution": "\ndef split_two_parts (lst, L):\n    length=len(lst)\n    first_part=lst[:L]\n    second_part=lst[L:]\n    return (first_part, second_part)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/264": [{"task_id": "Mbpp/264", "solution": "\ndef dog_age (dog_years):\n    if dog_years<1:\n        return \"Invalid input\"\n        \n    if dog_years==1:\n        return 15\n        \n    \n    elif dog_years==2:\n        return 20\n        \n    \n    elif dog_years==3:\n        return 25\n        \n    \n    elif dog_years==4:\n        return 30\n        \n    \n    elif dog_years==5:\n        return 35\n        \n    \n    elif dog_years==6:\n        return 40\n        \n    \n    elif dog_years==7:\n        return 45\n        \n    \n    elif dog_years==8:\n        return 50\n        \n    \n    elif dog_years==9:\n        return 55\n        \n    \n    elif dog_years==10:\n        return 60\n        \n    \n    elif dog_years==11:\n        return 65\n        \n    \n    elif dog_years==12:\n        return 70\n        \n    \n    else :\n        return \"Invalid input\"\n        \n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[12]], "plus_fail_tests": [[100]]}], "Mbpp/290": [{"task_id": "Mbpp/290", "solution": "\ndef max_length (lists):\n    max_length=max(len(lst) for lst in lists)\n    return max_length, [lst for lst in lists if len(lst)==max_length]\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]]], "plus_fail_tests": [[[[1, 3, 5, 7, 9, 11], [2, 4, 6], [10, 12, 14, 16, 18, 20], [13, 15, 17, 19, 21]]]]}], "Mbpp/297": [{"task_id": "Mbpp/297", "solution": "\ndef flatten_list (nested_list):\n    flat_list=[]\n    for i in nested_list:\n        if isinstance(i, list):\n            flat_list.extend(flatten_list(i))\n            \n        \n        else :\n            flat_list.append(i)\n            \n    \n    return flat_list\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/392": [{"task_id": "Mbpp/392", "solution": "\ndef get_max_sum (n):\n    memo={}\n    def helper (n):\n        if n==0:\n            return 0\n            \n        if n in memo:\n            return memo[n]\n            \n        result=max(helper(n//2)+helper(n//3)+helper(n//4)+helper(n//5), n)\n        memo[n]=result\n        return result\n        \n    return helper(n)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/301": [{"task_id": "Mbpp/301", "solution": "\ndef dict_depth (d):\n    if isinstance(d, dict):\n        return 1+max(dict_depth(v) for v in d.values())\n        \n    return 0\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"a": 1, "b": {"c": {"d": {}}}}]], "plus_fail_tests": [[{}]]}], "Mbpp/285": [{"task_id": "Mbpp/285", "solution": "\nimport re\ndef text_match_two_three (text):\n    pattern=r\"ab{2,3}\"\n    match=re.search(pattern, text)\n    return match is  not  None \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/308": [{"task_id": "Mbpp/308", "solution": "\ndef large_product (nums1, nums2, N):\n    result=[]\n    nums1.sort(reverse= True )\n    nums2.sort(reverse= True )\n    for i in range(N):\n        if nums1[0]==0:\n            result.append(0)\n            \n        \n        elif nums2[0]==0:\n            result.append(0)\n            \n        \n        else :\n            product1=nums1[0]*nums2[0]\n            product2=nums1[0]*nums2[-1]\n            product3=nums1[-1]*nums2[0]\n            product4=nums1[-1]*nums2[-1]\n            result.append(max(product1, product2, product3, product4))\n            \n        nums1.pop(0)\n        nums2.pop(0)\n        \n    return result\n    \n\n", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [[[1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3]], "plus_fail_tests": []}], "Mbpp/265": [{"task_id": "Mbpp/265", "solution": "\ndef list_split (lst, n):\n    result=[]\n    for i in range(0, len(lst), n):\n        result.append(lst[i:i+n])\n        \n    return result\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n"], 3]], "plus_fail_tests": [[[], 1]]}], "Mbpp/415": [{"task_id": "Mbpp/415", "solution": "\ndef max_Product (arr):\n    max1,max2=float('-inf'), float('-inf')\n    min1,min2=float('inf'), float('inf')\n    for num in arr:\n        if num>max1:\n            max2,max1=max1, num\n            \n        \n        elif num>max2:\n            max2=num\n            \n        if num<min1:\n            min2,min1=min1, num\n            \n        \n        elif num<min2:\n            min2=num\n            \n    \n    return (max1*max2, min1*min2) if max1*max2>min1*min2 else (min1*min2, max1*max2)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 7, 0, 8, 4]]], "plus_fail_tests": [[[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]}], "Mbpp/260": [{"task_id": "Mbpp/260", "solution": "\ndef newman_prime (n):\n    def is_prime (x):\n        if x<2:\n            return  False \n            \n        for i in range(2, int(x**0.5)+1):\n            if x%i==0:\n                return  False \n                \n        \n        return  True \n        \n    newman_num=2\n    while  True :\n        if is_prime(newman_num):\n            return newman_num\n            \n        newman_num+=1\n        \n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[100]]}], "Mbpp/279": [{"task_id": "Mbpp/279", "solution": "\ndef is_num_decagonal (n):\n    return n*(7*n-5)//2\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/310": [{"task_id": "Mbpp/310", "solution": "\ndef string_to_tuple (s):\n    return tuple(s)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python 3.0"]], "plus_fail_tests": [["hello   world"]]}], "Mbpp/293": [{"task_id": "Mbpp/293", "solution": "\nimport math\ndef otherside_rightangle (a, b):\n    c=math.sqrt(a**2+b**2)\n    return c\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/394": [{"task_id": "Mbpp/394", "solution": "\ndef check_distinct (test_tup):\n    return len(test_tup)==len(set(test_tup))\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/391": [{"task_id": "Mbpp/391", "solution": "\ndef convert_list_dictionary (keys, values):\n    if len(keys)!=len(values) or len(keys)==0 or len(values)==0:\n        return []\n        \n    result={}\n    for i in range(len(keys)):\n        result[keys[i]]={keys[i]:values[i]}\n        \n    return list(result.values())\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["S001", "S002", "S003", "S004"], ["Adina Park", "Leyton Marsh", "Duncan Boyle", "Saim Richards"], [85, 98, 89, 92]]], "plus_fail_tests": [[["abc", "def", "ghi", "jkl"], ["python", "program", "language", "programs"], [{"1": "a", "2": "b"}, {"3": "c"}, 4, ["x", "y", "z"]]]]}], "Mbpp/436": [{"task_id": "Mbpp/436", "solution": "\ndef neg_nos (lst):\n    return [i for i in lst if i<0]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/284": [{"task_id": "Mbpp/284", "solution": "\ndef check_element (lst, element):\n    return all(x==element for x in lst)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/311": [{"task_id": "Mbpp/311", "solution": "\ndef set_left_most_unset_bit (n):\n    return n|(1<<(n.bit_length()-1))\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[125]]}], "Mbpp/261": [{"task_id": "Mbpp/261", "solution": "\ndef division_elements (test_tup1, test_tup2):\n    result=tuple(ele1/ele2 for ele1,ele2 in zip(test_tup1, test_tup2))\n    return result\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/419": [{"task_id": "Mbpp/419", "solution": "\ndef round_and_sum (input_list):\n    total=0\n    for number in input_list:\n        total+=round(number)\n        \n    return total*len(input_list)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/405": [{"task_id": "Mbpp/405", "solution": "\ndef check_tuplex (tuplex, element):\n    return element in tuplex\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/406": [{"task_id": "Mbpp/406", "solution": "\ndef find_Parity (n):\n    return n%2!=0\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/429": [{"task_id": "Mbpp/429", "solution": "\ndef and_tuples (tup1, tup2):\n    res=[]\n    for i in range(len(tup1)):\n        if i<len(tup2):\n            res.append(tup1[i]-tup2[i])\n            \n        \n        else :\n            res.append(0)\n            \n    \n    return tuple(res)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[10, 4, 6, 9], [5, 2, 3, 3]]], "plus_fail_tests": [[[123, 456, 789, 10], [987, 654, 321, 10]]]}], "Mbpp/428": [{"task_id": "Mbpp/428", "solution": "\ndef shell_sort (arr):\n    gap=len(arr)//2\n    while gap>0:\n        for i in range(gap, len(arr)):\n            temp=arr[i]\n            j=i\n            while j>=gap and arr[j-gap]>temp:\n                arr[j]=arr[j-gap]\n                j-=gap\n                \n            arr[j]=temp\n            \n        gap//=2\n        \n    return arr\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/439": [{"task_id": "Mbpp/439", "solution": "\ndef multiple_to_single (numbers):\n    result=0\n    for i in range(len(numbers)):\n        result=result*10+numbers[i]\n        \n    return result\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[11, 33, 50]]], "plus_fail_tests": [[[1000000, 999999, 100000, 99999]]]}], "Mbpp/309": [{"task_id": "Mbpp/309", "solution": "\ndef maximum (a, b):\n    return a if a>b else b\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/388": [{"task_id": "Mbpp/388", "solution": "\ndef highest_Power_of_2 (n):\n    power=0\n    while (1<<power)<=n:\n        power+=1\n        \n    return 1<<(power-1)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/397": [{"task_id": "Mbpp/397", "solution": "\ndef median_numbers (a, b, c):\n    numbers=[a, b, c]\n    numbers.sort()\n    return numbers[1]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/441": [{"task_id": "Mbpp/441", "solution": "\ndef surfacearea_cube (n):\n    return 6*n**2\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/305": [{"task_id": "Mbpp/305", "solution": "\ndef start_withp (words):\n    p_words=[word for word in words if word.startswith('p')]\n    p_words.sort()\n    return p_words[0], p_words[1] if len(p_words)>1 else  None \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python PHP", "Java JavaScript", "c c++"]]], "plus_fail_tests": [[["Python Programming", "Java Programming", "Perl Programming", "Ruby Programming", "PHP Programming", "C Programming"]]]}], "Mbpp/432": [{"task_id": "Mbpp/432", "solution": "\ndef median_trapezium (a, b, c):\n    return (b+c)/2\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[15, 25, 35]], "plus_fail_tests": [[2.3, 4.7, 3.9]]}], "Mbpp/451": [{"task_id": "Mbpp/451", "solution": "\ndef remove_whitespaces (s):\n    return s.replace(' ', '')\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/412": [{"task_id": "Mbpp/412", "solution": "\ndef remove_odd (lst):\n    return [num for num in lst if num%2==0]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/424": [{"task_id": "Mbpp/424", "solution": "\ndef extract_rear (test_tup):\n    return [c[-1] for c in test_tup]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/278": [{"task_id": "Mbpp/278", "solution": "\ndef count_first_elements (t):\n    count=0\n    for i in t:\n        if isinstance(i, tuple):\n            break \n            \n        count+=1\n        \n    return count\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6]]]}], "Mbpp/420": [{"task_id": "Mbpp/420", "solution": "\ndef cube_Sum (n):\n    total=0\n    for i in range(1, n+1):\n        total+=(2*i)**3\n        \n    return total\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/413": [{"task_id": "Mbpp/413", "solution": "\ndef extract_nth_element (list_of_tuples, n):\n    return [t[n] for t in list_of_tuples]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/447": [{"task_id": "Mbpp/447", "solution": "\ndef cube_nums (nums):\n    return [num**3 for num in nums]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/410": [{"task_id": "Mbpp/410", "solution": "\ndef min_val (lst):\n    return min(lst)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python", 3, 2, 4, 5, "version"]]], "plus_fail_tests": [[["Python", 10, 5, 2.5, 2.5, "version"]]]}], "Mbpp/390": [{"task_id": "Mbpp/390", "solution": "\ndef add_string (input_list, format_string):\n    return [format_string.format(item) for item in input_list]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/460": [{"task_id": "Mbpp/460", "solution": "\ndef Extract (list_of_lists):\n    return [item[0] for item in list_of_lists]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/395": [{"task_id": "Mbpp/395", "solution": "\ndef first_non_repeating_character (s):\n    char_count={}\n    for char in s:\n        if char in char_count:\n            char_count[char]+=1\n            \n        \n        else :\n            char_count[char]=1\n            \n    \n    for char in s:\n        if char_count[char]==1:\n            return char\n            \n    \n    return  None \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/272": [{"task_id": "Mbpp/272", "solution": "\ndef rear_extract (tuple_list):\n    return [tup[-1] for tup in tuple_list]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/273": [{"task_id": "Mbpp/273", "solution": "\ndef substract_elements (tuple1, tuple2):\n    result=tuple(x-y for x,y in zip(tuple1, tuple2))\n    return result\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/445": [{"task_id": "Mbpp/445", "solution": "\ndef index_multiplication (test_tup1, test_tup2):\n    res=tuple(tuple(a*b for a,b in zip(tup1, tup2)) for tup1,tup2 in zip(test_tup1, test_tup2))\n    return res\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/459": [{"task_id": "Mbpp/459", "solution": "\ndef remove_uppercase (s):\n    result=[]\n    for char in s:\n        if char.islower():\n            result.append(char)\n            \n    \n    return ''.join(result)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/306": [{"task_id": "Mbpp/306", "solution": "\ndef max_sum_increasing_subseq (nums, k, t):\n    max_sum=[0]*len(nums)\n    max_sum[0]=nums[0]\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i]>nums[j]:\n                max_sum[i]=max(max_sum[i], max_sum[j]+nums[i])\n                \n        \n        max_sum[i]=max(max_sum[i], nums[i])\n        \n    max_sum2=[0]*len(nums)\n    max_sum2[-1]=nums[-1]\n    for i in range(len(nums)-2, -1, -1):\n        for j in range(i+1, len(nums)):\n            if nums[i]>nums[j]:\n                max_sum2[i]=max(max_sum2[i], max_sum2[j]+nums[i])\n                \n        \n        max_sum2[i]=max(max_sum2[i], nums[i])\n        \n    max_sum3=max_sum2[k]\n    return max_sum3 if max_sum3>max_sum2[0] else max_sum2[0]\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 101, 2, 3, 100, 4, 5], 7, 4, 6]], "plus_fail_tests": [[[5, 2, 4, 1, 3, 6], 6, 1, 3]]}], "Mbpp/299": [{"task_id": "Mbpp/299", "solution": "\ndef max_aggregate (lst):\n    max_name=''\n    max_value=0\n    for name,value in lst:\n        if value>max_value:\n            max_name=name\n            max_value=value\n            \n    \n    return (max_name, max_value)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[["Juan Whelan", 90], ["Sabah Colley", 88], ["Peter Nichols", 7], ["Juan Whelan", 122], ["Sabah Colley", 84]]]], "plus_fail_tests": [[[["Alice", 80], ["Bob", 90], ["Charlie", 70], ["Alice", 60], ["Bob", 50], ["Charlie", 40]]]]}], "Mbpp/277": [{"task_id": "Mbpp/277", "solution": "\ndef dict_filter (d, n):\n    return {k:v for k,v in d.items() if v>=n}\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/409": [{"task_id": "Mbpp/409", "solution": "\ndef min_product_tuple (tuples_list):\n    min_product=float('inf')\n    for i in range(len(tuples_list)):\n        for j in range(i+1, len(tuples_list)):\n            product=tuples_list[i][0]*tuples_list[j][0]\n            if product<min_product:\n                min_product=product\n                \n            product=tuples_list[i][1]*tuples_list[j][1]\n            if product<min_product:\n                min_product=product\n                \n        \n    \n    return min_product\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[2, 7], [2, 6], [1, 8], [4, 9]]]], "plus_fail_tests": [[[[1000000, 2000000], [5000000, 3000000], [4000000, 6000000]]]]}], "Mbpp/435": [{"task_id": "Mbpp/435", "solution": "\ndef last_Digit (n):\n    return n%10\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-987]]}], "Mbpp/312": [{"task_id": "Mbpp/312", "solution": "\nimport math\ndef volume_cone (radius, height):\n    \"\"\"Calculate the volume of a cone given its radius and height.\"\"\"\n    volume=(1/3)*math.pi*radius**2*height\n    return volume\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/294": [{"task_id": "Mbpp/294", "solution": "\ndef max_val (lst):\n    return max((i for i in lst if isinstance(i, int)), default= None )\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/425": [{"task_id": "Mbpp/425", "solution": "\ndef count_element_in_list (lst, element):\n    count=0\n    for sublist in lst:\n        if element in sublist:\n            count+=1\n            \n    \n    return count\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "\ndef digit_distance_nums (num1, num2):\n    distance=abs(num1-num2)\n    distance_str=str(distance)\n    total_distance=0\n    for digit in distance_str:\n        total_distance+=int(digit)\n        \n    return total_distance\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[123456789, 987654321]]}], "Mbpp/426": [{"task_id": "Mbpp/426", "solution": "\ndef filter_oddnumbers (numbers):\n    return [num for num in numbers if num%2!=0]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/422": [{"task_id": "Mbpp/422", "solution": "\ndef find_Average_Of_Cube (n):\n    total=0\n    for i in range(1, n+1):\n        total+=i**3\n        \n    return total/n\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/292": [{"task_id": "Mbpp/292", "solution": "\ndef find (dividend, divisor):\n    return dividend//divisor\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/458": [{"task_id": "Mbpp/458", "solution": "\ndef rectangle_area (length, width):\n    return length*width\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/450": [{"task_id": "Mbpp/450", "solution": "\ndef extract_string (string_list, size):\n    return string_list[-size:] if size<=len(string_list) else []\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python", "list", "exercises", "practice", "solution"], 8]], "plus_fail_tests": [[["abcdef", "xyz", "pqr", "lmnop", "abcde"], 5]]}], "Mbpp/457": [{"task_id": "Mbpp/457", "solution": "\ndef Find_Min (lst):\n    min_length=float('inf')\n    min_list=[]\n    for sublist in lst:\n        if len(sublist)<min_length:\n            min_length=len(sublist)\n            min_list=sublist\n            \n    \n    return min_list\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/427": [{"task_id": "Mbpp/427", "solution": "\ndef change_date_format (date):\n    return date[-2:]+'-'+date[0:2]+'-'+date[3:5]\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["2026-01-02"]], "plus_fail_tests": [["2021-1-026"]]}], "Mbpp/398": [{"task_id": "Mbpp/398", "solution": "\ndef sum_of_digits (lst):\n    total=0\n    for i in lst:\n        if isinstance(i, list):\n            total+=sum_of_digits(i)\n            \n        \n        else :\n            total+=sum(int(digit) for digit in str(i))\n            \n    \n    return total\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 20, 4, 5, "b", 70, "a"]]]], "plus_fail_tests": [[[-10, 15, 0, -5, 2]]]}], "Mbpp/455": [{"task_id": "Mbpp/455", "solution": "\ndef check_monthnumb_number (month_num):\n    month_days=[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if month_num<1 or month_num>12:\n        return  False \n        \n    if month_num==2:\n        if month_days[1]==29:\n            return  False \n            \n    \n    if month_num in [4, 6, 9, 11]:\n        return  True \n        \n    return  False \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[1]]}], "Mbpp/446": [{"task_id": "Mbpp/446", "solution": "\ndef count_Occurrence (iterable_list, elements_list):\n    count=0\n    for i in iterable_list:\n        if i in elements_list:\n            count+=1\n            \n    \n    return count\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 1, 1, 2, 2, 2, 3, 3, 3], [1, 1, 2, 2, 3, 3]]]}], "Mbpp/477": [{"task_id": "Mbpp/477", "solution": "\ndef is_lower (s):\n    return s.lower()\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/454": [{"task_id": "Mbpp/454", "solution": "\nimport re\ndef text_match_wordz (text):\n    \"\"\"\n    Check if the given text contains a word that matches the pattern 'z'.\n    \n    Args:\n    text (str): The text to search within.\n    \n    Returns:\n    bool: True if a match is found, False otherwise.\n    \"\"\"\n    pattern=r'\\bz\\b'\n    match=re.search(pattern, text)\n    return match is  not  None \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["pythonz."]], "plus_fail_tests": [["1234z5678"]]}], "Mbpp/389": [{"task_id": "Mbpp/389", "solution": "\ndef find_lucas (n):\n    if n==1:\n        return 2\n        \n    \n    elif n==2:\n        return 1\n        \n    \n    else :\n        a,b=2, 1\n        for _ in range(3, n+1):\n            a,b=b, a+b\n            \n        return b\n        \n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9]], "plus_fail_tests": [[15]]}], "Mbpp/300": [{"task_id": "Mbpp/300", "solution": "\nfrom math import comb\ndef count_binary_seq (n:int)->float:\n    \"\"\"\n    Count the number of binary sequences of length 2n such that the sum of the first n bits\n    is equal to the sum of the last n bits.\n    \n    Args:\n    n (int): The length of the binary sequence.\n    \n    Returns:\n    float: The count of such binary sequences.\n    \"\"\"\n    count=0\n    for k in range(n+1):\n        count+=comb(n, k)**2\n        \n    return count*2.0/n\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": [[4]]}], "Mbpp/437": [{"task_id": "Mbpp/437", "solution": "\ndef remove_odd (s):\n    result=\"\"\n    for char in s:\n        if ord(char)%2==0:\n            result+=char\n            \n    \n    return result\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python"]], "plus_fail_tests": [["Hello, world!"]]}], "Mbpp/440": [{"task_id": "Mbpp/440", "solution": "\nimport re\ndef find_adverb_position (sentence):\n    adverb_pattern=r'\\b(\\b(?:quickly|easily|quick|fast|slowly|slow|young|old|hot|cold|sick|healthy|rich|poor|happy|sad|angry|surprised|confused|stuck|frustrated|embarrassed|anxious|worried|fearful|anxious|frustrated|embarrassed|anxious|frightened|fearful|angry|surprised|confused|stuck|lazy|active|tired|bored|content|unhappy|joyful|merry|cheerful|worried|frightened|fearful|angry|surprised|confused|stuck|lazy|active|tired|bored|content|unhappy|joyful|merry|cheerful)\\b'\n    match=re.search(adverb_pattern, sentence)\n    if match:\n        adverb=match.group(0)\n        start_pos=match.start()\n        end_pos=match.end()\n        return (start_pos, end_pos, adverb)\n        \n    \n    else :\n        return  None \n        \n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["clearly!! we can see the sky"]], "plus_fail_tests": [["heavily and quickly we ran down the steep hill"]]}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "\ndef sum_digits (n):\n    if n==0:\n        return 0\n        \n    \n    else :\n        return n%10+sum_digits(n//10)\n        \n\n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]]}], "Mbpp/433": [{"task_id": "Mbpp/433", "solution": "\ndef check_greater (arr, num):\n    for i in arr:\n        if i>num:\n            return  True \n            \n    \n    return  False \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5], 4]], "plus_fail_tests": [[[], 10]]}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "\ndef extract_values (s):\n    result=[]\n    current=[]\n    in_quotes= False \n    for char in s:\n        if char=='\"':\n            in_quotes= not in_quotes\n            if  not in_quotes:\n                result.append(''.join(current))\n                current=[]\n                \n        \n        \n        elif in_quotes:\n            current.append(char)\n            \n    \n    return result\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/421": [{"task_id": "Mbpp/421", "solution": "\ndef concatenate_tuple (t:tuple, delimiter:str)->str:\n    return delimiter.join(map(str, t))\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["ID", "is", 4, "UTS"]]], "plus_fail_tests": [[["The", "quick", "brown", "fox"]]]}], "Mbpp/456": [{"task_id": "Mbpp/456", "solution": "\ndef reverse_string_list (string_list):\n    reversed_list=[]\n    for string in string_list:\n        reversed_list.append(string[::-1])\n        \n    return reversed_list\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/430": [{"task_id": "Mbpp/430", "solution": "\ndef parabola_directrix (a, b, c):\n    \"\"\"\n    Calculate the directrix of a parabola given its vertex coordinates (a, b) and its focal length c.\n\n    :param a: x-coordinate of the vertex\n    :param b: y-coordinate of the vertex\n    :param c: focal length\n    :return: The directrix of the parabola\n    \"\"\"\n    directrix=-b/(2*a)\n    return directrix\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 3, 2]], "plus_fail_tests": [[0, 0, 0]]}], "Mbpp/418": [{"task_id": "Mbpp/418", "solution": "\ndef Find_Max (lst):\n    return max(lst, key=len)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "\ndef sort_sublists (lst):\n    return [sorted(sublist) for sublist in lst]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/470": [{"task_id": "Mbpp/470", "solution": "\ndef add_pairwise (test_tup):\n    res=tuple(test_tup[i]+test_tup[i+1] for i in range(len(test_tup)-1))\n    return res\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/468": [{"task_id": "Mbpp/468", "solution": "\ndef max_product (arr):\n    n=len(arr)\n    max_product=[0]*n\n    max_product[0]=arr[0]\n    for i in range(1, n):\n        max_product[i]=max(arr[i]*max_product[i-1], arr[i])\n        \n    return max(max_product)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 100, 4, 5, 150, 6]]], "plus_fail_tests": [[[3, -5, 2, 6, -1, 4, -3]]]}], "Mbpp/448": [{"task_id": "Mbpp/448", "solution": "\ndef cal_sum (n):\n    p=[0, 2, 2, 4, 2, 8, 2, 14, 2, 28, 2, 34, 2, 44, 2, 54, 2, 66]\n    if n<len(p):\n        return p[n]\n        \n    \n    else :\n        return sum(cal_sum(i) for i in range(n+1))\n        \n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9]], "plus_fail_tests": [[-5]]}], "Mbpp/475": [{"task_id": "Mbpp/475", "solution": "\ndef sort_counter (counter_dict):\n    return sorted(counter_dict.items(), key=lambda x:x[1])\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"Math": 81, "Physics": 83, "Chemistry": 87}]], "plus_fail_tests": [[{"A": -10, "B": 20, "C": -5, "D": 15, "E": 0}]]}], "Mbpp/404": [{"task_id": "Mbpp/404", "solution": "\ndef minimum (a, b):\n    return a if a<b else b\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/473": [{"task_id": "Mbpp/473", "solution": "\ndef tuple_intersection (test_list1, test_list2):\n    res=set([tuple(sorted(ele)) for ele in test_list1])&set([tuple(sorted(ele)) for ele in test_list2])\n    return res\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "\ndef difference (n):\n    sum_of_cubes=sum([i**3 for i in range(1, n+1)])\n    sum_of_numbers=sum([i for i in range(1, n+1)])\n    return sum_of_cubes-sum_of_numbers\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/478": [{"task_id": "Mbpp/478", "solution": "\ndef remove_lowercase (s):\n    result=\"\"\n    for char in s:\n        if char.isupper():\n            result+=char\n            \n    \n    return result\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/414": [{"task_id": "Mbpp/414", "solution": "\ndef overlapping (seq1, seq2):\n    return any(item in seq2 for item in seq1)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "\ndef Split (arr):\n    return [i for i in arr if i%2!=0]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "\ndef toggle_string (s):\n    return ''.join([char.lower() if char.isupper() else char.upper() for char in s])\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/474": [{"task_id": "Mbpp/474", "solution": "\ndef replace_char (s, old, new):\n    return s.replace(old, new)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "\ndef issort_list (input_list):\n    for i in range(len(input_list)-1):\n        if input_list[i]>input_list[i+1]:\n            return  False \n            \n    \n    return  True \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/479": [{"task_id": "Mbpp/479", "solution": "\ndef first_Digit (n):\n    while n>=10:\n        n=n//10\n        \n    return n\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/463": [{"task_id": "Mbpp/463", "solution": "\ndef max_subarray_product (nums):\n    if  not nums:\n        return 0\n        \n    max_product=nums[0]\n    min_product=nums[0]\n    result=nums[0]\n    for i in range(1, len(nums)):\n        temp=max_product\n        max_product=max(nums[i], max_product*nums[i], min_product*nums[i])\n        min_product=min(nums[i], temp*nums[i], min_product*nums[i])\n        result=max(result, max_product)\n        \n    return result\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "\ndef max_sub_array_sum (nums, k):\n    max_sum=float('-inf')\n    current_sum=0\n    for num in nums:\n        current_sum=max(num, current_sum+num)\n        max_sum=max(max_sum, current_sum)\n        \n    return max_sum if max_sum>k else k\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-2, -3, 4, -1, -2, 1, 5, -3], 8]], "plus_fail_tests": [[[-10, -5, -3, -2, -1], 5]]}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "\ndef empty_list (n):\n    return [{} for _ in range(n)]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/472": [{"task_id": "Mbpp/472", "solution": "\ndef check_Consecutive (arr):\n    arr.sort()\n    for i in range(len(arr)-1):\n        if arr[i]+1!=arr[i+1]:\n            return  False \n            \n    \n    return  True \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "\ndef two_unique_nums (nums_list):\n    unique_nums=[]\n    for num in nums_list:\n        if num not  in unique_nums:\n            unique_nums.append(num)\n            \n    \n    return unique_nums\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 2, 3, 4, 5]]], "plus_fail_tests": [[[1, 2, 3, 2, 4, 5, 3, 6, 4, 7, 8, 9, 5, 6]]]}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "\ndef union_elements (test_tup1, test_tup2):\n    res=set(test_tup1).union(set(test_tup2))\n    return tuple(sorted(res))\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "\ndef split (s):\n    return list(s)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "\ndef count_Pairs (arr, n):\n    count=0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i]!=arr[j]:\n                count+=1\n                \n        \n    \n    return count\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/287": [{"task_id": "Mbpp/287", "solution": "\ndef square_Sum (n):\n    total=0\n    for i in range(1, n+1):\n        total+=(2*i)**2\n        \n    return total\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000]]}], "Mbpp/476": [{"task_id": "Mbpp/476", "solution": "\ndef big_sum (arr):\n    return min(arr)+max(arr)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/471": [{"task_id": "Mbpp/471", "solution": "\ndef find_remainder (arr, n):\n    product=1\n    for num in arr:\n        product=(product*num)%n\n        \n    return product\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "\ndef find_Odd_Pair (arr, n):\n    odd_count=0\n    for i in range(n):\n        if (arr[i]%2):\n            odd_count+=1\n            \n    \n    return odd_count*2\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[7, 2, 8, 1, 0, 5, 11], 7]], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10]]}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "\ndef Find_Max_Length (lst):\n    return max(len(sublist) for sublist in lst)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/465": [{"task_id": "Mbpp/465", "solution": "\ndef drop_empty (dictionary):\n    return {k:v for k,v in dictionary.items() if v is  not  None }\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "\ndef unique_product (nums):\n    unique_nums=set(nums)\n    product=1\n    for num in unique_nums:\n        product*=num\n        \n    return product\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "\ndef is_Sub_Array (sub, main):\n    len_sub=len(sub)\n    len_main=len(main)\n    if len_sub>len_main:\n        return  False \n        \n    for i in range(len_main-len_sub+1):\n        if main[i:i+len_sub]==sub:\n            return  True \n            \n    \n    return  False \n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], [1, 2, 3]]]}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "\ndef last_Digit_Factorial (n):\n    if n<0:\n        return \"Invalid input\"\n        \n    factorial=1\n    for i in range(1, n+1):\n        factorial*=i\n        factorial=factorial%10\n        \n    return factorial\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2.5]]}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "\nfrom math import factorial\ndef binomial_coefficient (n, k):\n    return factorial(n)//(factorial(k)*factorial(n-k))\n    \ndef sum_Of_product (n):\n    sum=0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum+=binomial_coefficient(i, j)*binomial_coefficient(j+1, i-j)\n            \n    \n    return sum\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[10]]}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "\ndef perfect_squares (start, end):\n    squares=[]\n    for i in range(int(start**0.5), int(end**0.5)+1):\n        squares.append(i*i)\n        \n    return sorted(squares)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[50, 100]], "plus_fail_tests": [[-10, -1]]}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "\ndef split_Arr (arr, n):\n    return arr[n:]+arr[:n]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/606": [{"task_id": "Mbpp/606", "solution": "\nimport math\ndef radian_degree (degrees):\n    return degrees*(math.pi/180)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "\ndef extract_even (mixed_tuple):\n    result=[]\n    for item in mixed_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n            \n        \n        elif isinstance(item, int) and item%2==0:\n            result.append(item)\n            \n    \n    return tuple(result)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "\nimport math\ndef polar_rect (r, theta):\n    x=r*math.cos(theta)\n    y=r*math.sin(theta)\n    return (x, y), (-2+2.4492935982947064e-16j)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4]], "plus_fail_tests": [[-1, 0]]}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "\ndef swap_List (lst):\n    if len(lst)>1:\n        lst[0],lst[-1]=lst[-1], lst[0]\n        \n    return lst\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "\ndef diff_even_odd (lst):\n    even=lst[0] if lst[0]%2==0 else  None \n    odd=lst[0] if lst[0]%2!=0 else  None \n    while even is  not  None  and even not  in lst:\n        even=lst[lst.index(even)+1] if lst[lst.index(even)+1]%2==0 else lst[lst.index(even)+2] if lst[lst.index(even)+2]%2!=0 else  None \n        \n    while odd is  not  None  and odd not  in lst:\n        odd=lst[lst.index(odd)+1] if lst[lst.index(odd)+1]%2!=0 else lst[lst.index(odd)+2] if lst[lst.index(odd)+2]%2==0 else  None \n        \n    return odd-even if odd is  not  None  and even is  not  None  else  None \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, 5, 7, 4, 1, 6, 8]]], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]}], "Mbpp/607": [{"task_id": "Mbpp/607", "solution": "\nimport re\ndef find_literals (text, pattern):\n    match=re.search(pattern, text)\n    if match:\n        return match.group(), match.start(), match.end()\n        \n    return  None ,  None ,  None \n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["", "rfvPtELLC"]]}], "Mbpp/602": [{"task_id": "Mbpp/602", "solution": "\ndef first_repeated_char (s):\n    seen=set()\n    for char in s:\n        if char in seen:\n            return char\n            \n        seen.add(char)\n        \n    return  None \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "\ndef big_diff (lst):\n    return max(lst)-min(lst)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "\nimport sys\ndef tuple_size (t):\n    return sys.getsizeof(t)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/604": [{"task_id": "Mbpp/604", "solution": "\ndef reverse_words (s):\n    return ' '.join(s.split()[::-1])\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "\ndef removezero_ip (ip_address):\n    ip_parts=ip_address.split('.')\n    ip_parts=[str(int(part)) for part in ip_parts]\n    return '.'.join(ip_parts)\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["0.0.0.0"]]}], "Mbpp/462": [{"task_id": "Mbpp/462", "solution": "\nfrom itertools import chain, combinations\ndef combinations_list (lst):\n    result=[]\n    for i in range(len(lst)+1):\n        result.extend(combinations(lst, i))\n        \n    return [list(item) for item in result]\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["orange", "red", "green", "blue"]]], "plus_fail_tests": [[["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]]]}], "Mbpp/603": [{"task_id": "Mbpp/603", "solution": "\ndef get_ludic (n):\n    ludic_numbers=[]\n    for i in range(1, n+1):\n        if is_lucasian(i):\n            ludic_numbers.append(i)\n            \n    \n    return ludic_numbers\n    \ndef is_lucasian (n):\n    if n<11:\n        return  False \n        \n    if n==11:\n        return  True \n        \n    a,b=1, 2\n    for _ in range(3, n+1):\n        a,b=b, a+b\n        if b==n or a==n:\n            return  True \n            \n        if b>n:\n            return  False \n            \n    \n    return  False \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[100]]}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "\ndef catalan_number (n):\n    if n<=1:\n        return 1\n        \n    catalan=[0 for i in range(n+1)]\n    catalan[0]=1\n    catalan[1]=1\n    for i in range(2, n+1):\n        catalan[i]=0\n        for j in range(i):\n            catalan[i]=catalan[i]+catalan[j]*catalan[i-j-1]\n            \n    \n    return catalan[n]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "\ndef expensive_items (dataset, n):\n    sorted_data=sorted(dataset, key=lambda x:x['price'], reverse= True )\n    return sorted_data[:n]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "\ndef find_dissimilar (t1, t2):\n    return tuple(set(t1)-set(t2)), tuple(set(t2)-set(t1))\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 4, 5, 6], [5, 7, 4, 10]]], "plus_fail_tests": [[[3, 4, 5, 6, 7, 8, 9], [5, 7, 4, 10, 12, 14, 16]]]}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "\ndef surface_Area (side_length, height):\n    base_area=side_length**2\n    lateral_area=2*side_length*height\n    total_area=base_area+lateral_area\n    return total_area\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "\ndef interleave_lists (list1, list2, list3):\n    result=[]\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n        \n    return result\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "\ndef list_tuple (lst):\n    return tuple(lst)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/626": [{"task_id": "Mbpp/626", "solution": "\nimport math\ndef triangle_area (radius):\n    if radius<0:\n        return  None \n        \n    return radius**2*math.asin(radius/2)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[0.5]]}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "\ndef armstrong_number (num):\n    order=len(str(num))\n    sum=0\n    temp=num\n    while temp>0:\n        digit=temp%10\n        sum+=digit**order\n        temp//=10\n        \n    return num==sum\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "\ndef is_Even (n):\n    return n%2==0\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/622": [{"task_id": "Mbpp/622", "solution": "\ndef get_median (nums1, nums2, n):\n    m,n=len(nums1), len(nums2)\n    if m>n:\n        return get_median(nums2, nums1, n, m)\n        \n    imin,imax,half_len=0, m, (m+n+1)//2\n    while imin<=imax:\n        i=(imin+imax)//2\n        j=half_len-i\n        if i<m and nums2[j-1]>nums1[i]:\n            imin=i+1\n            \n        \n        elif i>0 and nums1[i-1]>nums2[j]:\n            imax=i-1\n            \n        \n        else :\n            if i==0:\n                max_of_left=nums2[j-1]\n                \n            \n            elif j==0:\n                max_of_left=nums1[i-1]\n                \n            \n            else :\n                max_of_left=max(nums1[i-1], nums2[j-1])\n                \n            if (m+n)%2==1:\n                return max_of_left\n                \n            if i==m:\n                min_of_right=nums2[j]\n                \n            \n            elif j==n:\n                min_of_right=nums1[i]\n                \n            \n            else :\n                min_of_right=min(nums1[i], nums2[j])\n                \n            return (max_of_left+min_of_right)/2.0\n            \n    \n\n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[3, 6, 14, 23], [2, 18, 27, 39, 49, 55], 4]]}], "Mbpp/629": [{"task_id": "Mbpp/629", "solution": "\ndef Split (numbers):\n    return [num for num in numbers if num%2==0]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/610": [{"task_id": "Mbpp/610", "solution": "\ndef remove_kth_element (arr, k):\n    return [arr[:k-1]+arr[k+1:] for k in range(len(arr)) if k!=k-1]\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, 2, 3, 4, 4, 5, 1], 3]], "plus_fail_tests": [[[1, 2, 3, 4, 5], 1]]}], "Mbpp/618": [{"task_id": "Mbpp/618", "solution": "\ndef div_list (list1, list2):\n    return [float(i)/float(j) for i,j in zip(list1, list2)]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/612": [{"task_id": "Mbpp/612", "solution": "\ndef merge (list_of_lists):\n    first_elements=[sublist[0] for sublist in list_of_lists]\n    second_elements=[sublist[1] for sublist in list_of_lists]\n    return [first_elements, second_elements]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/615": [{"task_id": "Mbpp/615", "solution": "\ndef average_tuple (tuples):\n    return [sum(t)/len(t) for t in tuples]\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]]], "plus_fail_tests": [[[[7, 8, 9], [-2, -4, -6], [0, 20, 30]]]]}], "Mbpp/623": [{"task_id": "Mbpp/623", "solution": "\ndef nth_nums (nums, power):\n    return [num**power for num in nums]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/614": [{"task_id": "Mbpp/614", "solution": "\ndef cummulative_sum (tuples):\n    total=0\n    for sublist in tuples:\n        for item in sublist:\n            total+=item\n            \n    \n    return total\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/611": [{"task_id": "Mbpp/611", "solution": "\ndef max_of_nth (matrix, n):\n    return max(row[n] for row in matrix)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/608": [{"task_id": "Mbpp/608", "solution": "\ndef bell_Number (n):\n    bell=[[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0]=1\n    for i in range(1, n+1):\n        bell[i][0]=bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j]=bell[i-1][j-1]+bell[i][j-1]\n            \n    \n    return bell[n][0]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/620": [{"task_id": "Mbpp/620", "solution": "\ndef largest_subset (nums):\n    nums.sort()\n    n=len(nums)\n    dp=[1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i]%nums[j] ==0:\n                dp[i]=max(dp[i], dp[j]+1)\n                \n        \n    \n    return max(dp)\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[9, 3, 12, 7, 16, 3, 11, 8, 4, 13, 13]]]}], "Mbpp/628": [{"task_id": "Mbpp/628", "solution": "\ndef replace_spaces (s):\n    return s.replace(' ', '%20')\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/616": [{"task_id": "Mbpp/616", "solution": "\ndef tuple_modulo (t1, t2):\n    return tuple(t1[i]%t2[i] for i in range(len(t1)))\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/619": [{"task_id": "Mbpp/619", "solution": "\ndef move_num (s):\n    num_list=[char for char in s if char.isdigit()]\n    non_num_list=[char for char in s if  not char.isdigit()]\n    result=''.join(non_num_list+num_list)\n    return result\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/624": [{"task_id": "Mbpp/624", "solution": "\ndef is_upper (s):\n    return s.upper()\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/605": [{"task_id": "Mbpp/605", "solution": "\ndef prime_num (n):\n    if n<=1:\n        return  False \n        \n    if n==2:\n        return  True \n        \n    if n%2==0:\n        return  False \n        \n    i=3\n    while i*i<=n:\n        if n%i==0:\n            return  False \n            \n        i+=2\n        \n    return  True \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/637": [{"task_id": "Mbpp/637", "solution": "\ndef noprofit_noloss (profit, loss):\n    return profit==0 and loss==0\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[100, 100]], "plus_fail_tests": [[-100, -100]]}], "Mbpp/633": [{"task_id": "Mbpp/633", "solution": "\ndef pair_xor_Sum (arr, n):\n    xor_sum=0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum+=arr[i]^arr[j]\n            \n    \n    return xor_sum\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/638": [{"task_id": "Mbpp/638", "solution": "\ndef wind_chill velocity temp\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \n    Args:\n    velocity: Wind velocity in km/h.\n    temp: Temperature in celsius.\n    \n    Returns:\n    Wind chill index rounded to the next integer.\n    \"\"\"\n    wchil=13.12+0.6215*temp-11.37*velocity+0.3965*temp*velocity+0.03965*temp*temp-0.1129*temp*temp*velocity-0.00075*temp*temp*temp+0.0545*temp*temp*temp*velocity+0.0075*temp*temp*temp*temp-0.0005*temp*temp*temp*temp*velocity-0.0536*temp*temp*temp*temp*temp-0.0023*temp*temp*temp*temp*temp*velocity+0.0005*temp*temp*temp*temp*temp*temp*velocity+0.0536*temp*temp*temp*temp*temp*temp*temp*velocity+0.125*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.065*temp*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.025*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.008*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.001*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.0001*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.00001*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*temp*velocity+0.000001*temp*temp", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/739": [{"task_id": "Mbpp/739", "solution": "\ndef find_Index (n):\n    def triangular_number (k):\n        return k*(k+1)//2\n        \n    start=1\n    while len(str(triangular_number(start)))<n:\n        start+=1\n        \n    end=start+1\n    while len(str(triangular_number(end)))<n+1:\n        end+=1\n        \n    while triangular_number(start)>=triangular_number(end):\n        start+=1\n        \n    return start+triangular_number(start-1)//2-1\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[5]]}], "Mbpp/721": [{"task_id": "Mbpp/721", "solution": "\ndef maxAverageOfPath (grid):\n    N=len(grid)\n    dp=[[0]*N for _ in range(N)]\n    dp[0][0]=grid[0][0]\n    for i in range(1, N):\n        dp[0][i]=dp[0][i-1]+grid[0][i]\n        dp[i][0]=dp[i-1][0]+grid[i][0]\n        \n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j]=min(dp[i-1][j], dp[i][j-1])+grid[i][j]\n            \n    \n    max_avg=0\n    for i in range(N):\n        for j in range(N):\n            for k in range(i+1, N):\n                for l in range(j+1, N):\n                    if i==0 and j==0:\n                        continue \n                        \n                    \n                    elif i==0:\n                        dp[i][l]=dp[i][l-1]+grid[i][l]\n                        dp[l][i]=dp[l-1][i]+grid[l][i]\n                        \n                    \n                    elif j==0:\n                        dp[i][l]=dp[i-1][l]+grid[i][l]\n                        dp[l][j]=dp[l-1][j]+grid[l][j]\n                        \n                    \n                    else :\n                        dp[i][l]=dp[i-1][l]+grid[i][l]\n                        dp[l][j]=dp[l][j-1]+grid[l][j]\n                        \n                    avg=(dp[i][l]+dp[l][j])/2\n                    if avg>max_avg:\n                        max_avg=avg\n                        \n                \n            \n        \n    \n    return max_avg\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [6, 5, 4], [7, 3, 9]]]], "plus_fail_tests": [[[[0, 0, 0], [0, 0, 0], [0, 0, -1]]]]}], "Mbpp/735": [{"task_id": "Mbpp/735", "solution": "\ndef toggle_middle_bits (n):\n    binary=bin(n)[2:]\n    if len(binary)<=2:\n        return n\n        \n    binary=binary[0]+''.join('1' if bit=='0' else '0' for bit in binary[1:-1])+binary[-1]\n    return int(binary, 2)\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[true]]}], "Mbpp/740": [{"task_id": "Mbpp/740", "solution": "\ndef tuple_to_dict (t):\n    return {t[i]:t[i+1] for i in range(0, len(t)-1, 2)}\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/734": [{"task_id": "Mbpp/734", "solution": "\ndef sum_Of_Subarray_Prod (arr):\n    total=0\n    for i in range(len(arr)):\n        product=1\n        for j in range(i, len(arr)):\n            product*=arr[j]\n            total+=product\n            \n    \n    return total\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/726": [{"task_id": "Mbpp/726", "solution": "\ndef multiply_elements (t):\n    if len(t)==1:\n        return ()\n        \n    result=tuple(t[i]*t[i+1] for i in range(len(t)-1))\n    return result\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/731": [{"task_id": "Mbpp/731", "solution": "\nimport math\ndef lateralsurface_cone (r, h):\n    lateral_surface_area=math.pi*(r+h)*math.sqrt(r**2+h**2)\n    return lateral_surface_area\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 12]], "plus_fail_tests": [[2.5, 8.3]]}], "Mbpp/720": [{"task_id": "Mbpp/720", "solution": "\ndef add_dict_to_tuple (t, d):\n    return t+(d, )\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/733": [{"task_id": "Mbpp/733", "solution": "\ndef find_first_occurrence (arr, target):\n    left,right=0, len(arr)-1\n    result=-1\n    while left<=right:\n        mid=(left+right)//2\n        if arr[mid]==target:\n            result=mid\n            right=mid-1\n            \n        \n        elif arr[mid]<target:\n            left=mid+1\n            \n        \n        else :\n            right=mid-1\n            \n    \n    return result\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/639": [{"task_id": "Mbpp/639", "solution": "\ndef sample_nam (names):\n    total=0\n    for name in names:\n        if name[0].isupper():\n            total+=len(name)\n            \n    \n    return total\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["AbCdE", "fGH", "IJKLMnOp", "qrs", "TUVW", "xyz"]]]}], "Mbpp/643": [{"task_id": "Mbpp/643", "solution": "\ndef text_match_wordz_middle (text):\n    words=text.split()\n    for word in words:\n        if word[1:-1].lower()=='z':\n            return  True \n            \n    \n    return  False \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["pythonzabc."]], "plus_fail_tests": [["zzzxyabczzz"]]}], "Mbpp/631": [{"task_id": "Mbpp/631", "solution": "\ndef replace_spaces (input_string):\n    output_string=\"\"\n    for char in input_string:\n        if char.isspace():\n            output_string+=\"_\"\n            \n        \n        elif char.isalpha():\n            output_string+=char.upper() if char.islower() else char.lower()\n            \n        \n        else :\n            output_string+=char\n            \n    \n    return output_string\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Jumanji The Jungle"]], "plus_fail_tests": [["abcdefg"]]}], "Mbpp/635": [{"task_id": "Mbpp/635", "solution": "\ndef heap_sort (arr):\n    n=len(arr)\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n        \n    for i in range(n-1, 0, -1):\n        arr[i],arr[0]=arr[0], arr[i]\n        heapify(arr, i, 0)\n        \n    return arr\n    \ndef heapify (arr, n, i):\n    largest=i\n    l=2*i+1\n    r=2*i+2\n    if l<n and arr[i]<arr[l]:\n        largest=l\n        \n    if r<n and arr[largest]<arr[r]:\n        largest=r\n        \n    if largest!=i:\n        arr[i],arr[largest]=arr[largest], arr[i]\n        heapify(arr, n, largest)\n        \n\n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/632": [{"task_id": "Mbpp/632", "solution": "\ndef move_zero (arr):\n    non_zero=[x for x in arr if x!=0]\n    num_zeros=len(arr)-len(non_zero)\n    zeros=[0]*num_zeros\n    return non_zero+zeros\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/641": [{"task_id": "Mbpp/641", "solution": "\ndef is_nonagonal (n):\n    return n*(7*n-5)//2\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/644": [{"task_id": "Mbpp/644", "solution": "\ndef reverse_Array_Upto_K (arr, k):\n    \"\"\"\n    Reverses the elements of the array 'arr' up to the given position 'k'.\n    \n    Parameters:\n    arr (list): The input list to be reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The reversed list.\n    \"\"\"\n    if k<0 or k>=len(arr):\n        return arr\n        \n    return arr[:k+1][::-1]+arr[k+1:]\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5, 6], 4]], "plus_fail_tests": [[[6, 9, 2, 1, 5, 3], 4]]}], "Mbpp/725": [{"task_id": "Mbpp/725", "solution": "\nimport re\ndef extract_quotation (text):\n    pattern=r'\"(.*?)\"'\n    matches=re.findall(pattern, text)\n    return matches\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/737": [{"task_id": "Mbpp/737", "solution": "\nimport re\ndef check_str (s):\n    pattern=r\"^[aeiouAEIOU]\"\n    if re.match(pattern, s):\n        return  True \n        \n    \n    else :\n        return  False \n        \n\n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/730": [{"task_id": "Mbpp/730", "solution": "\ndef consecutive_duplicates (lst):\n    if  not lst:\n        return []\n        \n    result=[lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i]!=lst[i-1]:\n            result.append(lst[i])\n            \n    \n    return result\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/753": [{"task_id": "Mbpp/753", "solution": "\ndef min_k (test_cases, k):\n    sorted_list=sorted(test_cases, key=lambda x:x[1])\n    return sorted_list[:k]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/742": [{"task_id": "Mbpp/742", "solution": "\nimport math\ndef area_tetrahedron (a):\n    \"\"\"\n    Calculate the area of a tetrahedron.\n    \n    Parameters:\n    a (float): The length of the edge of the tetrahedron's base.\n    \n    Returns:\n    float: The area of the tetrahedron.\n    \"\"\"\n    s=(a*a*a)/(4.0*math.sqrt(2))\n    area=math.sqrt(s*(s-a)*(s-a)*(s-a))/4.0\n    return area\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/732": [{"task_id": "Mbpp/732", "solution": "\ndef replace_specialchar (text):\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/751": [{"task_id": "Mbpp/751", "solution": "\ndef check_min_heap (arr):\n    n=len(arr)\n    for i in range(n):\n        left_child=2*i+1\n        right_child=2*i+2\n        if left_child<n and arr[i]>arr[left_child]:\n            return  False \n            \n        if right_child<n and arr[i]>arr[right_child]:\n            return  False \n            \n    \n    return  True \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/752": [{"task_id": "Mbpp/752", "solution": "\ndef jacobsthal_num (n:int)->int:\n    if n==0:\n        return 0\n        \n    \n    elif n==1:\n        return 1\n        \n    \n    else :\n        return 2*jacobsthal_num(n-1)+jacobsthal_num(n-2)\n        \n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[100]]}], "Mbpp/748": [{"task_id": "Mbpp/748", "solution": "\ndef capital_words_spaces (s):\n    words=s.split()\n    for i in range(len(words)):\n        if words[i][0].isupper():\n            words[i]=words[i]+' '\n            \n    \n    return ''.join(words)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Python"]], "plus_fail_tests": [["MyNameIsAIAndIAmHereToHelpYou"]]}], "Mbpp/728": [{"task_id": "Mbpp/728", "solution": "\ndef sum_list (list1, list2):\n    return [x+y for x,y in zip(list1, list2)]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/736": [{"task_id": "Mbpp/736", "solution": "\ndef left_insertion (sorted_list, value):\n    low=0\n    high=len(sorted_list)\n    while low<high:\n        mid=(low+high)//2\n        if sorted_list[mid]<value:\n            low=mid+1\n            \n        \n        else :\n            high=mid\n            \n    \n    return low\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/723": [{"task_id": "Mbpp/723", "solution": "\ndef count_same_pair (list1, list2):\n    count=0\n    for i in range(len(list1)):\n        if list1[i]==list2[i]:\n            count+=1\n            \n    \n    return count\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/741": [{"task_id": "Mbpp/741", "solution": "\ndef all_Characters_Same (s):\n    return len(set(s))==1\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/745": [{"task_id": "Mbpp/745", "solution": "\ndef divisible_by_digits (startnum, ti, endnum):\n    result=[]\n    for num in range(startnum, ti+1):\n        if all(num%i==0 for i in range(10) if num//10**i!=0):\n            result.append(num)\n            \n    \n    return result\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 22]], "plus_fail_tests": [[100, 200]]}], "Mbpp/743": [{"task_id": "Mbpp/743", "solution": "\ndef rotate_right (lst, k):\n    k=k%len(lst)\n    return lst[-k:]+lst[:-k]\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 0]]}], "Mbpp/724": [{"task_id": "Mbpp/724", "solution": "\ndef power_base_sum (base, power):\n    total=0\n    for i in range(power):\n        total+=base%10\n        base//=10\n        \n    return total\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2, 100]], "plus_fail_tests": [[11, 100]]}], "Mbpp/759": [{"task_id": "Mbpp/759", "solution": "\ndef is_decimal (s):\n    try:\n        float(s)\n        if '.' in s:\n            fractional_part=s.split('.')[1]\n            if fractional_part.count('.')>1:\n                return  False \n                \n            if int(fractional_part)!=fractional_part:\n                return  False \n                \n        \n        return  True \n        \n    \n    except ValueError:\n        return  False \n        \n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["123.11"]], "plus_fail_tests": [["123.11"]]}], "Mbpp/757": [{"task_id": "Mbpp/757", "solution": "\ndef count_reverse_pairs (str_list):\n    reverse_pairs=0\n    for i in range(len(str_list)):\n        for j in range(i+1, len(str_list)):\n            if str_list[i]==str_list[j][::-1]:\n                reverse_pairs+=1\n                \n        \n    \n    return reverse_pairs\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/763": [{"task_id": "Mbpp/763", "solution": "\ndef find_min_diff (arr, target):\n    arr.sort()\n    min_diff=float('inf')\n    for i in range(len(arr)-1):\n        diff=arr[i+1]-arr[i]\n        if diff<min_diff:\n            min_diff=diff\n            \n    \n    return min_diff if min_diff<=target else -1\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 5, 3, 19, 18, 25], 6]], "plus_fail_tests": [[[15, 12, 20, 30, 8, 4, 19, 37, 22, 28, 11, 25], 12]]}], "Mbpp/771": [{"task_id": "Mbpp/771", "solution": "\ndef check_expression (expression):\n    stack=[]\n    mapping={\")\":\"(\", \"}\":\"{\", \"]\":\"[\"}\n    for char in expression:\n        if char in mapping.values():\n            stack.append(char)\n            \n        \n        elif char in mapping.keys():\n            if stack==[] or mapping[char]!=stack.pop():\n                return  False \n                \n        \n        \n        else :\n            continue \n            \n    \n    return stack==[]\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/766": [{"task_id": "Mbpp/766", "solution": "\ndef pair_wise (lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/782": [{"task_id": "Mbpp/782", "solution": "\ndef odd_length_sum (arr):\n    total=0\n    for i in range(0, len(arr), 2):\n        total+=sum(arr[i:])\n        \n    return total\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 4]]], "plus_fail_tests": [[[4, 3, 2, 1, 9, 10, 7]]]}], "Mbpp/807": [{"task_id": "Mbpp/807", "solution": "\ndef first_odd (nums):\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n\n    Args:\n    nums (list): A list of numbers.\n\n    Returns:\n    int: The first odd number in the list. If no odd number is found, returns None.\n    \"\"\"\n    for num in nums:\n        if num%2!=0:\n            return num\n            \n    \n    return  None \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/754": [{"task_id": "Mbpp/754", "solution": "\ndef extract_index_list (l1, l2, l3):\n    common_elements=[]\n    for i in range(len(l1)):\n        if l1[i]==l2[i]==l3[i]:\n            common_elements.append(l1[i])\n            \n    \n    return common_elements\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 4, 6, 8, 10, 12, 14], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]]]}], "Mbpp/784": [{"task_id": "Mbpp/784", "solution": "\ndef mul_even_odd (lst):\n    even_product=1\n    odd_product=1\n    for num in lst:\n        if num%2==0:\n            even_product*=num\n            \n        \n        else :\n            odd_product*=num\n            \n    \n    return even_product*odd_product\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, 5, 7, 4, 1, 6, 8]]], "plus_fail_tests": [[[-10, -5, 0, 5, 10]]]}], "Mbpp/750": [{"task_id": "Mbpp/750", "solution": "\ndef add_tuple (lst, tpl):\n    return lst+tpl\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[5, 6, 7], [9, 10]]], "plus_fail_tests": [[[], [1, 2]]]}], "Mbpp/788": [{"task_id": "Mbpp/788", "solution": "\ndef new_tuple (given_string, given_list):\n    return tuple(given_string)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["WEB", "is"], "best"]], "plus_fail_tests": [[[], ""]]}], "Mbpp/809": [{"task_id": "Mbpp/809", "solution": "\ndef check_smaller (t1, t2):\n    for i in range(len(t1)):\n        if t1[i]>=t2[i]:\n            return  False \n            \n    \n    return  True \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3], [2, 3, 4]]], "plus_fail_tests": [[[3, 7, 11, 15, 19], [2, 6, 10, 14, 18]]]}], "Mbpp/780": [{"task_id": "Mbpp/780", "solution": "\nfrom itertools import combinations\ndef find_combinations (tuple_list):\n    result=[]\n    for i in range(2, len(tuple_list)+1):\n        for subset in combinations(tuple_list, i):\n            sums=tuple(sum(subset))\n            result.append(sums)\n            \n    \n    return result\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [3, 4, 5]]]], "plus_fail_tests": [[[[100, 200], [300, 400], [500, 600], [700, 800]]]]}], "Mbpp/781": [{"task_id": "Mbpp/781", "solution": "\ndef count_divisors (n):\n    count=0\n    for i in range(1, n+1):\n        if n%i==0:\n            count+=1\n            \n    \n    return count\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[1]]}], "Mbpp/722": [{"task_id": "Mbpp/722", "solution": "\ndef filter_data (student_dict, min_height, min_weight):\n    filtered_students={}\n    for student,(height, weight) in student_dict.items():\n        if height>min_height and weight>min_weight:\n            filtered_students[student]=(height, weight)\n            \n    \n    return filtered_students\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"Cierra Vega": [6.2, 70], "Alden Cantrell": [5.9, 65], "Kierra Gentry": [6.0, 68], "Pierre Cox": [5.8, 66]}, 6.0, 70]], "plus_fail_tests": [[{"Alice": [5.6, 60], "Bob": [6.1, 70], "Charlie": [5.9, 65], "Dave": [5.11, 72], "Eve": [6.0, 68], "Frank": [5.7, 63]}, 5.8, 65]]}], "Mbpp/786": [{"task_id": "Mbpp/786", "solution": "\ndef right_insertion (lst, value):\n    for i in range(len(lst)):\n        if value<=lst[i]:\n            return i\n            \n    \n    return len(lst)\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[50.64327388212607, -72.16612625583227, 95.25630303581863, -75.73998556144497, 11.857449640680656, 90.05081633927793, -90.20293226837086, -12.02758648076636, -35.964731488229475], 7]]}], "Mbpp/792": [{"task_id": "Mbpp/792", "solution": "\ndef count_list (lst):\n    return len(lst)\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 3, [4, [5, [6, [7, [8, 9]]]]]]]]}], "Mbpp/755": [{"task_id": "Mbpp/755", "solution": "\ndef second_smallest (numbers):\n    unique_numbers=list(set(numbers))\n    if len(unique_numbers)<2:\n        return  None \n        \n    unique_numbers.sort()\n    return unique_numbers[1]\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/762": [{"task_id": "Mbpp/762", "solution": "\ndef check_monthnumber_number (month_number):\n    months_with_30_days=[1, 3, 5, 7, 8, 10, 12]\n    if month_number in months_with_30_days:\n        return  True \n        \n    \n    else :\n        return  False \n        \n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[6]], "plus_fail_tests": [[1]]}], "Mbpp/767": [{"task_id": "Mbpp/767", "solution": "\ndef get_pairs_count (lst, target_sum):\n    \"\"\"\n    Count the number of pairs in the list that sum up to the target sum.\n\n    Args:\n    lst: A list of integers.\n    target_sum: The target sum for the pairs.\n\n    Returns:\n    An integer count of pairs that sum up to the target sum.\n    \"\"\"\n    freq={}\n    for num in lst:\n        if num in freq:\n            freq[num]+=1\n            \n        \n        else :\n            freq[num]=1\n            \n    \n    count=0\n    for num in lst:\n        complement=target_sum-num\n        if complement in freq:\n            count+=freq[complement]\n            if complement==num:\n                count-=1\n                \n        \n    \n    return count//2\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/798": [{"task_id": "Mbpp/798", "solution": "\ndef _sum (arr):\n    return sum(arr)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/801": [{"task_id": "Mbpp/801", "solution": "\ndef test_three_equal (a, b, c):\n    return max(a, b, c)-min(a, b, c)+1 if max(a, b, c)!=min(a, b, c) else 0\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 1, 1]], "plus_fail_tests": [[1, 2, 3]]}], "Mbpp/775": [{"task_id": "Mbpp/775", "solution": "\ndef odd_position (lst):\n    for i in range(1, len(lst), 2):\n        if lst[i]%2==0:\n            return  False \n            \n    \n    return  True \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/790": [{"task_id": "Mbpp/790", "solution": "\ndef even_position (arr):\n    for i in range(0, len(arr), 2):\n        if arr[i]%2!=0:\n            return  False \n            \n    \n    return  True \n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 1, 4, 2, 6, 1, 8, 2, 10, 1, 12]]]}], "Mbpp/760": [{"task_id": "Mbpp/760", "solution": "\ndef unique_Element (numbers):\n    return len(set(numbers))==1\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/769": [{"task_id": "Mbpp/769", "solution": "\ndef Diff (list1, list2):\n    result=[]\n    for i in range(len(list1)):\n        if list1[i] not  in list2:\n            result.append(list1[i])\n            \n    \n    for i in range(len(list2)):\n        if list2[i] not  in list1:\n            result.append(list2[i])\n            \n    \n    return result\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/800": [{"task_id": "Mbpp/800", "solution": "\ndef remove_all_spaces (s):\n    return s.replace(' ', '')\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/787": [{"task_id": "Mbpp/787", "solution": "\nimport re\ndef text_match_three (text):\n    \"\"\"\n    Matches a string that has an a followed by three 'b'.\n    \n    Args:\n    text (str): The string to be checked.\n    \n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern=r'ab{3}'\n    return bool(re.search(pattern, text))\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/804": [{"task_id": "Mbpp/804", "solution": "\ndef is_product_even (nums):\n    product=1\n    for num in nums:\n        if num%2==0:\n            product*=num\n            \n    \n    return product%2==0\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/630": [{"task_id": "Mbpp/630", "solution": "\ndef get_coordinates (coord):\n    x,y=coord\n    return [[x+dx, y+dy] for dx in range(-1, 2) for dy in range(-1, 2) if (dx, dy)!=(0, 0)]\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 4]]], "plus_fail_tests": [[[1, 1, 1]]]}], "Mbpp/758": [{"task_id": "Mbpp/758", "solution": "\ndef unique_sublists (input_list):\n    output_dict={}\n    for sublist in input_list:\n        t=tuple(sublist)\n        if t in output_dict:\n            output_dict[t]+=1\n            \n        \n        else :\n            output_dict[t]=1\n            \n    \n    return output_dict\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/773": [{"task_id": "Mbpp/773", "solution": "\ndef occurance_substring (string, substring):\n    start=string.find(substring)\n    if start==-1:\n        return  None \n        \n    end=start+len(substring)\n    return (substring, start, end)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/770": [{"task_id": "Mbpp/770", "solution": "\ndef odd_num_sum (n):\n    sum=0\n    for i in range(1, n+1):\n        sum+=(i*2-1)**4\n        \n    return sum\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/772": [{"task_id": "Mbpp/772", "solution": "\ndef remove_length (s, k):\n    words=s.split()\n    result=[word for word in words if len(word)!=k]\n    return ' '.join(result)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/777": [{"task_id": "Mbpp/777", "solution": "\ndef find_sum (arr):\n    unique_elements=set(arr)\n    sum_of_non_repeated=sum([x for x in unique_elements if arr.count(x)==1])\n    return sum_of_non_repeated\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 1, 1, 4, 5, 6]]], "plus_fail_tests": [[[-1, -2, -3, -1, -1, -4, -5, -6]]]}], "Mbpp/806": [{"task_id": "Mbpp/806", "solution": "\ndef max_run_uppercase (s):\n    max_run=0\n    current_run=0\n    for char in s:\n        if char.isupper():\n            current_run+=1\n            max_run=max(max_run, current_run)\n            \n        \n        else :\n            current_run=0\n            \n    \n    return max_run\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Aaa"]]}], "Mbpp/803": [{"task_id": "Mbpp/803", "solution": "\ndef is_perfect_square (num):\n    if num<0:\n        return  False \n        \n    root=int(num**0.5)\n    return root*root==num\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/793": [{"task_id": "Mbpp/793", "solution": "\ndef last (arr, target):\n    left,right=0, len(arr)-1\n    while left<=right:\n        mid=(left+right)//2\n        if arr[mid]<=target:\n            left=mid+1\n            \n        \n        else :\n            right=mid-1\n            \n    \n    return right if right>=0 and arr[right]==target else -1\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/778": [{"task_id": "Mbpp/778", "solution": "\ndef pack_consecutive_duplicates (lst):\n    if  not lst:\n        return []\n        \n    result=[]\n    current_group=[lst[0]]\n    for element in lst[1:]:\n        if element==current_group[-1]:\n            current_group.append(element)\n            \n        \n        else :\n            result.append(current_group)\n            current_group=[element]\n            \n    \n    result.append(current_group)\n    return result\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/808": [{"task_id": "Mbpp/808", "solution": "\ndef check_K (tup, k):\n    return k in tup\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/799": [{"task_id": "Mbpp/799", "solution": "\ndef left_rotate (num, d):\n    mask=(1<<32)-1\n    return ((num<<d)&mask)|(num>>(32-d))\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/764": [{"task_id": "Mbpp/764", "solution": "\ndef number_ctr (s):\n    return len(s) if s.isdigit() else 0\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["program2bedone"]], "plus_fail_tests": [["1 2 3"]]}], "Mbpp/744": [{"task_id": "Mbpp/744", "solution": "\ndef check_none (test_tuple):\n    for i in test_tuple:\n        if i is  None :\n            return  True \n            \n    \n    return  False \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/749": [{"task_id": "Mbpp/749", "solution": "\ndef sort_numeric_strings (input_list):\n    return sorted(input_list, key=lambda x:int(x))\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["4", "12", "45", "7", "0", "100", "200", "-12", "-500"]]], "plus_fail_tests": [[["10000000000", "99999999", "88888888", "7777777", "666666", "-55555", "-4444", "-333", "222", "111", "10", "9", "8", "7", "6", "5", "4", "3", "2", "1"]]]}], "Mbpp/796": [{"task_id": "Mbpp/796", "solution": "\ndef return_sum (d):\n    return sum(d.values())\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/785": [{"task_id": "Mbpp/785", "solution": "\ndef tuple_str_int (s):\n    s=s.strip(\"()\")\n    return tuple(int(x) for x in s.split(\", \"))\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/791": [{"task_id": "Mbpp/791", "solution": "\ndef remove_nested (tup):\n    result=[]\n    for item in tup:\n        if isinstance(item, tuple):\n            result.append(remove_nested(item))\n            \n        \n        else :\n            result.append(item)\n            \n    \n    return tuple(result)\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 5, 7, [4, 6], 10]]], "plus_fail_tests": [[[2, 6, 8, [5, 7], 11, [[2, 9], [6, 3]], 4]]]}], "Mbpp/794": [{"task_id": "Mbpp/794", "solution": "\nimport re\ndef text_starta_endb (text):\n    \"\"\"\n    Matches a string that starts with 'a', followed by anything, and ends with 'b'.\n    \n    :param text: The input string to be matched.\n    :return: A boolean indicating whether the string matches the pattern.\n    \"\"\"\n    pattern=r'^a.*b$'\n    return bool(re.match(pattern, text))\n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["xaabbyz1323ababb"]]}], "Mbpp/805": [{"task_id": "Mbpp/805", "solution": "\ndef max_sum_list (lists):\n    return max(lists, key=sum)\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/797": [{"task_id": "Mbpp/797", "solution": "\ndef sum_in_range (l, r):\n    sum=0\n    for i in range(l, r+1):\n        if i%2!=0:\n            sum+=i\n            \n    \n    return sum\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/453": [{"task_id": "Mbpp/453", "solution": "\ndef sumofFactors (n):\n    sum=0\n    for i in range(2, n+1):\n        if n%i==0 and i%2==0:\n            sum+=i\n            \n    \n    return sum\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/765": [{"task_id": "Mbpp/765", "solution": "\ndef is_polite (n):\n    polite_numbers=[7]\n    last_polite=7\n    for i in range(8, n+1):\n        if i&(i-1)==0:\n            polite_numbers.append(i)\n            last_polite=i\n            \n    \n    return polite_numbers[n]\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7]], "plus_fail_tests": [[10000000]]}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "\ndef find_kth (arr1, arr2, k):\n    i,j=0, 0\n    while  True :\n        if i==len(arr1):\n            return arr2[j+k-1]\n            \n        if j==len(arr2):\n            return arr1[i+k-1]\n            \n        if k==1:\n            return min(arr1[i], arr2[j])\n            \n        mid1=(i+k)//2-1\n        mid2=(j+k)//2-1\n        if arr1[mid1]<=arr2[mid2]:\n            k-=(mid1-i+1)\n            i=mid1+1\n            \n        \n        else :\n            k-=(mid2-j+1)\n            j=mid2+1\n            \n    \n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 3, 6, 7, 9], [1, 4, 8, 10], 5]], "plus_fail_tests": [[[1, 2, 3], [true, true, false], 3]]}], "Mbpp/271": [{"task_id": "Mbpp/271", "solution": "\ndef even_Power_Sum (n):\n    total_sum=0\n    for i in range(1, n+1):\n        total_sum+=(2*i)**5\n        \n    return total_sum\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/255": [{"task_id": "Mbpp/255", "solution": "\nfrom itertools import product\ndef combinations_colors (lst, n):\n    return list(product(lst, repeat=n))\n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Red", "Green", "Blue"], 2]], "plus_fail_tests": [[["A", "B", "C", "D"], 4]]}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "\ndef sum_average (n):\n    total=sum(range(1, n+1))\n    average=total/n\n    return total, average\n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}}