{"date": "2025-06-05 04:09", "hash": "ee43ecabebf20deef4bb776a405ac5b1", "eval": {"Mbpp/4": [{"task_id": "Mbpp/4", "solution": "import heapq \ndef heap_queue_largest ( nums , n ) : \n    return heapq . nlargest ( n , nums ) [ : : - 1 ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[25, 35, 22, 85, 14, 65, 75, 22, 58], 3]], "plus_fail_tests": [[[9, 8, 7, 6, 5, 4, 3, 2, 1], 3]]}], "Mbpp/3": [{"task_id": "Mbpp/3", "solution": "def is_not_prime ( n ) : \n    if n <= 1 : \n        return True \n    \n    for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : \n        if n % i == 0 : \n            return True \n        \n    \n    return False \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/2": [{"task_id": "Mbpp/2", "solution": "def similar_elements ( list1 , list2 ) : \n    return tuple ( set ( list1 ) . intersection ( list2 ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/6": [{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos ( x , y ) : \n    xor_result = x ^ y \n    \n    return ( xor_result & ( xor_result - 1 ) ) == 0 \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0, 0]]}], "Mbpp/7": [{"task_id": "Mbpp/7", "solution": "def find_char_long ( s ) : \n    words = s . split ( ) \n    \n    return [ word for word in words if len ( word ) >= 4 ] \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["This is a very long string with no words that are at least 4 characters long."]]}], "Mbpp/8": [{"task_id": "Mbpp/8", "solution": "def square_nums ( nums ) : \n    return [ num ** 2 for num in nums ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/59": [{"task_id": "Mbpp/59", "solution": "def is_octagonal ( n ) : \n    return n * ( 3 * n - 1 ) // 2 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[100]]}], "Mbpp/56": [{"task_id": "Mbpp/56", "solution": "def check ( num ) : \n    rev_num = int ( str ( num ) [ : : - 1 ] ) \n    \n    return num == 2 * ( rev_num - num ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[73]], "plus_fail_tests": [[0]]}], "Mbpp/9": [{"task_id": "Mbpp/9", "solution": "def find_Rotations ( s ) : \n    rotations = 1 \n    \n    original = s \n    \n    while rotations <= len ( s ) : \n        s = s [ - 1 ] + s [ : - 1 ] \n        \n        if s == original : \n            return rotations \n        \n        rotations += 1 \n    \n    return rotations \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/79": [{"task_id": "Mbpp/79", "solution": "def word_len ( word ) : \n    return len ( word ) % 2 != 0 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/62": [{"task_id": "Mbpp/62", "solution": "def smallest_num ( lst ) : \n    return min ( lst ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/20": [{"task_id": "Mbpp/20", "solution": "def is_woodall ( num ) : \n    woodall_numbers = [ 222 , 333 , 444 , 555 , 666 , 777 , 888 , 999 ] \n    \n    return num in woodall_numbers \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[383]], "plus_fail_tests": [[true]]}], "Mbpp/88": [{"task_id": "Mbpp/88", "solution": "def freq_count ( lst ) : \n    freq = { } \n    \n    for i in lst : \n        if i in freq : \n            freq [ i ] += 1 \n        else : \n            freq [ i ] = 1 \n            \n        \n    \n    return freq \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/72": [{"task_id": "Mbpp/72", "solution": "def dif_Square ( n ) : \n    a = 0 \n    \n    b = int ( n ** 0.5 ) \n    \n    while a <= b : \n        diff = n - ( a * a ) \n        \n        if ( diff + b ) % 2 == 0 : \n            return True \n        \n        a += 1 \n        b = int ( n ** 0.5 ) \n        \n    \n    return False \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[990]]}], "Mbpp/68": [{"task_id": "Mbpp/68", "solution": "def is_Monotonic ( arr ) : \n    increasing = decreasing = True \n    \n    \n    for i in range ( 1 , len ( arr ) ) : \n        if arr [ i ] > arr [ i - 1 ] : \n            decreasing = False \n            \n        \n        if arr [ i ] < arr [ i - 1 ] : \n            increasing = False \n            \n        \n    \n    return increasing or decreasing \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/11": [{"task_id": "Mbpp/11", "solution": "def remove_Occ ( s , char ) : \n    first_occ = s . find ( char ) \n    \n    last_occ = s . rfind ( char ) \n    \n    if first_occ == - 1 or first_occ == last_occ : \n        return s \n    \n    s = s [ : first_occ ] + s [ first_occ + 1 : ] \n    \n    s = s [ : last_occ ] + s [ last_occ + 1 : ] \n    \n    return s \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["hello", "l"]], "plus_fail_tests": [["a", "a"]]}], "Mbpp/12": [{"task_id": "Mbpp/12", "solution": "def sort_matrix ( matrix ) : \n    row_sums = [ sum ( row ) for row in matrix ] \n    \n    sorted_rows = [ row for _ , row in sorted ( zip ( row_sums , matrix ) ) ] \n    \n    return sorted_rows \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/63": [{"task_id": "Mbpp/63", "solution": "def max_difference ( pairs ) : \n    max_diff = 0 \n    \n    for i in range ( len ( pairs ) ) : \n        for j in range ( i + 1 , len ( pairs ) ) : \n            diff = pairs [ j ] [ 0 ] - pairs [ i ] [ 0 ] \n            \n            if diff > max_diff : \n                max_diff = diff \n                \n            \n        \n    \n    return max_diff \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 5], [1, 7], [10, 3], [1, 2]]]], "plus_fail_tests": [[[[1000000, 999999], [10000000, 9999999], [100000000, 99999999], [1000000000, 999999999]]]]}], "Mbpp/19": [{"task_id": "Mbpp/19", "solution": "def test_duplicate ( arr ) : \n    return len ( arr ) != len ( set ( arr ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/14": [{"task_id": "Mbpp/14", "solution": "def find_Volume ( base , height , length ) : \n    return ( 1 / 2 ) * base * height * length \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/17": [{"task_id": "Mbpp/17", "solution": "def square_perimeter ( side_length ) : \n    return side_length * 4 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/64": [{"task_id": "Mbpp/64", "solution": "def subject_marks ( subject_marks ) : \n    return sorted ( subject_marks , key = lambda x : x [ 1 ] ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/80": [{"task_id": "Mbpp/80", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/16": [{"task_id": "Mbpp/16", "solution": "import re \ndef text_lowercase_underscore ( text ) : \n    pattern = r'[a-z]+_[a-z]+' \n    \n    return bool ( re . search ( pattern , text ) ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Aaab_abbbc"]], "plus_fail_tests": [["abc_def_ghi_"]]}], "Mbpp/57": [{"task_id": "Mbpp/57", "solution": "def find_Max_Num ( nums ) : \n    nums . sort ( reverse = True ) \n    result = '' . join ( map ( str , nums ) ) \n    \n    return int ( result ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/74": [{"task_id": "Mbpp/74", "solution": "def is_samepatterns ( patterns , str ) : \n    if len ( patterns ) != len ( str ) : \n        return False \n    \n    pattern_to_str = { } \n    \n    str_to_pattern = { } \n    \n    for p , s in zip ( patterns , str ) : \n        if p not in pattern_to_str : \n            pattern_to_str [ p ] = s \n            \n        \n        if s not in str_to_pattern : \n            str_to_pattern [ s ] = p \n            \n        \n        if pattern_to_str [ p ] != s or str_to_pattern [ s ] != p : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["red", "red", "red", "red", "red", "red"], ["a", "b", "c", "a", "b", "c"]]]}], "Mbpp/75": [{"task_id": "Mbpp/75", "solution": "def find_tuples ( tuples , k ) : \n    return [ t for t in tuples if all ( x % k == 0 for x in t ) ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/77": [{"task_id": "Mbpp/77", "solution": "def is_Diff ( num ) : \n    num_str = str ( num ) \n    \n    remainder = 0 \n    \n    for digit in num_str : \n        remainder = ( remainder * 10 + int ( digit ) ) % 11 \n        \n    \n    return remainder == 0 \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-1212]]}], "Mbpp/85": [{"task_id": "Mbpp/85", "solution": "import math \ndef surfacearea_sphere ( radius ) : \n    return 4 * math . pi * radius ** 2 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/70": [{"task_id": "Mbpp/70", "solution": "def get_equal ( tuples ) : \n    first_tuple_length = len ( tuples [ 0 ] ) \n    \n    for tup in tuples : \n        if len ( tup ) != first_tuple_length : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/58": [{"task_id": "Mbpp/58", "solution": "def opposite_Signs ( a , b ) : \n    return ( a * b ) < 0 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/71": [{"task_id": "Mbpp/71", "solution": "def comb_sort ( arr ) : \n    n = len ( arr ) \n    \n    gap = n \n    \n    swapped = True \n    \n    while gap != 1 or swapped : \n        gap = max ( 1 , gap // 2 ) \n        \n        swapped = False \n        \n        for i in range ( 0 , n - gap , gap ) : \n            if arr [ i ] > arr [ i + gap ] : \n                arr [ i ] , arr [ i + gap ] = arr [ i + gap ] , arr [ i ] \n                \n                swapped = True \n                \n            \n        \n    \n    return arr \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/66": [{"task_id": "Mbpp/66", "solution": "def pos_count ( lst ) : \n    count = 0 \n    \n    for num in lst : \n        if num > 0 : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/102": [{"task_id": "Mbpp/102", "solution": "def snake_to_camel ( snake_str ) : \n    components = snake_str . split ( '_' ) \n    \n    return '' . join ( x . title ( ) for x in components ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["___python_program"]]}], "Mbpp/128": [{"task_id": "Mbpp/128", "solution": "def long_words ( n , words ) : \n    return [ word for word in words if len ( word ) > n ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, "python is a programming language"]], "plus_fail_tests": [[0, "abc  def  ghi  jklm  nopqrs   tuvwxyz"]]}], "Mbpp/100": [{"task_id": "Mbpp/100", "solution": "def next_smallest_palindrome ( num ) : \n    num_str = str ( num ) \n    \n    length = len ( num_str ) \n    \n    if length % 2 == 0 : \n        first_half = num_str [ : length // 2 ] \n        \n        first_half_int = int ( first_half ) \n        \n        first_half_int -= 1 \n        first_half_str = str ( first_half_int ) \n        \n        second_half = first_half_str [ : : - 1 ] \n        \n        result_str = first_half_str + second_half \n        \n    else : \n        first_half = num_str [ : length // 2 ] \n        \n        first_half_int = int ( first_half ) \n        \n        first_half_int -= 1 \n        first_half_str = str ( first_half_int ) \n        \n        second_half = first_half_str [ : : - 1 ] \n        \n        result_str = first_half_str + second_half \n        \n    \n    result_int = int ( result_str ) \n    \n    return result_int \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[99]], "plus_fail_tests": [[0]]}], "Mbpp/90": [{"task_id": "Mbpp/90", "solution": "def len_log ( lst ) : \n    return max ( len ( word ) for word in lst ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/18": [{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars ( str1 , str2 ) : \n    return '' . join ( [ char for char in str1 if char not in str2 ] ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/97": [{"task_id": "Mbpp/97", "solution": "def frequency_lists ( lists ) : \n    frequency_dict = { } \n    \n    for sublist in lists : \n        for item in sublist : \n            if item in frequency_dict : \n                frequency_dict [ item ] += 1 \n            else : \n                frequency_dict [ item ] = 1 \n                \n            \n        \n    \n    return frequency_dict \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/84": [{"task_id": "Mbpp/84", "solution": "def sequence ( n ) : \n    if n == 1 : \n        return 1 \n    elif n == 2 : \n        return 2 \n    else : \n        return sequence ( n - 1 ) + sequence ( n - 2 ) \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[100]]}], "Mbpp/69": [{"task_id": "Mbpp/69", "solution": "def is_sublist ( lst , sub_lst ) : \n    sub_len = len ( sub_lst ) \n    \n    for i in range ( len ( lst ) - sub_len + 1 ) : \n        if lst [ i : i + sub_len ] == sub_lst : \n            return True \n        \n    \n    return False \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/93": [{"task_id": "Mbpp/93", "solution": "def power ( a , b ) : \n    return a ** b \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/91": [{"task_id": "Mbpp/91", "solution": "def find_substring ( lst , substring ) : \n    return any ( substring in s for s in lst ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/92": [{"task_id": "Mbpp/92", "solution": "def is_undulating ( n ) : \n    s = str ( n ) \n    \n    undulating = True \n    \n    for i in range ( 1 , len ( s ) - 1 ) : \n        if s [ i ] > s [ i - 1 ] and s [ i ] > s [ i + 1 ] : \n            continue \n        else : \n            undulating = False \n            \n            break \n        \n    \n    return undulating \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1212121]], "plus_fail_tests": [[2121212121212121]]}], "Mbpp/108": [{"task_id": "Mbpp/108", "solution": "def merge_sorted_list ( list1 , list2 , list3 ) : \n    merged_list = list1 + list2 + list3 \n    \n    merged_list . sort ( ) \n    return merged_list \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/82": [{"task_id": "Mbpp/82", "solution": "import math \ndef volume_sphere ( radius ) : \n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n    \n    Parameters:\n    radius (float): The radius of the sphere.\n    \n    Returns:\n    float: The volume of the sphere.\n    \"\"\" \n    return ( 4 / 3 ) * math . pi * ( radius ** 3 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/86": [{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number ( n ) : \n    return 3 * n * ( n - 1 ) + 1 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/65": [{"task_id": "Mbpp/65", "solution": "def recursive_list_sum ( lst ) : \n    total = 0 \n    \n    for element in lst : \n        if isinstance ( element , list ) : \n            total += recursive_list_sum ( element ) \n        else : \n            total += element \n        \n    \n    return total \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/172": [{"task_id": "Mbpp/172", "solution": "def count_occurance ( s ) : \n    return s . count ( \"std\" ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/118": [{"task_id": "Mbpp/118", "solution": "def string_to_list ( s ) : \n    return s . split ( ' ' ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/126": [{"task_id": "Mbpp/126", "solution": "def sum_common_divisors ( a , b ) : \n    divisors = [ ] \n    \n    for i in range ( 1 , min ( a , b ) + 1 ) : \n        if a % i == 0 and b % i == 0 : \n            divisors . append ( i ) \n        \n    \n    return sum ( divisors ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/94": [{"task_id": "Mbpp/94", "solution": "def index_minimum ( lst ) : \n    return min ( lst , key = lambda x : x [ 1 ] ) [ 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/119": [{"task_id": "Mbpp/119", "solution": "def search ( nums ) : \n    left , right = 0 , len ( nums ) - 1 \n    \n    while left < right : \n        mid = ( left + right ) // 2 \n        \n        if mid % 2 == 1 : \n            mid -= 1 \n        \n        if nums [ mid ] == nums [ mid + 1 ] : \n            left = mid + 2 \n            \n        else : \n            right = mid \n            \n        \n    \n    return nums [ left ] \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/131": [{"task_id": "Mbpp/131", "solution": "def reverse_vowels ( s ) : \n    vowels = \"aeiouAEIOU\" \n    \n    s_list = list ( s ) \n    \n    left , right = 0 , len ( s_list ) - 1 \n    \n    while left < right : \n        while left < right and s_list [ left ] not in vowels : \n            left += 1 \n        \n        while left < right and s_list [ right ] not in vowels : \n            right -= 1 \n        \n        s_list [ left ] , s_list [ right ] = s_list [ right ] , s_list [ left ] \n        \n        left += 1 \n        right -= 1 \n    \n    return \"\" . join ( s_list ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/133": [{"task_id": "Mbpp/133", "solution": "def sum_negativenum ( nums ) : \n    return sum ( num for num in nums if num < 0 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/99": [{"task_id": "Mbpp/99", "solution": "def decimal_to_binary ( n ) : \n    return bin ( n ) . lstrip ( '0b' ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0]]}], "Mbpp/87": [{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three ( dict1 , dict2 , dict3 ) : \n    merged_dict = dict1 . copy ( ) \n    \n    merged_dict . update ( dict2 ) \n    merged_dict . update ( dict3 ) \n    return merged_dict \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/98": [{"task_id": "Mbpp/98", "solution": "def multiply_num ( lst ) : \n    result = 1 \n    \n    for num in lst : \n        result *= num \n    \n    return result / len ( lst ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/67": [{"task_id": "Mbpp/67", "solution": "def bell_number ( n ) : \n    bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] \n    \n    bell [ 0 ] [ 0 ] = 1 \n    \n    for i in range ( 1 , n + 1 ) : \n        bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] \n        \n        for j in range ( 1 , i + 1 ) : \n            bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] \n            \n        \n    \n    return bell [ n ] [ 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/233": [{"task_id": "Mbpp/233", "solution": "def lateralsuface_cylinder ( radius , height ) : \n    base_area = 3.14 * ( radius ** 2 ) \n    \n    lateral_area = 2 * 3.14 * radius \n    \n    total_area = base_area + lateral_area \n    \n    return total_area \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10, 5]], "plus_fail_tests": [[0.5, 5]]}], "Mbpp/165": [{"task_id": "Mbpp/165", "solution": "def count_char_position ( s ) : \n    alphabet = \"abcdefghijklmnopqrstuvwxyz\" \n    \n    count = 0 \n    \n    for i in range ( len ( s ) ) : \n        if s [ i ] . lower ( ) == alphabet [ i ] : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["TheQuickBrownFoxJumpsOverTheLazyDog"]]}], "Mbpp/238": [{"task_id": "Mbpp/238", "solution": "def number_of_substrings ( s ) : \n    return len ( s ) * ( len ( s ) + 1 ) // 2 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/160": [{"task_id": "Mbpp/160", "solution": "def find_solution ( a , b , n ) : \n    if n % b != 0 : \n        return None \n    \n    x = n // b \n    \n    y = ( - a // b ) + 1 \n    \n    return ( x , y ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2, 3, 7]], "plus_fail_tests": [[100, 50, 4000]]}], "Mbpp/95": [{"task_id": "Mbpp/95", "solution": "def Find_Min_Length ( lists ) : \n    return len ( min ( lists , key = len ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/129": [{"task_id": "Mbpp/129", "solution": "def magic_square_test ( matrix ) : \n    n = len ( matrix ) \n    \n    if n != 4 : \n        return False \n    \n    expected_sum = sum ( matrix [ 0 ] ) \n    \n    for row in matrix : \n        if sum ( row ) != expected_sum : \n            return False \n        \n    \n    for col in range ( n ) : \n        if sum ( matrix [ row ] [ col ] for row in range ( n ) ) != expected_sum : \n            return False \n        \n    \n    sum_diagonal1 = sum ( matrix [ i ] [ i ] for i in range ( n ) ) \n    \n    sum_diagonal2 = sum ( matrix [ i ] [ n - i - 1 ] for i in range ( n ) ) \n    \n    if sum_diagonal1 != expected_sum or sum_diagonal2 != expected_sum : \n        return False \n    \n    sum_all = sum ( sum ( row ) for row in matrix ) \n    \n    if sum_all != 4 * expected_sum : \n        return False \n    \n    return True \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[2, 7, 6], [9, 5, 1], [4, 3, 8]]]], "plus_fail_tests": [[[[7, 7], [7, 7]]]]}], "Mbpp/145": [{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff ( arr ) : \n    max_diff = 0 \n    \n    min_element = arr [ 0 ] \n    \n    for i in range ( 1 , len ( arr ) ) : \n        max_diff = max ( max_diff , abs ( arr [ i ] - min_element ) ) \n        \n        min_element = min ( min_element , arr [ i ] ) \n        \n    \n    return max_diff \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[9, 3, 2, 5, 1]]], "plus_fail_tests": [[[9, -3, 2, 0, -5, 1, 11, -7]]]}], "Mbpp/135": [{"task_id": "Mbpp/135", "solution": "def hexagonal_num ( n ) : \n    return n * ( 2 * n - 1 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/168": [{"task_id": "Mbpp/168", "solution": "def frequency ( lst , num ) : \n    return lst . count ( num ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/101": [{"task_id": "Mbpp/101", "solution": "def kth_element ( arr , k ) : \n    return arr [ k - 1 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/113": [{"task_id": "Mbpp/113", "solution": "def check_integer ( s ) : \n    try : \n        int ( s ) \n        return True \n    except ValueError : \n        return False \n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/234": [{"task_id": "Mbpp/234", "solution": "def volume_cube ( side_length ) : \n    return side_length ** 3 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/104": [{"task_id": "Mbpp/104", "solution": "def sort_sublists ( lst ) : \n    return [ sorted ( sublist ) for sublist in lst ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/137": [{"task_id": "Mbpp/137", "solution": "def zero_count ( arr ) : \n    zero = 0 \n    \n    non_zero = 0 \n    \n    for i in arr : \n        if i == 0 : \n            zero += 1 \n        else : \n            non_zero += 1 \n        \n    \n    return zero / non_zero \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}], "Mbpp/125": [{"task_id": "Mbpp/125", "solution": "def find_length ( s ) : \n    max_diff = 0 \n    \n    for i in range ( len ( s ) ) : \n        count_0 = 0 \n        \n        count_1 = 0 \n        \n        for j in range ( i , len ( s ) ) : \n            if s [ j ] == '0' : \n                count_0 += 1 \n            else : \n                count_1 += 1 \n            \n            diff = abs ( count_0 - count_1 ) \n            \n            if diff > max_diff : \n                max_diff = diff \n                \n            \n        \n    \n    return max_diff \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["10111"]], "plus_fail_tests": [["0000000000001111111111111"]]}], "Mbpp/130": [{"task_id": "Mbpp/130", "solution": "def max_occurrences ( lst ) : \n    count_dict = { } \n    \n    for item in lst : \n        if item in count_dict : \n            count_dict [ item ] += 1 \n        else : \n            count_dict [ item ] = 1 \n            \n        \n    \n    max_occ = max ( count_dict . values ( ) ) \n    \n    max_item = [ key for key , value in count_dict . items ( ) if value == max_occ ] \n    \n    return max_item [ 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/132": [{"task_id": "Mbpp/132", "solution": "def tup_string ( tup ) : \n    return '' . join ( tup ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/141": [{"task_id": "Mbpp/141", "solution": "def pancake_sort ( arr ) : \n    n = len ( arr ) \n    \n    for i in range ( n , 1 , - 1 ) : \n        max_idx = arr . index ( max ( arr [ : i ] ) ) \n        \n        if max_idx != i - 1 : \n            if max_idx != 0 : \n                arr = arr [ : max_idx + 1 ] + arr [ max_idx + 1 : ] \n                \n            \n            arr = arr [ : i ] + arr [ i : ] \n            \n        \n    \n    return arr \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[15, 79, 25, 38, 69]]], "plus_fail_tests": [[[54, 28, 91, 12, 78, 37, 66, 42, 84, 59]]]}], "Mbpp/138": [{"task_id": "Mbpp/138", "solution": "def is_Sum_Of_Powers_Of_Two ( n ) : \n    if n == 0 : \n        return False \n    \n    while n > 0 : \n        if n % 2 != 0 : \n            return False \n        \n        n = n // 2 \n        \n    \n    return True \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[-14]]}], "Mbpp/244": [{"task_id": "Mbpp/244", "solution": "def next_Perfect_Square ( n ) : \n    root = n ** 0.5 \n    \n    if int ( root + 0.5 ) ** 2 == n : \n        return ( root + 1 ) ** 2 \n    else : \n        return ( int ( root ) + 1 ) ** 2 \n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/103": [{"task_id": "Mbpp/103", "solution": "def eulerian_num ( n , m ) : \n    if m == 0 : \n        return 1 \n    \n    return ( n - 1 ) * eulerian_num ( n , m - 1 ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 1]], "plus_fail_tests": [[0, 0]]}], "Mbpp/170": [{"task_id": "Mbpp/170", "solution": "def sum_range_list ( lst , start , end ) : \n    return sum ( lst [ start : end + 1 ] ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/61": [{"task_id": "Mbpp/61", "solution": "def count_Substrings ( s ) : \n    count = 0 \n    \n    n = len ( s ) \n    \n    for i in range ( n ) : \n        sum = 0 \n        \n        for j in range ( i , n ) : \n            sum += int ( s [ j ] ) \n            if sum == j - i + 1 : \n                count += 1 \n            \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/224": [{"task_id": "Mbpp/224", "solution": "def count_Set_Bits ( n ) : \n    count = 0 \n    \n    while n : \n        count += n & 1 \n        n >>= 1 \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/120": [{"task_id": "Mbpp/120", "solution": "def max_product_tuple ( tuples_list ) : \n    max_product = 0 \n    \n    for i in range ( len ( tuples_list ) ) : \n        for j in range ( i + 1 , len ( tuples_list ) ) : \n            product = abs ( tuples_list [ i ] [ 0 ] * tuples_list [ j ] [ 0 ] ) \n            \n            if product > max_product : \n                max_product = product \n                \n            \n        \n    \n    return max_product \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[2, 7], [2, 6], [1, 8], [4, 9]]]], "plus_fail_tests": [[[[-10, 20], [15, -2], [-5, 10]]]]}], "Mbpp/239": [{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences ( m , n ) : \n    dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] \n    \n    for i in range ( 1 , m + 1 ) : \n        dp [ i ] [ 1 ] = 1 \n        \n    \n    for j in range ( 1 , n + 1 ) : \n        dp [ 1 ] [ j ] = 1 \n        \n    \n    for i in range ( 2 , m + 1 ) : \n        for j in range ( 2 , n + 1 ) : \n            dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] \n            \n        \n    \n    return dp [ m ] [ n ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10, 4]], "plus_fail_tests": [[100, 10]]}], "Mbpp/111": [{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists ( nested_lists ) : \n    common_elements = set ( ) \n    \n    for sublist in nested_lists : \n        common_elements . update ( set ( sublist ) ) \n    \n    return common_elements \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]]], "plus_fail_tests": [[[[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7], [4, 5, 6, 7, 8]]]]}], "Mbpp/226": [{"task_id": "Mbpp/226", "solution": "def odd_values_string ( s ) : \n    return '' . join ( [ s [ i ] for i in range ( 0 , len ( s ) , 2 ) ] ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/124": [{"task_id": "Mbpp/124", "solution": "import cmath \ndef angle_complex ( x , y ) : \n    return cmath . phase ( complex ( x , y ) ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["0.0", "1j"]], "plus_fail_tests": [["0.0", "1j"]]}], "Mbpp/245": [{"task_id": "Mbpp/245", "solution": "def max_sum ( arr ) : \n    n = len ( arr ) \n    \n    max_sum = 0 \n    \n    max_end_here = [ 0 ] * n \n    \n    max_start_here = [ 0 ] * n \n    \n    for i in range ( n ) : \n        max_end_here [ i ] = arr [ i ] \n        \n    \n    for i in range ( 1 , n ) : \n        for j in range ( i ) : \n            if arr [ i ] > arr [ j ] and max_end_here [ i ] < max_end_here [ j ] + arr [ i ] : \n                max_end_here [ i ] = max_end_here [ j ] + arr [ i ] \n                \n            \n        \n    \n    for i in range ( n - 2 , - 1 , - 1 ) : \n        for j in range ( n - 1 , i , - 1 ) : \n            if arr [ i ] > arr [ j ] and max_start_here [ i ] < max_start_here [ j ] + arr [ i ] : \n                max_start_here [ i ] = max_start_here [ j ] + arr [ i ] \n                \n            \n        \n    \n    for i in range ( n ) : \n        |block-> \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/161": [{"task_id": "Mbpp/161", "solution": "def remove_elements ( lst1 , lst2 ) : \n    return [ i for i in lst1 if i not in lst2 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/223": [{"task_id": "Mbpp/223", "solution": "def is_majority ( arr , n , x ) : \n    left = 0 \n    \n    right = n - 1 \n    \n    while left <= right : \n        mid = ( left + right ) // 2 \n        \n        if arr [ mid ] == x : \n            break \n        elif arr [ mid ] < x : \n            left = mid + 1 \n            \n        else : \n            right = mid - 1 \n            \n        \n    \n    if arr [ mid ] != x : \n        return False \n    \n    left = 0 \n    \n    right = n - 1 \n    \n    while left <= right : \n        mid = ( left + right ) // 2 \n        \n        if arr [ mid ] == x : \n            if mid == n - 1 or arr [ mid ] != arr [ mid + 1 ] : \n                return True \n            else : \n                left = mid + 1 \n                \n            \n        else : \n            right = mid - 1 \n            \n        \n    \n    return False \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, 2, 4, 4, 4, 6, 6], 8, 4]], "plus_fail_tests": [[[], 0, 1]]}], "Mbpp/235": [{"task_id": "Mbpp/235", "solution": "def even_bit_set_number ( n ) : \n    return n | ( n >> 1 ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[999999999]]}], "Mbpp/222": [{"task_id": "Mbpp/222", "solution": "def check_type ( tup ) : \n    first_type = type ( tup [ 0 ] ) \n    \n    return all ( type ( i ) == first_type for i in tup ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/89": [{"task_id": "Mbpp/89", "solution": "def closest_num ( n ) : \n    for i in range ( n - 1 , 0 , - 1 ) : \n        if i < n : \n            return i \n        \n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/139": [{"task_id": "Mbpp/139", "solution": "import math \ndef circle_circumference ( radius ) : \n    return 2 * math . pi * radius \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/116": [{"task_id": "Mbpp/116", "solution": "def tuple_to_int ( tup ) : \n    return int ( '' . join ( map ( str , tup ) ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/230": [{"task_id": "Mbpp/230", "solution": "def replace_blank ( s , char ) : \n    return s . replace ( \" \" , char ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/237": [{"task_id": "Mbpp/237", "solution": "def check_occurences ( lst ) : \n    occurrences = { } \n    \n    for item in lst : \n        if item in occurrences : \n            occurrences [ item ] += 1 \n        else : \n            occurrences [ item ] = 1 \n            \n        \n    \n    return occurrences \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 1], [1, 3], [2, 5], [5, 2], [6, 3]]]], "plus_fail_tests": [[[[2, 2], [1, 3], [2, 2], [3, 1], [1, 3]]]]}], "Mbpp/142": [{"task_id": "Mbpp/142", "solution": "def count_samepair ( list1 , list2 , list3 ) : \n    count = 0 \n    \n    for i in range ( len ( list1 ) ) : \n        if list1 [ i ] == list2 [ i ] == list3 [ i ] : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8]]]}], "Mbpp/167": [{"task_id": "Mbpp/167", "solution": "def next_power_of_2 ( n ) : \n    if n == 0 : \n        return 1 \n    \n    power = 1 \n    \n    while power < n : \n        power *= 2 \n    \n    return power \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/250": [{"task_id": "Mbpp/250", "solution": "def count_X ( tup , element ) : \n    count = 0 \n    \n    for i in tup : \n        if i == element : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/127": [{"task_id": "Mbpp/127", "solution": "def multiply_int ( a , b ) : \n    return a * b \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/166": [{"task_id": "Mbpp/166", "solution": "def find_even_pair ( lst ) : \n    even_count = 0 \n    \n    odd_count = 0 \n    \n    for num in lst : \n        if num % 2 == 0 : \n            even_count += 1 \n        else : \n            odd_count += 1 \n        \n    \n    return even_count * odd_count \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[5, 4, 7, 2, 1]]], "plus_fail_tests": [[[1, 3, 5, 7, 9, 2, 4, 6, 8, 10]]]}], "Mbpp/171": [{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon ( side_length ) : \n    return side_length * 5 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/232": [{"task_id": "Mbpp/232", "solution": "def larg_nnum ( lst , n ) : \n    return sorted ( lst , reverse = True ) [ : n ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/109": [{"task_id": "Mbpp/109", "solution": "def odd_Equivalent ( s , n ) : \n    count = 0 \n    \n    for _ in range ( n ) : \n        s = s [ - 1 : ] + s [ : - 1 ] \n        \n        if int ( s , 2 ) % 2 == 1 : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["10000100110011", 5]]}], "Mbpp/251": [{"task_id": "Mbpp/251", "solution": "def insert_element ( lst , element ) : \n    result = [ ] \n    \n    for item in lst : \n        result . append ( element ) \n        result . append ( item ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/253": [{"task_id": "Mbpp/253", "solution": "def count_integer ( lst ) : \n    return sum ( 1 for i in lst if isinstance ( i , int ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/252": [{"task_id": "Mbpp/252", "solution": "def convert ( num ) : \n    real_part = abs ( num ) \n    \n    imag_part = phase ( num ) \n    \n    return ( real_part , imag_part ) \n\ndef phase ( num ) : \n    import cmath \n    return abs ( cmath . phase ( num ) ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["(2-5j)"]]}], "Mbpp/227": [{"task_id": "Mbpp/227", "solution": "def min_of_three ( a , b , c ) : \n    return min ( a , b , c ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/240": [{"task_id": "Mbpp/240", "solution": "def replace_list ( lst1 , lst2 ) : \n    lst1 [ - 1 ] = lst2 \n    \n    return lst1 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, 5, 7, 9, 10], [2, 4, 6, 8]]], "plus_fail_tests": [[[1, 2, 3, 4], []]]}], "Mbpp/140": [{"task_id": "Mbpp/140", "solution": "def extract_singly ( lists ) : \n    return set ( [ num for sublist in lists for num in sublist ] ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/242": [{"task_id": "Mbpp/242", "solution": "def count_charac ( s ) : \n    return len ( s ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/96": [{"task_id": "Mbpp/96", "solution": "def divisor ( n ) : \n    count = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        if n % i == 0 : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/105": [{"task_id": "Mbpp/105", "solution": "def count ( lst ) : \n    return sum ( 1 for i in lst if i ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/106": [{"task_id": "Mbpp/106", "solution": "def add_lists ( list1 , tuple1 ) : \n    return tuple1 + list1 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[5, 6, 7], [9, 10]]], "plus_fail_tests": [[[], [1, 2, 3]]]}], "Mbpp/247": [{"task_id": "Mbpp/247", "solution": "def lps ( s ) : \n    n = len ( s ) \n    \n    dp = [ [ 0 ] * n for _ in range ( n ) ] \n    \n    for i in range ( n - 1 , - 1 , - 1 ) : \n        dp [ i ] [ i ] = 1 \n        \n        for j in range ( i + 1 , n ) : \n            if s [ i ] == s [ j ] : \n                dp [ i ] [ j ] = dp [ i + 1 ] [ j - 1 ] + 2 \n                \n            else : \n                dp [ i ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j - 1 ] ) \n                \n            \n        \n    \n    return dp [ 0 ] [ n - 1 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/162": [{"task_id": "Mbpp/162", "solution": "def sum_series ( n ) : \n    sum = 0 \n    \n    i = 0 \n    \n    while n >= 2 * i : \n        sum += n - 2 * i \n        i += 1 \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/123": [{"task_id": "Mbpp/123", "solution": "def amicable_numbers_sum ( n ) : \n    amicable_sum = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        sum1 = 0 \n        \n        sum2 = 0 \n        \n        for j in range ( 1 , i ) : \n            if i % j == 0 : \n                sum1 += j \n            \n        \n        for j in range ( 1 , i ) : \n            if i % j == 0 : \n                sum2 += i // j \n            \n        \n        if sum1 == sum2 == i and i != 1 : \n            amicable_sum += i \n        \n    \n    return amicable_sum \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[999]], "plus_fail_tests": [[10000]]}], "Mbpp/269": [{"task_id": "Mbpp/269", "solution": "def ascii_value ( char ) : \n    return ord ( char ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/256": [{"task_id": "Mbpp/256", "solution": "def count_Primes_nums ( n ) : \n    if n <= 2 : \n        return 0 \n    \n    primes = [ True ] * n \n    \n    primes [ 0 ] = primes [ 1 ] = False \n    \n    \n    for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : \n        if primes [ i ] : \n            for j in range ( i * i , n , i ) : \n                primes [ j ] = False \n                \n            \n        \n    \n    return sum ( primes ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/286": [{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated ( arr , k , repeat ) : \n    max_sum = float ( '-inf' ) \n    \n    for i in range ( len ( arr ) ) : \n        current_sum = 0 \n        \n        for j in range ( i , i + repeat * k , k ) : \n            current_sum += arr [ j % len ( arr ) ] \n            max_sum = max ( max_sum , current_sum ) \n            \n        \n    \n    return max_sum \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[10, 20, -30, -1], 4, 3]], "plus_fail_tests": [[[5, -2, 10, 4, -7, 3], 6, 5]]}], "Mbpp/270": [{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index ( lst ) : \n    return sum ( x for i , x in enumerate ( lst ) if i % 2 == 0 and x % 2 == 0 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/267": [{"task_id": "Mbpp/267", "solution": "def square_Sum ( n ) : \n    sum = 0 \n    \n    for i in range ( 1 , 2 * n , 2 ) : \n        sum += i ** 2 \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000.0]]}], "Mbpp/272": [{"task_id": "Mbpp/272", "solution": "def rear_extract ( tuples ) : \n    return [ t [ - 1 ] for t in tuples ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/265": [{"task_id": "Mbpp/265", "solution": "def list_split ( lst , n ) : \n    result = [ ] \n    \n    for i in range ( 0 , len ( lst ) , n ) : \n        result . append ( lst [ i : i + n ] ) \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n"], 3]], "plus_fail_tests": [[[], 1]]}], "Mbpp/261": [{"task_id": "Mbpp/261", "solution": "def division_elements ( tuple1 , tuple2 ) : \n    return tuple ( a / b for a , b in zip ( tuple1 , tuple2 ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/300": [{"task_id": "Mbpp/300", "solution": "from math import comb \ndef count_binary_seq ( n ) : \n    count = 0 \n    \n    for k in range ( n + 1 ) : \n        count += comb ( n , k ) ** 2 \n    \n    return count \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[50]]}], "Mbpp/257": [{"task_id": "Mbpp/257", "solution": "def swap_numbers ( num1 , num2 ) : \n    return ( num2 , num1 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/274": [{"task_id": "Mbpp/274", "solution": "def even_binomial_Coeff_Sum ( n ) : \n    sum = 0 \n    \n    for i in range ( 0 , n + 1 , 2 ) : \n        sum += ( 2 * i + 1 ) * ( 2 * i + 2 ) // 2 - ( i + 1 ) * i \n    \n    return sum \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[4]], "plus_fail_tests": [[10]]}], "Mbpp/312": [{"task_id": "Mbpp/312", "solution": "def volume_cone ( radius , height ) : \n    \"\"\"\n    Calculate the volume of a cone.\n\n    Parameters:\n    radius (float): The radius of the base of the cone.\n    height (float): The height of the cone.\n\n    Returns:\n    float: The volume of the cone.\n    \"\"\" \n    return ( 1 / 3 ) * math . pi * radius ** 2 * height \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 12]], "plus_fail_tests": [[3.5, 8.2]]}], "Mbpp/266": [{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube ( side_length ) : \n    return side_length * 6 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[100]]}], "Mbpp/279": [{"task_id": "Mbpp/279", "solution": "def is_num_decagonal ( n ) : \n    return n * ( 7 * n - 3 ) // 2 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7]], "plus_fail_tests": [[1000000]]}], "Mbpp/392": [{"task_id": "Mbpp/392", "solution": "def get_max_sum ( n ) : \n    dp = [ 0 ] * ( n + 1 ) \n    \n    dp [ 1 ] = 1 \n    \n    for i in range ( 2 , n + 1 ) : \n        dp [ i ] = dp [ i - 1 ] + 1 \n        \n        for j in range ( 1 , 5 ) : \n            if i - j >= 0 : \n                dp [ i ] = max ( dp [ i ] , dp [ i - j ] + 1 ) \n                \n            \n        \n    \n    return dp [ n ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[60]], "plus_fail_tests": [[100]]}], "Mbpp/311": [{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit ( n ) : \n    return n | ( 1 - ( n & ( n - 1 ) ) ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[125]]}], "Mbpp/283": [{"task_id": "Mbpp/283", "solution": "def validate ( num ) : \n    num_str = str ( num ) \n    \n    for digit in num_str : \n        if num_str . count ( digit ) > int ( digit ) : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/285": [{"task_id": "Mbpp/285", "solution": "import re \ndef text_match_two_three ( text ) : \n    pattern = r\"ab{2,3}\" \n    \n    return bool ( re . search ( pattern , text ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/282": [{"task_id": "Mbpp/282", "solution": "def sub_list ( list1 , list2 ) : \n    return [ a - b for a , b in zip ( list1 , list2 ) ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/299": [{"task_id": "Mbpp/299", "solution": "def max_aggregate ( lst ) : \n    max_tuple = max ( lst , key = lambda x : x [ 1 ] ) \n    \n    return max_tuple \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[["Juan Whelan", 90], ["Sabah Colley", 88], ["Peter Nichols", 7], ["Juan Whelan", 122], ["Sabah Colley", 84]]]], "plus_fail_tests": [[[["Alice", 80], ["Bob", 90], ["Charlie", 70], ["Alice", 60], ["Bob", 50], ["Charlie", 40]]]]}], "Mbpp/281": [{"task_id": "Mbpp/281", "solution": "def all_unique ( lst ) : \n    return len ( lst ) == len ( set ( lst ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/297": [{"task_id": "Mbpp/297", "solution": "def flatten_list ( nested_list ) : \n    result = [ ] \n    \n    for item in nested_list : \n        if isinstance ( item , list ) : \n            result . extend ( flatten_list ( item ) ) \n        else : \n            result . append ( item ) \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/280": [{"task_id": "Mbpp/280", "solution": "def sequential_search ( array , element ) : \n    for i in range ( len ( array ) ) : \n        if array [ i ] == element : \n            return ( True , i ) \n        \n    \n    return ( False , - 1 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/437": [{"task_id": "Mbpp/437", "solution": "def remove_odd ( s ) : \n    return '' . join ( [ c for c in s if ord ( c ) % 2 == 0 ] ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python"]], "plus_fail_tests": [["Hello, world!"]]}], "Mbpp/432": [{"task_id": "Mbpp/432", "solution": "def median_trapezium ( a , b , c ) : \n    s = a + b + c \n    \n    mid = s / 2 \n    \n    return ( a + c ) / 2 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[15, 25, 35]], "plus_fail_tests": [[2.3, 4.7, 3.9]]}], "Mbpp/292": [{"task_id": "Mbpp/292", "solution": "def find ( dividend , divisor ) : \n    return dividend // divisor \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/394": [{"task_id": "Mbpp/394", "solution": "def check_distinct ( t ) : \n    return len ( t ) == len ( set ( t ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/422": [{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube ( n ) : \n    sum_of_cubes = sum ( [ i ** 3 for i in range ( 1 , n + 1 ) ] ) \n    \n    return sum_of_cubes / n \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/398": [{"task_id": "Mbpp/398", "solution": "def sum_of_digits ( lst ) : \n    total = 0 \n    \n    for item in lst : \n        if isinstance ( item , int ) : \n            total += sum ( int ( digit ) for digit in str ( abs ( item ) ) ) \n        \n    \n    return total \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 20, 4, 5, "b", 70, "a"]]]], "plus_fail_tests": [[[10, -5, "abc", 0, 3.14]]]}], "Mbpp/405": [{"task_id": "Mbpp/405", "solution": "def check_tuplex ( tuplex , element ) : \n    return element in tuplex \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/293": [{"task_id": "Mbpp/293", "solution": "import math \ndef otherside_rightangle ( a , b ) : \n    return math . sqrt ( a ** 2 + b ** 2 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/262": [{"task_id": "Mbpp/262", "solution": "def split_two_parts ( lst , L ) : \n    return ( lst [ : L ] , lst [ L : ] ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/296": [{"task_id": "Mbpp/296", "solution": "def get_Inv_Count ( arr ) : \n    count = 0 \n    \n    for i in range ( len ( arr ) ) : \n        for j in range ( i + 1 , len ( arr ) ) : \n            if arr [ i ] > arr [ j ] : \n                count += 1 \n            \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/284": [{"task_id": "Mbpp/284", "solution": "def check_element ( lst , element ) : \n    return all ( x == element for x in lst ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/278": [{"task_id": "Mbpp/278", "solution": "def count_first_elements ( tup ) : \n    count = 0 \n    \n    for i in tup : \n        if isinstance ( i , tuple ) : \n            break \n        \n        count += 1 \n    \n    return count \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6]]]}], "Mbpp/309": [{"task_id": "Mbpp/309", "solution": "def maximum ( a , b ) : \n    return a if a > b else b \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/273": [{"task_id": "Mbpp/273", "solution": "def substract_elements ( tuple1 , tuple2 ) : \n    return tuple ( map ( lambda x , y : x - y , tuple1 , tuple2 ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/391": [{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary ( keys , values , value_type ) : \n    result = { } \n    \n    for key , value in zip ( keys , values ) : \n        result [ key ] = { value_type : value } \n        \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["S001", "S002", "S003", "S004"], ["Adina Park", "Leyton Marsh", "Duncan Boyle", "Saim Richards"], [85, 98, 89, 92]]], "plus_fail_tests": [[["abc", "def", "ghi", "jkl"], ["python", "program", "language", "programs"], [{"1": "a", "2": "b"}, {"3": "c"}, 4, ["x", "y", "z"]]]]}], "Mbpp/301": [{"task_id": "Mbpp/301", "solution": "def dict_depth ( d ) : \n    if isinstance ( d , dict ) : \n        return 1 + ( max ( map ( dict_depth , d . values ( ) ) ) if d else 0 ) \n    \n    return 0 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/389": [{"task_id": "Mbpp/389", "solution": "def find_lucas ( n ) : \n    if n == 0 : \n        return 2 \n    \n    if n == 1 : \n        return 1 \n    \n    lucas_n_minus_2 = 2 \n    \n    lucas_n_minus_1 = 1 \n    \n    for _ in range ( 2 , n + 1 ) : \n        lucas_n = lucas_n_minus_1 + lucas_n_minus_2 \n        \n        lucas_n_minus_2 = lucas_n_minus_1 \n        \n        lucas_n_minus_1 = lucas_n \n        \n    \n    return lucas_n \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/397": [{"task_id": "Mbpp/397", "solution": "def median_numbers ( a , b , c ) : \n    if a <= b <= c or c <= b <= a : \n        return float ( b ) \n    elif b <= a <= c or c <= a <= b : \n        return float ( a ) \n    else : \n        return float ( c ) \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/428": [{"task_id": "Mbpp/428", "solution": "def shell_sort ( arr ) : \n    gap = 1 \n    \n    while gap < len ( arr ) // 3 : \n        gap = gap * 3 + 1 \n        \n    \n    while gap > 0 : \n        for i in range ( gap , len ( arr ) ) : \n            temp = arr [ i ] \n            \n            j = i \n            \n            while j >= gap and arr [ j - gap ] > temp : \n                arr [ j ] = arr [ j - gap ] \n                \n                j -= gap \n            \n            arr [ j ] = temp \n            \n        \n        gap //= 3 \n    \n    return arr \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/277": [{"task_id": "Mbpp/277", "solution": "def dict_filter ( d , n ) : \n    return { k : v for k , v in d . items ( ) if v >= n } \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/430": [{"task_id": "Mbpp/430", "solution": "def parabola_directrix ( a , b , c ) : \n    return - ( 2 * a * b ) / ( a ** 2 - 4 * b ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 3, 2]], "plus_fail_tests": [[0, 0, 0]]}], "Mbpp/268": [{"task_id": "Mbpp/268", "solution": "def find_star_num ( n ) : \n    return n * ( n + 1 ) * ( 2 * n + 1 ) // 6 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/306": [{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq ( arr , k , i , n ) : \n    dp = [ 0 ] * ( n + 1 ) \n    \n    dp [ 0 ] = 0 \n    \n    dp [ 1 ] = arr [ 0 ] \n    \n    for j in range ( 2 , n + 1 ) : \n        max_sum = 0 \n        \n        for m in range ( 1 , j ) : \n            if arr [ j - 1 ] > arr [ m - 1 ] : \n                max_sum = max ( max_sum , dp [ m ] ) \n                \n            \n        \n        dp [ j ] = max_sum + arr [ j - 1 ] \n        \n    \n    return dp [ n ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 101, 2, 3, 100, 4, 5], 7, 4, 6]], "plus_fail_tests": [[[5, 2, 4, 1, 3, 6], 6, 1, 3]]}], "Mbpp/310": [{"task_id": "Mbpp/310", "solution": "def string_to_tuple ( string ) : \n    return tuple ( string ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python 3.0"]], "plus_fail_tests": [["hello   world"]]}], "Mbpp/308": [{"task_id": "Mbpp/308", "solution": "def large_product ( list1 , list2 , n ) : \n    result = [ ] \n    \n    for i in list1 : \n        for j in list2 : \n            product = i * j \n            \n            if len ( result ) < n : \n                result . append ( product ) \n            else : \n                result . sort ( reverse = True ) \n                if product > result [ - 1 ] : \n                    result . pop ( ) \n                    result . append ( product ) \n                \n            \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[61.017129591114184, 19.303378474526568, 49.402419273875154, -6.658136072450631, 55.36349167122134, 6.408487552626596, -22.555835342170255, -61.03464372753109, 76.32506038662768, 61.017129591114184], [61.017129591114184, 19.303378474526568, 49.402419273875154, -6.658136072450631, 55.36349167122134, 6.408487552626596, -22.555835342170255, -61.03464372753109, 76.32506038662768, 61.017129591114184], 0]]}], "Mbpp/414": [{"task_id": "Mbpp/414", "solution": "def overlapping ( seq1 , seq2 ) : \n    return any ( val in seq2 for val in seq1 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/276": [{"task_id": "Mbpp/276", "solution": "import math \ndef volume_cylinder ( radius , height ) : \n    return math . pi * radius ** 2 * height \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/426": [{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers ( numbers ) : \n    return [ num for num in numbers if num % 2 != 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/436": [{"task_id": "Mbpp/436", "solution": "def neg_nos ( lst ) : \n    return [ x for x in lst if x < 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/425": [{"task_id": "Mbpp/425", "solution": "def count_element_in_list ( lst , element ) : \n    count = 0 \n    \n    for sublist in lst : \n        if element in sublist : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/418": [{"task_id": "Mbpp/418", "solution": "def Find_Max ( lst ) : \n    return max ( lst , key = len ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/406": [{"task_id": "Mbpp/406", "solution": "def find_Parity ( n ) : \n    return n % 2 != 0 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/390": [{"task_id": "Mbpp/390", "solution": "def add_string ( lst , format_str ) : \n    return [ format_str . format ( i ) for i in lst ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/415": [{"task_id": "Mbpp/415", "solution": "def max_Product ( arr ) : \n    arr . sort ( ) \n    return ( arr [ - 1 ] , arr [ - 2 ] ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 7, 0, 8, 4]]], "plus_fail_tests": [[[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "def digit_distance_nums ( a , b ) : \n    return sum ( abs ( int ( digit_a ) - int ( digit_b ) ) for digit_a , digit_b in zip ( str ( a ) , str ( b ) ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/457": [{"task_id": "Mbpp/457", "solution": "def Find_Min ( lst ) : \n    return min ( lst , key = len ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/420": [{"task_id": "Mbpp/420", "solution": "def cube_Sum ( n ) : \n    sm = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        sm += ( 2 * i ) ** 3 \n    \n    return sm \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/433": [{"task_id": "Mbpp/433", "solution": "def check_greater ( arr , num ) : \n    return all ( x > num for x in arr ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 3, 4, 5, 6], 8]], "plus_fail_tests": [[[1, 2, 3, 4, 5], 6]]}], "Mbpp/388": [{"task_id": "Mbpp/388", "solution": "def highest_Power_of_2 ( n ) : \n    power = 1 \n    \n    while power * 2 <= n : \n        power *= 2 \n    \n    return power \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/429": [{"task_id": "Mbpp/429", "solution": "def and_tuples ( tuple1 , tuple2 ) : \n    result = [ ] \n    \n    for a , b in zip ( tuple1 , tuple2 ) : \n        result . append ( a & b ) \n    \n    return tuple ( result ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/412": [{"task_id": "Mbpp/412", "solution": "def remove_odd ( lst ) : \n    return [ x for x in lst if x % 2 == 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/419": [{"task_id": "Mbpp/419", "solution": "def round_and_sum ( numbers ) : \n    total_sum = sum ( numbers ) \n    \n    rounded_sum = round ( total_sum ) \n    \n    result = rounded_sum * len ( numbers ) \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[22.4, 4.0, -16.22, -9.1, 11.0, -12.22, 14.2, -5.2, 17.5]]], "plus_fail_tests": [[[1234.56789, 9876.54321, -1111.22222, -3333.44444]]]}], "Mbpp/305": [{"task_id": "Mbpp/305", "solution": "def start_withp ( words ) : \n    p_words = [ ] \n    \n    for word in words : \n        if word . startswith ( 'p' ) : \n            p_words . append ( word ) \n        \n    \n    return ( p_words [ 0 ] , p_words [ 1 ] ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python PHP", "Java JavaScript", "c c++"]]], "plus_fail_tests": [[["Python Programming", "Java Programming", "Perl Programming", "Ruby Programming", "PHP Programming", "C Programming"]]]}], "Mbpp/435": [{"task_id": "Mbpp/435", "solution": "def last_Digit ( n ) : \n    return n % 10 \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-987]]}], "Mbpp/447": [{"task_id": "Mbpp/447", "solution": "def cube_nums ( nums ) : \n    return [ num ** 3 for num in nums ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/424": [{"task_id": "Mbpp/424", "solution": "def extract_rear ( s ) : \n    return [ x [ - 1 ] for x in s ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/395": [{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character ( s ) : \n    char_count = { } \n    \n    for char in s : \n        if char in char_count : \n            char_count [ char ] += 1 \n        else : \n            char_count [ char ] = 1 \n            \n        \n    \n    for char in s : \n        if char_count [ char ] == 1 : \n            return char \n        \n    \n    return None \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/404": [{"task_id": "Mbpp/404", "solution": "def minimum ( a , b ) : \n    return a if a < b else b \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/470": [{"task_id": "Mbpp/470", "solution": "def add_pairwise ( tup ) : \n    return tuple ( map ( lambda x , y : x + y , tup [ : - 1 ] , tup [ 1 : ] ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "def difference ( n ) : \n    sum_of_first_n = n * ( n + 1 ) // 2 \n    \n    sum_of_cubes_of_first_n = n * ( n + 1 ) * ( 2 * n + 1 ) // 6 \n    \n    return sum_of_cubes_of_first_n - sum_of_first_n \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[10]]}], "Mbpp/294": [{"task_id": "Mbpp/294", "solution": "def max_val ( list ) : \n    return max ( list ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python", 3, 2, 4, 5, "version"]]], "plus_fail_tests": [[[1, "2", true, 3.14, ["a", "b"], [5, 6, 7], {"8": "eight", "9": "nine"}, "Python", 10, 11, 12]]]}], "Mbpp/451": [{"task_id": "Mbpp/451", "solution": "def remove_whitespaces ( s ) : \n    return s . replace ( ' ' , '' ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/439": [{"task_id": "Mbpp/439", "solution": "def multiple_to_single ( numbers ) : \n    result = \"\" \n    \n    for num in numbers : \n        result += str ( num ) \n    \n    return int ( result ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/259": [{"task_id": "Mbpp/259", "solution": "def maximize_elements ( tup1 , tup2 ) : \n    result = [ ] \n    \n    max_len = max ( len ( tup1 ) , len ( tup2 ) ) \n    \n    for i in range ( max_len ) : \n        if i < len ( tup1 ) and i < len ( tup2 ) : \n            result . append ( max ( tup1 [ i ] , tup2 [ i ] , key = lambda x : x [ 1 ] ) ) \n        elif i < len ( tup1 ) : \n            result . append ( tup1 [ i ] ) \n        else : \n            result . append ( tup2 [ i ] ) \n        \n    \n    return tuple ( result ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]]], "plus_fail_tests": [[[[1, 2], [5, 6], [7, 8], [3, 8]], [[1, 2], [4, 6], [7, 8], [7, 8]]]]}], "Mbpp/290": [{"task_id": "Mbpp/290", "solution": "def max_length ( lists ) : \n    max_len = 0 \n    \n    max_list = [ ] \n    \n    for lst in lists : \n        if len ( lst ) > max_len : \n            max_len = len ( lst ) \n            \n            max_list = lst \n            \n        \n    \n    return max_len , max_list \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/409": [{"task_id": "Mbpp/409", "solution": "def min_product_tuple ( tuples_list ) : \n    products = [ x * y for x , y in tuples_list ] \n    \n    return min ( products ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/421": [{"task_id": "Mbpp/421", "solution": "def concatenate_tuple ( tup ) : \n    return '-' . join ( map ( str , tup ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/441": [{"task_id": "Mbpp/441", "solution": "def surfacearea_cube ( size ) : \n    return 6 * size * size \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/440": [{"task_id": "Mbpp/440", "solution": "import re \ndef find_adverb_position ( sentence ) : \n    words = re . finditer ( r'\\b\\w+\\b' , sentence ) \n    \n    adverbs = [ ( match . group ( ) , match . start ( ) ) for match in words if re . match ( r'\\b(?:a|an|the|at|by|for|in|of|on|or|per|the|to|with|without)\\b\\w+\\b' , match . group ( ) ) ] \n    \n    if not adverbs : \n        return None \n    \n    return adverbs [ 0 ] [ 1 ] , adverbs [ 0 ] [ 2 ] , adverbs [ 0 ] [ 0 ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["clearly!! we can see the sky"]], "plus_fail_tests": [["heavily and quickly we ran down the steep hill"]]}], "Mbpp/446": [{"task_id": "Mbpp/446", "solution": "def count_Occurrence ( lst , tpl ) : \n    count = 0 \n    \n    for i in tpl : \n        count += lst . count ( i ) \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/427": [{"task_id": "Mbpp/427", "solution": "def change_date_format ( date ) : \n    return date . replace ( \"-\" , \"-\" ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["2026-01-02"]], "plus_fail_tests": [["2021-1-026"]]}], "Mbpp/472": [{"task_id": "Mbpp/472", "solution": "def check_Consecutive ( nums ) : \n    nums . sort ( ) \n    return all ( nums [ i ] + 1 == nums [ i + 1 ] for i in range ( len ( nums ) - 1 ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/458": [{"task_id": "Mbpp/458", "solution": "def rectangle_area ( length , width ) : \n    return length * width \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum ( nums , k ) : \n    max_sum = float ( '-inf' ) \n    \n    current_sum = 0 \n    \n    for i in range ( len ( nums ) ) : \n        current_sum = max ( nums [ i ] , current_sum + nums [ i ] ) \n        \n        max_sum = max ( max_sum , current_sum ) \n        \n    \n    return max_sum if max_sum >= k else k \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-2, -3, 4, -1, -2, 1, 5, -3], 8]], "plus_fail_tests": [[[-10, -5, -3, -2, -1], 5]]}], "Mbpp/456": [{"task_id": "Mbpp/456", "solution": "def reverse_string_list ( string_list ) : \n    return [ s [ : : - 1 ] for s in string_list ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/445": [{"task_id": "Mbpp/445", "solution": "def index_multiplication ( test_tup1 , test_tup2 ) : \n    res = tuple ( tuple ( a * b for a , b in zip ( tup1 , tup2 ) ) for tup1 , tup2 in zip ( test_tup1 , test_tup2 ) ) \n    \n    return ( res ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/413": [{"task_id": "Mbpp/413", "solution": "def extract_nth_element ( lst , n ) : \n    return [ tup [ n ] for tup in lst ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/455": [{"task_id": "Mbpp/455", "solution": "def check_monthnumb_number ( month_number ) : \n    thirty_one_days_months = [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] \n    \n    return month_number in thirty_one_days_months \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/410": [{"task_id": "Mbpp/410", "solution": "def min_val ( listval ) : \n    return min ( [ i for i in listval if isinstance ( i , int ) ] ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/478": [{"task_id": "Mbpp/478", "solution": "def remove_lowercase ( s ) : \n    result = [ ] \n    \n    for char in s : \n        if not char . islower ( ) : \n            result . append ( char ) \n        \n    \n    return '' . join ( result ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/475": [{"task_id": "Mbpp/475", "solution": "def sort_counter ( dict ) : \n    return sorted ( dict . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "def sort_sublists ( lst ) : \n    return [ sorted ( sublist ) for sublist in lst ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "def two_unique_nums ( nums ) : \n    unique_nums = [ ] \n    \n    for num in nums : \n        if num not in unique_nums : \n            unique_nums . append ( num ) \n        \n    \n    return unique_nums \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 2, 3, 4, 5]]], "plus_fail_tests": [[[1, 2, 3, 2, 4, 5, 3, 6, 4, 7, 8, 9, 5, 6]]]}], "Mbpp/460": [{"task_id": "Mbpp/460", "solution": "def Extract ( lst ) : \n    return [ sublst [ 0 ] for sublst in lst ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "def split ( string ) : \n    return list ( string ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/459": [{"task_id": "Mbpp/459", "solution": "def remove_uppercase ( s ) : \n    result = \"\" \n    \n    upper_flag = False \n    \n    for char in s : \n        if char . isupper ( ) : \n            if not upper_flag : \n                result += char \n                upper_flag = True \n                \n            \n        else : \n            result += char \n            upper_flag = False \n            \n        \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["cAstyoUrFavoRitETVshoWs"]], "plus_fail_tests": [["ABCDEFG"]]}], "Mbpp/450": [{"task_id": "Mbpp/450", "solution": "def extract_string ( lst , size ) : \n    return lst [ - size : ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python", "list", "exercises", "practice", "solution"], 8]], "plus_fail_tests": [[["abcdef", "xyz", "pqr", "lmnop", "abcde"], 5]]}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "def Split ( lst ) : \n    return [ i for i in lst if i % 2 != 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/474": [{"task_id": "Mbpp/474", "solution": "def replace_char ( s , old , new ) : \n    return s . replace ( old , new ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/468": [{"task_id": "Mbpp/468", "solution": "def max_product ( nums ) : \n    max_product_so_far = nums [ 0 ] \n    \n    max_product_up_to_second_element = nums [ 0 ] \n    \n    for i in range ( 1 , len ( nums ) ) : \n        max_product_up_to_current_element = max ( nums [ i ] , max_product_up_to_second_element * nums [ i ] ) \n        \n        max_product_so_far = max ( max_product_so_far , max_product_up_to_current_element ) \n        \n        max_product_up_to_second_element = max_product_up_to_current_element \n        \n    \n    return max_product_so_far \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 100, 4, 5, 150, 6]]], "plus_fail_tests": [[[3, -5, 2, 6, -1, 4, -3]]]}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "def issort_list ( lst ) : \n    \"\"\"\n    Check whether a specified list is sorted or not.\n    \"\"\" \n    return all ( lst [ i ] <= lst [ i + 1 ] for i in range ( len ( lst ) - 1 ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/479": [{"task_id": "Mbpp/479", "solution": "def first_Digit ( n ) : \n    while n >= 10 : \n        n = n // 10 \n        \n    \n    return n \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "def extract_values ( s ) : \n    values = [ ] \n    \n    start = - 1 \n    \n    for i , char in enumerate ( s ) : \n        if char == '\"' : \n            if start == - 1 : \n                start = i + 1 \n                \n            else : \n                values . append ( s [ start : i ] ) \n                start = - 1 \n                \n            \n        \n    \n    return values \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "def toggle_string ( s ) : \n    return '' . join ( [ i . lower ( ) if i . isupper ( ) else i . upper ( ) for i in s ] ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/463": [{"task_id": "Mbpp/463", "solution": "def max_subarray_product ( nums ) : \n    if not nums : \n        return 0 \n    \n    max_product = min_product = result = nums [ 0 ] \n    \n    \n    \n    for i in range ( 1 , len ( nums ) ) : \n        if nums [ i ] < 0 : \n            max_product , min_product = min_product , max_product \n            \n        \n        max_product = max ( nums [ i ] , max_product * nums [ i ] ) \n        \n        min_product = min ( nums [ i ] , min_product * nums [ i ] ) \n        \n        result = max ( result , max_product ) \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/476": [{"task_id": "Mbpp/476", "solution": "def big_sum ( arr ) : \n    return max ( arr ) + min ( arr ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/454": [{"task_id": "Mbpp/454", "solution": "import re \ndef text_match_wordz ( text ) : \n    patterns = '.*z.*' \n    \n    if re . search ( patterns , text ) : \n        return True \n    else : \n        return False \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/448": [{"task_id": "Mbpp/448", "solution": "def cal_sum ( n ) : \n    perrin_cache = { 1 : 3 , 2 : 2 , 3 : 5 , 4 : 2 } \n    \n    def perrin ( n ) : \n        if n not in perrin_cache : \n            perrin_cache [ n ] = perrin ( n - 1 ) + perrin ( n - 2 ) - perrin ( n - 3 ) \n            \n        \n        return perrin_cache [ n ] \n    \n    return sum ( [ perrin ( i ) for i in range ( 1 , n + 1 ) ] ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9]], "plus_fail_tests": [[-5]]}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "def count_Pairs ( arr , n ) : \n    count = 0 \n    \n    for i in range ( n ) : \n        for j in range ( i + 1 , n ) : \n            if arr [ i ] != arr [ j ] : \n                count += 1 \n            \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/471": [{"task_id": "Mbpp/471", "solution": "def find_remainder ( arr , n ) : \n    result = 1 \n    \n    for num in arr : \n        result = ( result * num ) % n \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/473": [{"task_id": "Mbpp/473", "solution": "def tuple_intersection ( test_list1 , test_list2 ) : \n    res = set ( ) \n    \n    for i in test_list1 : \n        for j in test_list2 : \n            if tuple ( sorted ( i ) ) == tuple ( sorted ( j ) ) : \n                res . add ( j ) \n            \n        \n    \n    return res \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 4], [5, 6], [9, 10], [4, 5]], [[5, 4], [3, 4], [6, 5], [9, 11]]]], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], [[2, 3, 1], [6, 5, 4], [11, 12, 10]]]]}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "def union_elements ( tuple1 , tuple2 ) : \n    union_set = set ( tuple1 ) . union ( tuple2 ) \n    \n    return tuple ( sorted ( union_set ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "def empty_list ( N ) : \n    return [ { } for _ in range ( N ) ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair ( arr , x ) : \n    count = 0 \n    \n    for i in range ( len ( arr ) ) : \n        for j in range ( i + 1 , len ( arr ) ) : \n            if ( arr [ i ] ^ arr [ j ] ) % 2 != 0 : \n                count += 1 \n            \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 2], 10]]}], "Mbpp/477": [{"task_id": "Mbpp/477", "solution": "def is_lower ( s ) : \n    return s . lower ( ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/465": [{"task_id": "Mbpp/465", "solution": "def drop_empty ( d ) : \n    return { k : v for k , v in d . items ( ) if v is not None } \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "def Find_Max_Length ( lst ) : \n    return max ( len ( sublist ) for sublist in lst ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/287": [{"task_id": "Mbpp/287", "solution": "def square_Sum ( n ) : \n    sum = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        sum += ( 2 * i ) ** 2 \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000]]}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "def sum_digits ( n ) : \n    \"\"\"\n    Calculate the sum of the digits of a non-negative integer.\n\n    Args:\n        n (int): The non-negative integer whose digits are to be summed.\n\n    Returns:\n        int: The sum of the digits of the integer.\n    \"\"\" \n    sum_digits = 0 \n    \n    while n > 0 : \n        sum_digits += n % 10 \n        n //= 10 \n    \n    return sum_digits \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "def is_Sub_Array ( sub , main ) : \n    sub_len = len ( sub ) \n    \n    main_len = len ( main ) \n    \n    if sub_len == 0 : \n        return True \n    \n    if main_len < sub_len : \n        return False \n    \n    for i in range ( main_len - sub_len + 1 ) : \n        if main [ i : i + sub_len ] == sub : \n            return True \n        \n    \n    return False \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], [1, 2, 3]]]}], "Mbpp/462": [{"task_id": "Mbpp/462", "solution": "from itertools import combinations \ndef combinations_list ( lst ) : \n    result = [ ] \n    \n    for i in range ( len ( lst ) + 1 ) : \n        for combination in combinations ( lst , i ) : \n            result . append ( list ( combination ) ) \n        \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["orange", "red", "green", "blue"]]], "plus_fail_tests": [[["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]]]}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "def extract_even ( t ) : \n    result = [ ] \n    \n    for i in t : \n        if isinstance ( i , tuple ) : \n            result . append ( extract_even ( i ) ) \n        elif i % 2 == 0 : \n            result . append ( i ) \n        \n    \n    return tuple ( result ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "def unique_product ( nums ) : \n    unique_nums = set ( nums ) \n    \n    product = 1 \n    \n    for num in unique_nums : \n        product *= num \n    \n    return product \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "def catalan_number ( n ) : \n    if n <= 1 : \n        return 1 \n    \n    catalan = [ 0 for i in range ( n + 1 ) ] \n    \n    catalan [ 0 ] = 1 \n    \n    catalan [ 1 ] = 1 \n    \n    for i in range ( 2 , n + 1 ) : \n        catalan [ i ] = 0 \n        \n        for j in range ( i ) : \n            catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] \n        \n    \n    return catalan [ n ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "def last_Digit_Factorial ( n ) : \n    factorial = 1 \n    \n    for i in range ( 1 , n + 1 ) : \n        factorial *= i \n    \n    return factorial % 10 \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2.5]]}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "def surface_Area ( edge , height ) : \n    base_area = ( 1 / 2 ) * edge * edge \n    \n    side_area = edge * height * 2 \n    \n    return base_area + side_area \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4]], "plus_fail_tests": [[10, 20]]}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "def interleave_lists ( list1 , list2 , list3 ) : \n    result = [ ] \n    \n    for i in range ( len ( list1 ) ) : \n        result . append ( list1 [ i ] ) \n        result . append ( list2 [ i ] ) \n        result . append ( list3 [ i ] ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "def removezero_ip ( ip ) : \n    return ip . lstrip ( '0' ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["216.08.094.196"]], "plus_fail_tests": [["0.0.0.0"]]}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "def split_Arr ( arr , n ) : \n    return arr [ : n ] + arr [ n : ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[12, 10, 5, 6, 52, 36], 2]], "plus_fail_tests": [[["apple", "banana", "cherry", "date"], 2]]}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "def list_tuple ( lst ) : \n    return tuple ( lst ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "def expensive_items ( items , n ) : \n    sorted_items = sorted ( items , key = lambda x : x [ 'price' ] , reverse = True ) \n    \n    return sorted_items [ : n ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "def perfect_squares ( start , end ) : \n    squares = [ ] \n    \n    for i in range ( start , end + 1 ) : \n        if int ( i ** 0.5 ) ** 2 == i : \n            squares . append ( i ) \n        \n    \n    return squares \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-10, -1]]}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "import cmath \ndef polar_rect ( r , theta ) : \n    rect_coordinates = ( r * cmath . cos ( theta ) , r * cmath . sin ( theta ) ) \n    \n    return rect_coordinates \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4]], "plus_fail_tests": [[0, 0]]}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "def find_kth ( arr1 , arr2 , k ) : \n    i , j = 0 , 0 \n    \n    while True : \n        if i == len ( arr1 ) : \n            return arr2 [ j + k - 1 ] \n        \n        if j == len ( arr2 ) : \n            return arr1 [ i + k - 1 ] \n        \n        if k == 1 : \n            return min ( arr1 [ i ] , arr2 [ j ] ) \n        \n        new_i = min ( i + k // 2 , len ( arr1 ) ) \n        \n        new_j = min ( j + k // 2 , len ( arr2 ) ) \n        \n        if arr1 [ new_i - 1 ] < arr2 [ new_j - 1 ] : \n            k -= ( new_i - i + 1 ) \n            i = new_i \n            \n        else : \n            k -= ( new_j - j + 1 ) \n            j = new_j \n            \n        \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 3, 6, 7, 9], [1, 4, 8, 10], 5]], "plus_fail_tests": [[[1, 2, 3, 1], [], 3]]}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "def find_dissimilar ( tuple1 , tuple2 ) : \n    return tuple ( set ( tuple1 ) ^ set ( tuple2 ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "def armstrong_number ( num ) : \n    num_str = str ( num ) \n    \n    num_digits = len ( num_str ) \n    \n    sum_of_powers = sum ( [ int ( digit ) ** num_digits for digit in num_str ] ) \n    \n    return sum_of_powers == num \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "def diff_even_odd ( lst ) : \n    even = odd = None \n    \n    \n    for num in lst : \n        if even is None and num % 2 == 0 : \n            even = num \n            \n        elif odd is None and num % 2 != 0 : \n            odd = num \n            \n        \n        if even is not None and odd is not None : \n            break \n        \n    \n    return even - odd \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "def swap_List ( lst ) : \n    if len ( lst ) > 1 : \n        lst [ 0 ] , lst [ - 1 ] = lst [ - 1 ] , lst [ 0 ] \n        \n    \n    return lst \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "import sys \ndef tuple_size ( t ) : \n    return sys . getsizeof ( t ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/604": [{"task_id": "Mbpp/604", "solution": "def reverse_words ( sentence ) : \n    words = sentence . split ( \" \" ) \n    \n    reversed_words = \" \" . join ( reversed ( words ) ) \n    \n    return reversed_words \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[" "]]}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "def big_diff ( lst ) : \n    return max ( lst ) - min ( lst ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "def sum_Of_product ( n ) : \n    result = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        result += ( 2 * i - 1 ) * i * result \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[10]]}], "Mbpp/611": [{"task_id": "Mbpp/611", "solution": "def max_of_nth ( matrix , n ) : \n    return max ( [ row [ n ] for row in matrix ] ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/603": [{"task_id": "Mbpp/603", "solution": "def get_ludic ( n ) : \n    lucids = [ 1 ] \n    \n    i = 2 \n    \n    while i * i <= n : \n        if i % 2 != 0 and i % 3 != 0 : \n            lucids . append ( i ) \n        \n        i += 1 \n    \n    return lucids \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[100]]}], "Mbpp/605": [{"task_id": "Mbpp/605", "solution": "def prime_num ( n ) : \n    if n <= 1 : \n        return False \n    \n    if n <= 3 : \n        return True \n    \n    if n % 2 == 0 or n % 3 == 0 : \n        return False \n    \n    i = 5 \n    \n    while i * i <= n : \n        if n % i == 0 or n % ( i + 2 ) == 0 : \n            return False \n        \n        i += 6 \n    \n    return True \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/616": [{"task_id": "Mbpp/616", "solution": "def tuple_modulo ( t1 , t2 ) : \n    return tuple ( a % b for a , b in zip ( t1 , t2 ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/626": [{"task_id": "Mbpp/626", "solution": "def triangle_area ( radius ) : \n    if radius < 0 : \n        return None \n    else : \n        return radius * radius \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "def is_Even ( n ) : \n    return n % 2 == 0 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/615": [{"task_id": "Mbpp/615", "solution": "def average_tuple ( tuples ) : \n    return [ sum ( t ) / len ( t ) for t in tuples ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]]], "plus_fail_tests": [[[[7, 8, 9], [-2, -4, -6], [0, 20, 30]]]]}], "Mbpp/607": [{"task_id": "Mbpp/607", "solution": "import re \ndef find_literals ( text , pattern ) : \n    match = re . search ( pattern , text ) \n    \n    if match : \n        return match . group ( ) , match . start ( ) , match . end ( ) \n    else : \n        return None , None , None \n    \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["", "rfvPtELLC"]]}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "def sum_average ( n ) : \n    sum_of_numbers = n * ( n + 1 ) // 2 \n    \n    average = sum_of_numbers / n \n    \n    return sum_of_numbers , average \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/619": [{"task_id": "Mbpp/619", "solution": "def move_num ( s ) : \n    num_list = [ ] \n    \n    alpha_list = [ ] \n    \n    for char in s : \n        if char . isdigit ( ) : \n            num_list . append ( char ) \n        else : \n            alpha_list . append ( char ) \n        \n    \n    result = '' . join ( alpha_list ) + '' . join ( num_list ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/610": [{"task_id": "Mbpp/610", "solution": "def remove_kth_element ( lst , k ) : \n    return lst [ : k ] + lst [ k + 1 : ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, 2, 3, 4, 4, 5, 1], 3]], "plus_fail_tests": [[[1, 2, 3, 4, 5], 1]]}], "Mbpp/614": [{"task_id": "Mbpp/614", "solution": "def cummulative_sum ( tuple_list ) : \n    total = 0 \n    \n    result = [ ] \n    \n    for tup in tuple_list : \n        total += sum ( tup ) \n        result . append ( total ) \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 3], [5, 6, 7], [2, 6]]]], "plus_fail_tests": [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]]}], "Mbpp/618": [{"task_id": "Mbpp/618", "solution": "def div_list ( list1 , list2 ) : \n    return [ a / b for a , b in zip ( list1 , list2 ) ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/612": [{"task_id": "Mbpp/612", "solution": "def merge ( lst ) : \n    first = [ ] \n    \n    second = [ ] \n    \n    for sublist in lst : \n        first . extend ( sublist [ 0 ] ) \n        second . extend ( sublist [ 1 ] ) \n    \n    return [ first , second ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2], [3, 4], [5, 6], [7, 8]]]], "plus_fail_tests": [[[["x", 1], ["y", 2], [true, "z"]]]]}], "Mbpp/622": [{"task_id": "Mbpp/622", "solution": "def get_median ( list1 , list2 , k ) : \n    merged_list = [ ] \n    \n    i , j = 0 , 0 \n    \n    while i < len ( list1 ) and j < len ( list2 ) : \n        if list1 [ i ] < list2 [ j ] : \n            merged_list . append ( list1 [ i ] ) \n            i += 1 \n        else : \n            merged_list . append ( list2 [ j ] ) \n            j += 1 \n        \n    \n    while i < len ( list1 ) : \n        merged_list . append ( list1 [ i ] ) \n        i += 1 \n    \n    while j < len ( list2 ) : \n        merged_list . append ( list2 [ j ] ) \n        j += 1 \n    \n    return merged_list [ k - 1 ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5]], "plus_fail_tests": [[[1, 4, 7, 10, 13, 16, 19, 22, 25, 28], [2, 5, 8, 11, 14, 17, 20, 23, 26, 29], 10]]}], "Mbpp/606": [{"task_id": "Mbpp/606", "solution": "import math \ndef radian_degree ( degree ) : \n    return degree * ( math . pi / 180 ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/628": [{"task_id": "Mbpp/628", "solution": "def replace_spaces ( s ) : \n    return s . replace ( \" \" , \"%20\" ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/602": [{"task_id": "Mbpp/602", "solution": "def first_repeated_char ( s ) : \n    char_count = { } \n    \n    for char in s : \n        if char in char_count : \n            return char \n        \n        char_count [ char ] = 1 \n        \n    \n    return None \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/624": [{"task_id": "Mbpp/624", "solution": "def is_upper ( s ) : \n    return s . upper ( ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/608": [{"task_id": "Mbpp/608", "solution": "def bell_Number ( n ) : \n    bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] \n    \n    bell [ 0 ] [ 0 ] = 1 \n    \n    for i in range ( 1 , n + 1 ) : \n        bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] \n        \n        for j in range ( 1 , i + 1 ) : \n            bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] \n            \n        \n    \n    return bell [ n ] [ 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/623": [{"task_id": "Mbpp/623", "solution": "def nth_nums ( nums , power ) : \n    return [ num ** power for num in nums ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/620": [{"task_id": "Mbpp/620", "solution": "def largest_subset ( nums ) : \n    nums . sort ( ) \n    n = len ( nums ) \n    \n    dp = [ 1 ] * n \n    \n    for i in range ( 1 , n ) : \n        for j in range ( i ) : \n            if nums [ i ] % nums [ j ] == 0 : \n                dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) \n                \n            \n        \n    \n    return max ( dp ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[9, 3, 12, 7, 16, 3, 11, 8, 4, 13, 13]]]}], "Mbpp/629": [{"task_id": "Mbpp/629", "solution": "def Split ( lst ) : \n    return [ i for i in lst if i % 2 == 0 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/632": [{"task_id": "Mbpp/632", "solution": "def move_zero ( arr ) : \n    count = 0 \n    \n    for i in range ( len ( arr ) ) : \n        if arr [ i ] != 0 : \n            arr [ count ] = arr [ i ] \n            \n            count += 1 \n        \n    \n    for i in range ( count , len ( arr ) ) : \n        arr [ i ] = 0 \n        \n    \n    return arr \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/637": [{"task_id": "Mbpp/637", "solution": "def noprofit_noloss ( profit , loss ) : \n    return profit != loss \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1500, 1200]], "plus_fail_tests": [[-2000, -5000]]}], "Mbpp/635": [{"task_id": "Mbpp/635", "solution": "def heap_sort ( arr ) : \n    def heapify ( arr , n , i ) : \n        largest = i \n        \n        l = 2 * i + 1 \n        \n        r = 2 * i + 2 \n        \n        if l < n and arr [ i ] < arr [ l ] : \n            largest = l \n            \n        \n        if r < n and arr [ largest ] < arr [ r ] : \n            largest = r \n            \n        \n        if largest != i : \n            arr [ i ] , arr [ largest ] = arr [ largest ] , arr [ i ] \n            \n            heapify ( arr , n , largest ) \n        \n    \n    n = len ( arr ) \n    \n    for i in range ( n , - 1 , - 1 ) : \n        heapify ( arr , n , i ) \n    \n    for i in range ( n - 1 , 0 , - 1 ) : \n        arr [ i ] , arr [ 0 ] = arr [ 0 ] , arr [ i ] \n        \n        heapify ( arr , i , 0 ) \n    \n    return arr \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/639": [{"task_id": "Mbpp/639", "solution": "def sample_nam ( names ) : \n    total = 0 \n    \n    for name in names : \n        if name [ 0 ] . isupper ( ) : \n            total += len ( name ) \n        \n    \n    return total \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["AbCdE", "fGH", "IJKLMnOp", "qrs", "TUVW", "xyz"]]]}], "Mbpp/748": [{"task_id": "Mbpp/748", "solution": "def capital_words_spaces ( string ) : \n    result = \"\" \n    \n    capitalize_next = False \n    \n    for char in string : \n        if char . isupper ( ) : \n            if capitalize_next : \n                result += \" \" \n            \n            capitalize_next = True \n            \n        else : \n            capitalize_next = False \n            \n        \n        result += char \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["PythonProgrammingExamples"]], "plus_fail_tests": [["MyNameIsAIAndIAmHereToHelpYou"]]}], "Mbpp/641": [{"task_id": "Mbpp/641", "solution": "def is_nonagonal ( n ) : \n    return n * ( 3 * n - 1 ) // 2 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[1000000]]}], "Mbpp/633": [{"task_id": "Mbpp/633", "solution": "def pair_xor_Sum ( arr , k ) : \n    result = 0 \n    \n    for i in range ( 32 ) : \n        count = 0 \n        \n        mask = 1 << i \n        \n        for num in arr : \n            if num & mask : \n                count += 1 \n            \n        \n        result += count * ( k - count ) * 2 \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[5, 9, 7, 6], 4]], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10]]}], "Mbpp/735": [{"task_id": "Mbpp/735", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/631": [{"task_id": "Mbpp/631", "solution": "def replace_spaces ( s ) : \n    return s . replace ( ' ' , '_' ) . replace ( '_' , ' ' ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Jumanji The Jungle"]], "plus_fail_tests": [["  Jumanji The Jungle  "]]}], "Mbpp/723": [{"task_id": "Mbpp/723", "solution": "def count_same_pair ( list1 , list2 ) : \n    count = 0 \n    \n    for i in range ( len ( list1 ) ) : \n        if list1 [ i ] == list2 [ i ] : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/736": [{"task_id": "Mbpp/736", "solution": "def left_insertion ( lst , val ) : \n    left , right = 0 , len ( lst ) \n    \n    while left < right : \n        mid = ( left + right ) // 2 \n        \n        if lst [ mid ] < val : \n            left = mid + 1 \n            \n        else : \n            right = mid \n            \n        \n    \n    return left \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/731": [{"task_id": "Mbpp/731", "solution": "import math \ndef lateralsurface_cone ( r , h ) : \n    return math . pi * r * ( h + math . sqrt ( r ** 2 + h ** 2 ) ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 12]], "plus_fail_tests": [[2.5, 8.3]]}], "Mbpp/720": [{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple ( tup , dct ) : \n    return tup + ( dct , ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/744": [{"task_id": "Mbpp/744", "solution": "def check_none ( tup ) : \n    for i in tup : \n        if i is None : \n            return True \n        \n    \n    return False \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/732": [{"task_id": "Mbpp/732", "solution": "def replace_specialchar ( text ) : \n    return text . replace ( ' ' , ':' ) . replace ( ',' , ':' ) . replace ( '.' , ':' ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/726": [{"task_id": "Mbpp/726", "solution": "def multiply_elements ( t ) : \n    return tuple ( t [ i ] * t [ i + 1 ] for i in range ( len ( t ) - 1 ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/750": [{"task_id": "Mbpp/750", "solution": "def add_tuple ( lst , tup ) : \n    return lst + list ( tup ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/721": [{"task_id": "Mbpp/721", "solution": "def maxAverageOfPath ( grid ) : \n    N = len ( grid ) \n    \n    dp = [ [ 0 ] * N for _ in range ( N ) ] \n    \n    dp [ 0 ] [ 0 ] = grid [ 0 ] [ 0 ] \n    \n    for i in range ( 1 , N ) : \n        dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + grid [ 0 ] [ i ] \n        \n        dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + grid [ i ] [ 0 ] \n        \n    \n    for i in range ( 1 , N ) : \n        for j in range ( 1 , N ) : \n            dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + grid [ i ] [ j ] \n            \n        \n    \n    max_avg = 0 \n    \n    for i in range ( N ) : \n        for j in range ( N ) : \n            max_avg = max ( identifie \n            \n        \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/643": [{"task_id": "Mbpp/643", "solution": "import re \ndef text_match_wordz_middle ( text ) : \n    pattern = r\"^(?!.*z)(.*z)(?=\\S)\" \n    \n    match = re . search ( pattern , text ) \n    \n    return match is not None \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["pythonzabc."]], "plus_fail_tests": [["zzzxyabczzz"]]}], "Mbpp/741": [{"task_id": "Mbpp/741", "solution": "def all_Characters_Same ( s ) : \n    return len ( set ( s ) ) == 1 \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/724": [{"task_id": "Mbpp/724", "solution": "def power_base_sum ( base , power ) : \n    result = 0 \n    \n    for digit in str ( base ** power ) : \n        result += int ( digit ) \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/725": [{"task_id": "Mbpp/725", "solution": "import re \ndef extract_quotation ( s ) : \n    pattern = r'\"(.*?)\"' \n    \n    return re . findall ( pattern , s ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/644": [{"task_id": "Mbpp/644", "solution": "def reverse_Array_Upto_K ( arr , k ) : \n    left = 0 \n    \n    right = k - 1 \n    \n    while left < right : \n        arr [ left ] , arr [ right ] = arr [ right ] , arr [ left ] \n        \n        left += 1 \n        right -= 1 \n    \n    return arr \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/752": [{"task_id": "Mbpp/752", "solution": "def jacobsthal_num ( n ) : \n    if n == 0 : \n        return 0 \n    elif n == 1 or n == 2 : \n        return 1 \n    \n    a , b = 0 , 1 \n    \n    for _ in range ( 3 , n + 1 ) : \n        a , b = b , a + b \n        \n    \n    return b \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[100]]}], "Mbpp/749": [{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings ( strings ) : \n    return sorted ( strings , key = int ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["4", "12", "45", "7", "0", "100", "200", "-12", "-500"]]], "plus_fail_tests": [[["10000000000", "99999999", "88888888", "7777777", "666666", "-55555", "-4444", "-333", "222", "111", "10", "9", "8", "7", "6", "5", "4", "3", "2", "1"]]]}], "Mbpp/730": [{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates ( lst ) : \n    result = [ ] \n    \n    for i in range ( len ( lst ) ) : \n        if i == 0 or lst [ i ] != lst [ i - 1 ] : \n            result . append ( lst [ i ] ) \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/742": [{"task_id": "Mbpp/742", "solution": "import math \ndef area_tetrahedron ( a ) : \n    return ( a * ( a - 1 ) * ( a - 2 ) * ( a - 3 ) ) / 24 \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/755": [{"task_id": "Mbpp/755", "solution": "def second_smallest ( numbers ) : \n    unique_numbers = list ( set ( numbers ) ) \n    \n    if len ( unique_numbers ) < 2 : \n        return None \n    \n    unique_numbers . sort ( ) \n    return unique_numbers [ 1 ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/793": [{"task_id": "Mbpp/793", "solution": "def last ( arr , target ) : \n    left , right = 0 , len ( arr ) - 1 \n    \n    result = - 1 \n    \n    while left <= right : \n        mid = ( left + right ) // 2 \n        \n        if arr [ mid ] == target : \n            result = mid \n            \n            left = mid + 1 \n            \n        elif arr [ mid ] < target : \n            left = mid + 1 \n            \n        else : \n            right = mid - 1 \n            \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/733": [{"task_id": "Mbpp/733", "solution": "def find_first_occurrence ( arr , target ) : \n    left , right = 0 , len ( arr ) - 1 \n    \n    result = - 1 \n    \n    while left <= right : \n        mid = left + ( right - left ) // 2 \n        \n        if arr [ mid ] == target : \n            result = mid \n            \n            right = mid - 1 \n            \n        elif arr [ mid ] < target : \n            left = mid + 1 \n            \n        else : \n            right = mid - 1 \n            \n        \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/769": [{"task_id": "Mbpp/769", "solution": "def Diff ( list1 , list2 ) : \n    return [ i for i in list1 if i not in list2 ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5], [6, 7, 1]]], "plus_fail_tests": [[[], [1, 2, 3]]]}], "Mbpp/740": [{"task_id": "Mbpp/740", "solution": "def tuple_to_dict ( tup ) : \n    return { tup [ i ] : tup [ i + 1 ] for i in range ( 0 , len ( tup ) , 2 ) } \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/739": [{"task_id": "Mbpp/739", "solution": "def find_Index ( n ) : \n    start = 1 \n    \n    index = 1 \n    \n    while len ( str ( start ) ) < n : \n        start += index \n        index += 1 \n    \n    return start \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[5]]}], "Mbpp/638": [{"task_id": "Mbpp/638", "solution": "def wind_chill ( velocity , temp ) : \n    \"\"\"\n    Calculate the wind chill index.\n    :param velocity: wind velocity in km/h\n    :param temp: temperature in celsius\n    :return: wind chill index rounded to the next integer\n    \"\"\" \n    if velocity < 12 or temp <= 10 : \n        return round ( temp ) \n    else : \n        wind_chill_index = 13.12 + 0.6215 * temp - 11.37 * velocity ** 0.16 + 0.3965 * temp * velocity ** 0.16 \n        \n        return round ( wind_chill_index ) \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10, 8]], "plus_fail_tests": [[0, 0]]}], "Mbpp/734": [{"task_id": "Mbpp/734", "solution": "def sum_Of_Subarray_Prod ( nums ) : \n    total_sum = 0 \n    \n    for i in range ( len ( nums ) ) : \n        prod = 1 \n        \n        for j in range ( i , len ( nums ) ) : \n            prod *= nums [ j ] \n            total_sum += prod \n        \n    \n    return total_sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/762": [{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number ( month_number ) : \n    thirty_days_months = [ 4 , 6 , 9 , 11 ] \n    \n    return month_number in thirty_days_months \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/788": [{"task_id": "Mbpp/788", "solution": "def new_tuple ( str_list , str_tuple ) : \n    return tuple ( str_list + str_tuple ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["WEB", "is"], "best"]], "plus_fail_tests": [[[], ""]]}], "Mbpp/763": [{"task_id": "Mbpp/763", "solution": "def find_min_diff ( arr , diff ) : \n    arr . sort ( ) \n    min_diff = float ( 'inf' ) \n    \n    for i in range ( len ( arr ) - 1 ) : \n        if arr [ i + 1 ] - arr [ i ] < diff : \n            min_diff = arr [ i + 1 ] - arr [ i ] \n            \n        \n    \n    return min_diff \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 5, 3, 19, 18, 25], 6]], "plus_fail_tests": [[[15, 12, 20, 30, 8, 4, 19, 37, 22, 28, 11, 25], 12]]}], "Mbpp/728": [{"task_id": "Mbpp/728", "solution": "def sum_list ( list1 , list2 ) : \n    return [ a + b for a , b in zip ( list1 , list2 ) ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/754": [{"task_id": "Mbpp/754", "solution": "def extract_index_list ( l1 , l2 , l3 ) : \n    common_elements = [ ] \n    \n    for i in range ( min ( len ( l1 ) , len ( l2 ) , len ( l3 ) ) ) : \n        if l1 [ i ] == l2 [ i ] == l3 [ i ] : \n            common_elements . append ( l1 [ i ] ) \n        \n    \n    return common_elements \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/771": [{"task_id": "Mbpp/771", "solution": "def check_expression ( expression ) : \n    stack = [ ] \n    \n    opening_brackets = [ '(' , '[' , '{' ] \n    \n    closing_brackets = [ ')' , ']' , '}' ] \n    \n    bracket_pairs = { '(' : ')' , '[' : ']' , '{' : '}' } \n    \n    for char in expression : \n        if char in opening_brackets : \n            stack . append ( char ) \n        elif char in closing_brackets : \n            if not stack or bracket_pairs [ stack . pop ( ) ] != char : \n                return False \n            \n        \n    \n    return len ( stack ) == 0 \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/809": [{"task_id": "Mbpp/809", "solution": "def check_smaller ( tup1 , tup2 ) : \n    return all ( x < y for x , y in zip ( tup1 , tup2 ) ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3], [2, 3, 4]]], "plus_fail_tests": [[[3, 7, 11, 15, 19], [2, 6, 10, 14, 18]]]}], "Mbpp/760": [{"task_id": "Mbpp/760", "solution": "def unique_Element ( nums ) : \n    return len ( set ( nums ) ) == 1 \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/757": [{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs ( lst ) : \n    count = 0 \n    \n    for i in range ( len ( lst ) ) : \n        for j in range ( i + 1 , len ( lst ) ) : \n            if lst [ i ] == lst [ j ] [ : : - 1 ] : \n                count += 1 \n            \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/767": [{"task_id": "Mbpp/767", "solution": "def get_pairs_count ( numbers , target_sum ) : \n    count = 0 \n    \n    seen = { } \n    \n    for number in numbers : \n        complement = target_sum - number \n        \n        if complement in seen : \n            count += seen [ complement ] \n        \n        if number in seen : \n            seen [ number ] += 1 \n        else : \n            seen [ number ] = 1 \n            \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/772": [{"task_id": "Mbpp/772", "solution": "def remove_length ( s , k ) : \n    return ' ' . join ( [ word for word in s . split ( ) if len ( word ) != k ] ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/807": [{"task_id": "Mbpp/807", "solution": "def first_odd ( nums ) : \n    for num in nums : \n        if num % 2 != 0 : \n            return num \n        \n    \n    return None \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/751": [{"task_id": "Mbpp/751", "solution": "def check_min_heap ( arr ) : \n    n = len ( arr ) \n    \n    for i in range ( n // 2 ) : \n        if 2 * i + 1 < n and arr [ 2 * i + 1 ] < arr [ i ] : \n            return False \n        \n        if 2 * i + 2 < n and arr [ 2 * i + 2 ] < arr [ i ] : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/770": [{"task_id": "Mbpp/770", "solution": "def odd_num_sum ( n ) : \n    sum = 0 \n    \n    for i in range ( 1 , 2 * n , 2 ) : \n        sum += i ** 4 \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/803": [{"task_id": "Mbpp/803", "solution": "def is_perfect_square ( n ) : \n    if n < 0 : \n        return False \n    \n    x = n // 2 \n    \n    seen = { x } \n    \n    while x * x != n : \n        x = ( x + ( n // x ) ) // 2 \n        \n        if x in seen : \n            return False \n        \n        seen . add ( x ) \n    \n    return True \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[true]]}], "Mbpp/745": [{"task_id": "Mbpp/745", "solution": "def divisible_by_digits ( startnum , endnum ) : \n    result = [ ] \n    \n    for i in range ( startnum , endnum + 1 ) : \n        if all ( i % int ( digit ) == 0 for digit in str ( i ) ) : \n            result . append ( i ) \n        \n    \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 22]], "plus_fail_tests": [[100, 200]]}], "Mbpp/753": [{"task_id": "Mbpp/753", "solution": "def min_k ( t , k ) : \n    t . sort ( key = lambda x : x [ 1 ] ) \n    return t [ : k ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/737": [{"task_id": "Mbpp/737", "solution": "import re \ndef check_str ( str1 ) : \n    pattern = '^[aeiou]' \n    \n    if re . search ( pattern , str1 ) : \n        return True \n    else : \n        return False \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Else"]], "plus_fail_tests": [["Anna18"]]}], "Mbpp/773": [{"task_id": "Mbpp/773", "solution": "import re \ndef occurance_substring ( string , substring ) : \n    match = re . search ( substring , string ) \n    \n    if match : \n        return ( match . group ( ) , match . start ( ) , match . end ( ) ) \n    else : \n        return None \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/785": [{"task_id": "Mbpp/785", "solution": "def tuple_str_int ( tuple_str ) : \n    return tuple ( map ( int , tuple_str . strip ( \"()\" ) . split ( \",\" ) ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/764": [{"task_id": "Mbpp/764", "solution": "def number_ctr ( s ) : \n    count = 0 \n    \n    for char in s : \n        if char . isdigit ( ) : \n            count += 1 \n        \n    \n    return count \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/791": [{"task_id": "Mbpp/791", "solution": "def remove_nested ( t ) : \n    result = [ ] \n    \n    for i in t : \n        if isinstance ( i , tuple ) : \n            result . append ( remove_nested ( i ) ) \n        else : \n            result . append ( i ) \n        \n    \n    return tuple ( result ) \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 5, 7, [4, 6], 10]]], "plus_fail_tests": [[[2, 6, 8, [5, 7], 11, [[2, 9], [6, 3]], 4]]]}], "Mbpp/765": [{"task_id": "Mbpp/765", "solution": "def is_polite ( n ) : \n    i = 1 \n    \n    while i * i <= n : \n        remainder = n % i \n        \n        if remainder == 0 and bin ( remainder ) . count ( '1' ) == 1 : \n            return i \n        \n        i += 1 \n    \n    return n \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7]], "plus_fail_tests": [[10000000]]}], "Mbpp/786": [{"task_id": "Mbpp/786", "solution": "def right_insertion ( lst , val ) : \n    left , right = 0 , len ( lst ) \n    \n    while left < right : \n        mid = ( left + right ) // 2 \n        \n        if lst [ mid ] < val : \n            left = mid + 1 \n            \n        else : \n            right = mid \n            \n        \n    \n    return left \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[7, true, 3, 6], true]]}], "Mbpp/801": [{"task_id": "Mbpp/801", "solution": "def test_three_equal ( a , b , c ) : \n    if a == b == c : \n        return 3 \n    elif a == b or b == c or a == c : \n        return 2 \n    else : \n        return 0 \n    \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/778": [{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates ( lst ) : \n    result = [ ] \n    \n    i = 0 \n    \n    while i < len ( lst ) : \n        start = i \n        \n        while i < len ( lst ) - 1 and lst [ i ] == lst [ i + 1 ] : \n            i += 1 \n        \n        result . append ( lst [ start : i + 1 ] ) \n        i += 1 \n    \n    return result \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/792": [{"task_id": "Mbpp/792", "solution": "def count_list ( lst ) : \n    return len ( lst ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 3, [4, [5, [6, [7, [8, 9]]]]]]]]}], "Mbpp/782": [{"task_id": "Mbpp/782", "solution": "def odd_length_sum ( arr ) : \n    total_sum = 0 \n    \n    n = len ( arr ) \n    \n    for i in range ( 1 , n + 1 , 2 ) : \n        for j in range ( n - i + 1 ) : \n            total_sum += sum ( arr [ j : j + i ] ) \n        \n    \n    return total_sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/775": [{"task_id": "Mbpp/775", "solution": "def odd_position ( lst ) : \n    for i in range ( 1 , len ( lst ) , 2 ) : \n        if lst [ i ] % 2 == 0 : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/780": [{"task_id": "Mbpp/780", "solution": "def find_combinations ( tuples ) : \n    combinations = [ ] \n    \n    for i in tuples : \n        for j in tuples : \n            combination = tuple ( x + y for x , y in zip ( i , j ) ) \n            \n            combinations . append ( combination ) \n        \n    \n    return combinations \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [3, 4, 5]]]], "plus_fail_tests": [[[[100, 200], [300, 400], [500, 600], [700, 800]]]]}], "Mbpp/759": [{"task_id": "Mbpp/759", "solution": "import re \ndef is_decimal ( s ) : \n    pattern = r'^\\d+\\.\\d{2}$' \n    \n    return bool ( re . match ( pattern , s ) ) \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["123"]]}], "Mbpp/800": [{"task_id": "Mbpp/800", "solution": "def remove_all_spaces ( s ) : \n    return s . replace ( ' ' , '' ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/798": [{"task_id": "Mbpp/798", "solution": "def _sum ( arr ) : \n    total = 0 \n    \n    for num in arr : \n        total += num \n    \n    return total \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/790": [{"task_id": "Mbpp/790", "solution": "def even_position ( lst ) : \n    for i in range ( 0 , len ( lst ) , 2 ) : \n        if lst [ i ] % 2 != 0 : \n            return False \n        \n    \n    return True \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 1, 4, 2, 6, 1, 8, 2, 10, 1, 12]]]}], "Mbpp/794": [{"task_id": "Mbpp/794", "solution": "import re \ndef text_starta_endb ( text ) : \n    patterns = 'a.*b$' \n    \n    if re . search ( patterns , text ) : \n        return 'Found a match!' \n    else : \n        return ( 'Not matched!' ) \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["aabAbbbc"]], "plus_fail_tests": [[""]]}], "Mbpp/630": [{"task_id": "Mbpp/630", "solution": "def get_coordinates ( coordinate ) : \n    x , y = coordinate \n    \n    return [ [ x + dx , y + dy ] for dx in range ( - 1 , 2 ) for dy in range ( - 1 , 2 ) if not ( dx == 0 and dy == 0 ) ] \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 4]]], "plus_fail_tests": [[[1, 1, 1]]]}], "Mbpp/806": [{"task_id": "Mbpp/806", "solution": "def max_run_uppercase ( s ) : \n    max_run = 0 \n    \n    current_run = 0 \n    \n    for char in s : \n        if char . isupper ( ) : \n            current_run += 1 \n            max_run = max ( max_run , current_run ) \n            \n        else : \n            current_run = 0 \n            \n        \n    \n    return max_run \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Aaa"]]}], "Mbpp/804": [{"task_id": "Mbpp/804", "solution": "def is_product_even ( nums ) : \n    for num in nums : \n        if num % 2 == 0 : \n            return True \n        \n    \n    return False \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/784": [{"task_id": "Mbpp/784", "solution": "def mul_even_odd ( nums ) : \n    even_count = 0 \n    \n    odd_count = 0 \n    \n    for num in nums : \n        if num % 2 == 0 : \n            even_count += 1 \n        else : \n            odd_count += 1 \n        \n    \n    if even_count > 0 and odd_count > 0 : \n        return even_count * odd_count \n    else : \n        return 0 \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, 5, 7, 4, 1, 6, 8]]], "plus_fail_tests": [[[-10, -5, 0, 5, 10]]]}], "Mbpp/777": [{"task_id": "Mbpp/777", "solution": "def find_sum ( lst ) : \n    unique_elements = set ( lst ) \n    \n    sum_of_unique = 0 \n    \n    for element in unique_elements : \n        if lst . count ( element ) == 1 : \n            sum_of_unique += element \n        \n    \n    return sum_of_unique \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 1, 1, 4, 5, 6]]], "plus_fail_tests": [[[-1, -2, -3, -1, -1, -4, -5, -6]]]}], "Mbpp/796": [{"task_id": "Mbpp/796", "solution": "def return_sum ( dictionary ) : \n    return sum ( dictionary . values ( ) ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/799": [{"task_id": "Mbpp/799", "solution": "def left_rotate ( n , d ) : \n    d = d % 32 \n    \n    return ( ( n << d ) | ( n >> ( 32 - d ) ) ) & 0xffffffff \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/808": [{"task_id": "Mbpp/808", "solution": "def check_K ( tup , k ) : \n    return k in tup \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/787": [{"task_id": "Mbpp/787", "solution": "import re \ndef text_match_three ( text ) : \n    patterns = 'ab{3}' \n    \n    if re . search ( patterns , text ) : \n        return 'Found a match!' \n    else : \n        return ( 'Not matched!' ) \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["ac"]], "plus_fail_tests": [[""]]}], "Mbpp/722": [{"task_id": "Mbpp/722", "solution": "def filter_data ( students , min_height , min_weight ) : \n    filtered_students = { } \n    \n    for name , ( height , weight ) in students . items ( ) : \n        if height > min_height and weight > min_weight : \n            filtered_students [ name ] = ( height , weight ) \n            \n        \n    \n    return filtered_students \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"Cierra Vega": [6.2, 70], "Alden Cantrell": [5.9, 65], "Kierra Gentry": [6.0, 68], "Pierre Cox": [5.8, 66]}, 6.0, 70]], "plus_fail_tests": [[{"Alice": [5.6, 60], "Bob": [6.1, 70], "Charlie": [5.9, 65], "Dave": [5.11, 72], "Eve": [6.0, 68], "Frank": [5.7, 63]}, 5.8, 65]]}], "Mbpp/766": [{"task_id": "Mbpp/766", "solution": "def pair_wise ( lst ) : \n    return [ ( lst [ i ] , lst [ i + 1 ] ) for i in range ( len ( lst ) - 1 ) ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/743": [{"task_id": "Mbpp/743", "solution": "def rotate_right ( lst , n ) : \n    return lst [ - n : ] + lst [ : - n ] \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/797": [{"task_id": "Mbpp/797", "solution": "def sum_in_range ( l , r ) : \n    sum = 0 \n    \n    for i in range ( l , r + 1 ) : \n        if i % 2 != 0 : \n            sum += i \n        \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/805": [{"task_id": "Mbpp/805", "solution": "def max_sum_list ( lists ) : \n    return max ( lists , key = sum ) \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/758": [{"task_id": "Mbpp/758", "solution": "def unique_sublists ( lst ) : \n    sublists = [ ] \n    \n    for sublist in lst : \n        sublists . append ( tuple ( sublist ) ) \n    \n    sublist_counts = { } \n    \n    for sublist in sublists : \n        if sublist in sublist_counts : \n            sublist_counts [ sublist ] += 1 \n        else : \n            sublist_counts [ sublist ] = 1 \n            \n        \n    \n    return sublist_counts \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/453": [{"task_id": "Mbpp/453", "solution": "def sumofFactors ( n ) : \n    sum = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        if n % i == 0 : \n            if i % 2 == 0 : \n                sum += i \n            \n        \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/260": [{"task_id": "Mbpp/260", "solution": "def is_prime ( n ) : \n    if n <= 1 : \n        return False \n    \n    for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : \n        if n % i == 0 : \n            return False \n        \n    \n    return True \n\ndef newman_prime ( n ) : \n    i = 2 \n    \n    while True : \n        if is_prime ( i ) : \n            newman_sum = sum ( [ int ( digit ) for digit in str ( i ) ] ) \n            \n            if newman_sum == n : \n                return i \n            \n        \n        i += 1 \n    \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[100]]}], "Mbpp/781": [{"task_id": "Mbpp/781", "solution": "def count_divisors ( n ) : \n    count = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        if n % i == 0 : \n            count += 1 \n        \n    \n    return count % 2 == 0 \n\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[987654321]]}], "Mbpp/264": [{"task_id": "Mbpp/264", "solution": "def dog_age ( age ) : \n    dog_year = 0 \n    \n    human_year = 0 \n    \n    while age > 0 : \n        age -= age // 4 \n        dog_year += 1 \n        human_year += 1 \n    \n    return human_year + dog_year \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[12]], "plus_fail_tests": [[100]]}], "Mbpp/271": [{"task_id": "Mbpp/271", "solution": "def even_Power_Sum ( n ) : \n    sum = 0 \n    \n    for i in range ( 1 , n + 1 ) : \n        sum += ( 2 * i ) ** 5 \n    \n    return sum \n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/255": [{"task_id": "Mbpp/255", "solution": "def combinations_colors ( colors , length ) : \n    result = [ ] \n    \n    def generate_combinations ( current_combination , index ) : \n        if len ( current_combination ) == length : \n            result . append ( tuple ( current_combination ) ) \n            return \n        \n        for i in range ( index , len ( colors ) ) : \n            current_combination . append ( colors [ i ] ) \n            generate_combinations ( current_combination , i + 1 ) \n            current_combination . pop ( ) \n        \n    \n    generate_combinations ( [ ] , 0 ) \n    return result \n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Red", "Green", "Blue"], 2]], "plus_fail_tests": [[["A", "B", "C", "D"], 4]]}]}}